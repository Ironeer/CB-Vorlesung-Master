<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.119.0">
    <meta name="generator" content="Relearn 5.22.1">
    <meta name="description" content="">
    <meta name="author" content="cagix">
    <title>Lexer</title>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing.html" rel="canonical" type="text/html" title="Lexer">

    
    

    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/images/logo.png?1697015446" rel="icon" type="image/png">

    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fontawesome-all.min.css?1697015446" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fontawesome-all.min.css?1697015446" rel="stylesheet"></noscript>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/nucleus.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/auto-complete.css?1697015446" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/auto-complete.css?1697015446" rel="stylesheet"></noscript>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/perfect-scrollbar.min.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fonts.css?1697015446" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fonts.css?1697015446" rel="stylesheet"></noscript>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/theme.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/theme-auto.css?1697015446" rel="stylesheet" id="R-variant-style">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/variant.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/print.css?1697015446" rel="stylesheet" media="print">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/format-print.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/ie.css?1697015446" rel="stylesheet">
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/url.js?1697015446"></script>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/variant.js?1697015446"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/index.search.js";
      var root_url="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_Reset_view = 'Reset view';
      window.T_View_reset = 'View reset!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/www.hsbi.de\/elearning\/data\/FH-Bielefeld\/lm_data\/lm_1371719/';
      window.variants && variants.init( [ 'auto', 'zen-light', 'zen-dark', 'relearn-bright', 'relearn-light', 'relearn-dark' ] );
    </script><style type="text/css">

 
.center {
    align-content: center;
    text-align: center;
    margin: auto;
}
.alert {
    color: #ff3333;
}
.bsp {
    padding: 0.05cm;
    border-width: 0.05cm;
    border-style: solid;
    border-color: #ddd;
    background-color: #ddd;
    border-radius: 25px;
    float: right;
}
.cbox {
    padding: 0.2cm;
    border-width: 0.1cm;
    border-style: solid;
    border-color: #4070a0;
    background-color: #f2f2f2;
    margin: auto;
    width: 60%;
    text-align: center;
    overflow: auto;
}
.blueArrow {
    color: #4070a0;
    font-family: "Courier New", "Courier", monospace;
    font-weight: bold;
}
.origin {
    background-color: #ededed;
    font-size: 0.8em;
}
.showme {
    background-color: #ededed;
    font-size: 0.8em;
}


 
.tldr {
    background: #dbe4ed;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.recap {
    
    
   margin: 4px 0px 26px 0px;
}
.bib {
    background: #dbe4ed;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.outcomes {
    background: #d9e9d5;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.quizzes {
    background: #d9e9d5;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.challenges {
    background: #ebe4d6;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.assignments {
    background: #ebe4d6;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
h1.tldr, h1.recap, h1.bib, h1.outcomes, h1.quizzes, h1.challenges, h1.assignments {
    padding: 0px;
}


 
.noJsAlert {
    padding: 20px;
    background-color: #f44336;  
    color: white;
    margin-bottom: 15px;
}


 
.embed-video-player {
    position: relative;
    padding-bottom: 56%;
    height: 0;
    overflow: hidden;
}
.youtube-player {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border:0;
}


 
#header-wrapper {
    padding:0.6rem;
}


 
#shortcuts {
    padding-top: 2.0rem;
}


 
#chapter p {
    text-align: left;
}


 
figcaption h4 {
    margin-top:-2.5rem;
}
.border1 {
    border:1px solid black;
}

 
td ul, td ol {
    margin: 0 0 1rem 0.5rem;
    padding: 0 0 0 0.5rem;
}

 
h1 { font-size:2.8rem !important;}
h2 { font-size:2.2rem; margin:1.2rem 0}
h3 { font-size:1.9rem; text-align:left !important; font-weight:400 !important;}
h4 { font-size:1.6rem}
h5 { font-size:1.3rem}
h6 { font-size:1rem}

h2 {
    width:100% !important;
    border-bottom:1px solid #5e5e5e !important;
    padding-bottom: 2px;
}
.tldr h2, .recap h2, .bib h2, .outcomes h2, .quizzes h2, .challenges h2, .assignments h2 {
    margin:0.5rem 0
}

.btn-crossreference, .btn-crossreference:hover {
    cursor: initial;
}

</style>

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <span class="topbar-breadcrumbs highlightable">
            Lexer
          </span>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="lexer">Lexer</h1>

<p>Der Lexer (auch &quot;Scanner&quot;) soll den Zeichenstrom in eine Folge von Token
zerlegen. Zur Spezifikation der Token werden in der Regel reguläre Ausdrücke
verwendet.</p>

<ul class="children children-li children-sort-">
	
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/regular.html">Reguläre Sprachen, Ausdrucksstärke</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table.html">Lexer: Tabellenbasierte Implementierung</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/recursive.html">Lexer: Handcodierte Implementierung</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/antlr-lexing.html">Lexer mit ANTLR generieren</a></li>
</ul>

            <footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Lexer</h1>
<article class="default">
<h1>Reguläre Sprachen, Ausdrucksstärke</h1>



    
    




    
    
        
        
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="far fa-file-powerpoint"></i> Annotierte Folien</div>
  <div class="box-content">

<ul> <li><a href='https://raw.githubusercontent.com/Compiler-CampusMinden/AnnotatedSlides/master/lexing_regular.ann.ma.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Annotierte Folien: Reguläre Sprachen, Ausdrucksstärke</a></li></ul></div>
</div>




    <h1 id="motivation">Motivation</h1>
<h2 id="was-muss-ein-compiler-wohl-als-erstes-tun">Was muss ein Compiler wohl als erstes tun?</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="themen-für-heute">Themen für heute</h2>
<ul>
<li>Endliche Automaten</li>
<li>Reguläre Ausdrücke</li>
</ul>
<h1 id="endliche-automaten">Endliche Automaten</h1>
<h2 id="alphabete">Alphabete</h2>
<p><strong>Def.:</strong> Ein <em>Alphabet</em> 
<span class="math align-center">$\Sigma$</span> ist eine endliche, nicht-leere Menge von Symbolen. Die Symbole eines Alphabets heißen <em>Buchstaben</em>.</p>
<p><strong>Def.:</strong> Ein <em>Wort</em> 
<span class="math align-center">$w$</span> <em>über einem Alphabet</em> 
<span class="math align-center">$\Sigma$</span> ist eine endliche Folge von Symbolen aus 
<span class="math align-center">$\Sigma$</span>.

<span class="math align-center">$\epsilon$</span> ist das leere Wort.
Die <em>Länge</em> 
<span class="math align-center">$\vert w \vert$</span> eines Wortes 
<span class="math align-center">$w$</span> ist die Anzahl von Buchstaben, die es enthält (Kardinalität).</p>
<p><strong>Def.:</strong>

<span class="math align-center">$\Sigma^k = \lbrace w\ \text{über}\ \Sigma\ \vert\ \vert w \vert = k \rbrace$</span></p>
<p>
<span class="math align-center">$\Sigma^{\ast} = \bigcup\limits_{i \in \mathbb{N}_0} \Sigma^i$</span> (die Kleene-Hülle von 
<span class="math align-center">$\Sigma$</span>)</p>

<span class="math align-center">$\Sigma^+ = \bigcup\limits_{i \in \mathbb{N}} \Sigma^i$</span>
<h2 id="sprachen-über-alphabete">Sprachen über Alphabete</h2>
<p><strong>Def.:</strong> Seien 
<span class="math align-center">$x = a_1 a_2 \ \ldots \ a_n$</span> und 
<span class="math align-center">$y = b_1b_2 \  \ldots \  b_m$</span> Wörter. Wir nennen 
<span class="math align-center">$xy = x \circ y = a_1 \  \ldots \  a_nb_1 \ \ldots \ b_m$</span> die <em>Konkatenation</em> von 
<span class="math align-center">$x$</span> und 
<span class="math align-center">$y$</span>.</p>
<p><strong>Def.:</strong> <em>Eine Sprache</em> 
<span class="math align-center">$L$</span> <em>über einem Alphabet</em> 
<span class="math align-center">$\Sigma$</span> ist eine Teilmenge von 
<span class="math align-center">$\Sigma^{\ast} :\ L \subseteq\Sigma^{\ast}$</span></p>
<h2 id="deterministische-endliche-automaten">Deterministische endliche Automaten</h2>
<p><strong>Def.:</strong> Ein <em>deterministischer endlicher Automat</em> (DFA) ist ein 5-Tupel

<span class="math align-center">$A = (Q, \Sigma, \delta, q_0, F)$</span> mit</p>
<ul>
<li>
<span class="math align-center">$Q$</span> : eine endliche Menge von Zuständen</li>
<li>
<span class="math align-center">$\Sigma$</span> : ein Alphabet von Eingabesymbolen</li>
<li>
<span class="math align-center">$\delta$</span> : die Übergangsfunktion 
<span class="math align-center">$(Q \times \Sigma) \rightarrow Q, \delta$</span> kann partiell sein</li>
<li>
<span class="math align-center">$q_0 \in Q$</span> : der Startzustand</li>
<li>
<span class="math align-center">$F \subseteq Q$</span> : die Menge der Endzustände</li>
</ul>
<h2 id="die-übergangsfunktion">Die Übergangsfunktion</h2>
<p><strong>Def.:</strong> Wir definieren 
<span class="math align-center">$\delta^{\ast}: (Q \times \Sigma^{\ast}) \rightarrow Q$</span>: induktiv wie folgt:</p>
<ul>
<li>Basis: 
<span class="math align-center">$\delta^{\ast}(q, \epsilon) = q\ \forall q \in Q$</span></li>
<li>Induktion: 
<span class="math align-center">$\delta^{\ast}(q, a_1, \ldots, a_n) = \delta(\delta^{\ast}(q, a_1, \ldots , a_{n-1}), a_n)$</span></li>
</ul>
<p><strong>Def.:</strong> Ein DFA akzeptiert ein Wort 
<span class="math align-center">$w \in \Sigma^{\ast}$</span> genau dann, wenn 
<span class="math align-center">$\delta^{\ast}(q_0, w) \in F.$</span></p>
<p><strong>Def.:</strong> Die Sprache eines DFA 
<span class="math align-center">$A\ L(A)$</span> ist definiert durch:</p>

<span class="math align-center">$L(A) =\lbrace w\ \vert \delta^{\ast}(q_0, w) \in F \rbrace$</span>
<h2 id="beispiel">Beispiel</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="nichtdeterministische-endliche-automaten">Nichtdeterministische endliche Automaten</h2>
<p><strong>Def.:</strong> Ein <em>nichtdeterministischer endlicher Automat</em> (NFA) ist ein 5-Tupel

<span class="math align-center">$A = (Q, \Sigma, \delta, q_0, F)$</span> mit</p>
<ul>
<li>
<span class="math align-center">$Q$</span>: eine endliche Menge von Zuständen</li>
<li>
<span class="math align-center">$\Sigma$</span>: ein Alphabet von Eingabesymbolen</li>
<li>
<span class="math align-center">$\delta$</span>: die Übergangsfunktion 
<span class="math align-center">$(Q \times \Sigma) \rightarrow \mathcal{P}(Q)$</span></li>
<li>
<span class="math align-center">$q_0 \in Q$</span>: der Startzustand</li>
<li>
<span class="math align-center">$F \subseteq Q$</span>: die Menge der Endzustände</li>
</ul>
<h2 id="die-übergangsfunktion-eines-nfas">Die Übergangsfunktion eines NFAs</h2>
<p><strong>Def.:</strong> Wir definieren 
<span class="math align-center">$\delta^{\ast}: (Q \times \Sigma) \rightarrow \mathcal{P}(Q):$</span>
induktiv wie folgt:</p>
<ul>
<li>
<p>Basis: 
<span class="math align-center">$\delta^{\ast}(q, \epsilon) = q\ \forall q \in Q$</span></p>
</li>
<li>
<p>Induktion: Sei 
<span class="math align-center">$w \in \Sigma^{\ast}, w = xa, x \in \Sigma^{\ast}, a \in \Sigma$</span> mit</p>
<p>
<span class="math align-center">$\delta^{\ast}(q, x) = \lbrace p_1,\ \ldots,\  p_k \rbrace, p_i \in Q$</span>, sei</p>
<p>
<span class="math align-center">$A = \bigcup\limits_{i = 1}^k \delta(p_i, a) = \lbrace r_1, \ldots r_m \rbrace, r_j \in Q$</span>.</p>
<p>Dann ist 
<span class="math align-center">$\delta^{\ast}(q, w) = \lbrace r_1,\  \ldots\ , r_m\rbrace$</span>.</p>
</li>
</ul>
<h2 id="wozu-nfas-im-compilerbau">Wozu NFAs im Compilerbau?</h2>
<p>Pattern Matching geht mit NFAs.</p>
<p>NFAs sind so nicht zu programmieren, aber:</p>
<p><strong>Satz:</strong> Eine Sprache 
<span class="math align-center">$L$</span> wird von einem NFA akzeptiert 
<span class="math align-center">$\Leftrightarrow L$</span> wird von einem DFA akzeptiert.</p>
<h2 id="konvertierung-eines-nfas-in-einen-dfa">Konvertierung eines NFAs in einen DFA</h2>
<p>Gegeben: Ein NFA 
<span class="math align-center">$A = (Q, \Sigma, \delta, q_0, F)$</span></p>
<p>Wir konstruieren einen DFA 
<span class="math align-center">$A' = (Q', \Sigma, \delta ', q_0, F')$</span> wie folgt:</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/regular/nfa2dfa.png" alt="Konvertierung NFA in DFA" width="45%" height="auto">
    <figcaption><p>Konvertierung NFA in DFA</p></figcaption>
</figure>
<h2 id="beispiel-1">Beispiel</h2>
<table>
<thead>
<tr>
<th style="text-align:right">
<span class="math align-center">$\delta$</span></th>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">
<span class="math align-center">$\rightarrow q_0$</span></td>
<td style="text-align:center">
<span class="math align-center">$\lbrace q_0\rbrace$</span></td>
<td style="text-align:center">
<span class="math align-center">$\lbrace q_1, q_2\rbrace$</span></td>
</tr>
<tr>
<td style="text-align:right">
<span class="math align-center">$q_1$</span></td>
<td style="text-align:center">
<span class="math align-center">$\lbrace q_2\rbrace$</span></td>
<td style="text-align:center">
<span class="math align-center">$\lbrace q_1\rbrace$</span></td>
</tr>
<tr>
<td style="text-align:right">*
<span class="math align-center">$q_2$</span></td>
<td style="text-align:center">-</td>
<td style="text-align:center">
<span class="math align-center">$\lbrace q_0, q_2\rbrace$</span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">
<span class="math align-center">$\delta$</span>'</th>
<th style="text-align:left">a</th>
<th style="text-align:left">b</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">
<span class="math align-center">$\rightarrow$</span> 
<span class="math align-center">$\lbrace q_0\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_1,q_2\rbrace$</span></td>
</tr>
<tr>
<td style="text-align:left">*
<span class="math align-center">$\lbrace q_1 q_2\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_2\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0, q_1, q_2\rbrace$</span></td>
</tr>
<tr>
<td style="text-align:left">*
<span class="math align-center">$\lbrace q_2\rbrace$</span></td>
<td style="text-align:left">-</td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0,q_2\rbrace$</span></td>
</tr>
<tr>
<td style="text-align:left">*
<span class="math align-center">$\lbrace q_0, q_2\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0, q_1, q_2\rbrace$</span></td>
</tr>
<tr>
<td style="text-align:left">*
<span class="math align-center">$\lbrace q_0, q_1, q_2\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0, q_2\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0, q_1, q_2\rbrace$</span></td>
</tr>
</tbody>
</table>
<h2 id="minimierung-eines-dfas">Minimierung eines DFAs</h2>
<p>Ist ist der DFA 
<span class="math align-center">$A$</span> nicht vollständig, wird ein Fehlerzustand 
<span class="math align-center">$q_e$</span>, der kein Endzustand ist, hinzugefügt und in alle leeren Tabellenfelder eingetragen.</p>
<p>Dann wird eine Matrix generiert, die für alle Zustandspaare sagt, ob die beiden Zustände zu einem verschmelzen können.</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/regular/minimize_dfa.png" alt="DFA Minimierung" width="50%" height="auto">
    <figcaption><p>DFA Minimierung</p></figcaption>
</figure>
<h1 id="reguläre-ausdrücke">Reguläre Ausdrücke</h1>
<h2 id="operatoren-auf-sprachen">Operatoren auf Sprachen</h2>
<p><strong>Def.:</strong> Seien <em>L</em> und <em>M</em> Sprachen.</p>
<ul>
<li>
<span class="math align-center">$L \cup M = \lbrace w \mid w \in L \vee w \in M \rbrace$</span></li>
<li>
<span class="math align-center">$LM = L \cdot M = L \circ M = \lbrace vw \mid v \in L \land w \in M\rbrace$</span></li>
<li>Die Kleene-Hülle einer Sprache:
<ul>
<li>Basis: 
<span class="math align-center">$L^0 = \lbrace \epsilon\rbrace$</span></li>
<li>Induktion: 
<span class="math align-center">$L^i = \lbrace xw\mid x \in L^{i-1}, w \in L, i > 0\rbrace$</span>, 
<span class="math align-center">$L^{\ast} = \bigcup\limits_{i \ge 0}L^i$</span>, 
<span class="math align-center">$L^+ = \bigcup\limits_{i > 0}L^i$</span></li>
</ul>
</li>
</ul>
<h2 id="reguläre-ausdrücke-1">Reguläre Ausdrücke</h2>
<p><strong>Def.:</strong> Induktive Definition von regulären Ausdrücken (<em>regex</em>) und der von ihnen repräsentierten Sprache:</p>
<ul>
<li>Basis:
<ul>
<li>
<span class="math align-center">$\epsilon$</span> und 
<span class="math align-center">$\emptyset$</span> sind reguläre Ausdrücke mit 
<span class="math align-center">$L(\epsilon) =  \lbrace \epsilon\rbrace$</span>, 
<span class="math align-center">$L(\emptyset)=\emptyset$</span></li>
<li>Sei 
<span class="math align-center">$a$</span> ein Symbol 
<span class="math align-center">$\Rightarrow$</span> 
<span class="math align-center">$a$</span> ist ein regex mit 
<span class="math align-center">$L(a) = \lbrace a\rbrace$</span></li>
</ul>
</li>
<li>Induktion: Seien 
<span class="math align-center">$E,\ F$</span> reguläre Ausdrücke. Dann gilt:
<ul>
<li>
<span class="math align-center">$E+F$</span> ist ein regex und bezeichnet die Vereinigung 
<span class="math align-center">$L(E + F) = L(E)\cup L(F)$</span></li>
<li>
<span class="math align-center">$EF$</span> ist ein regex und bezeichnet die Konkatenation 
<span class="math align-center">$L(EF) = L(E)L(F)$</span></li>
<li>
<span class="math align-center">$E^{\ast}$</span> ist ein regex und bezeichnet die Kleene-Hülle 
<span class="math align-center">$L(E^{\ast})=(L(E))^{\ast}$</span></li>
<li>
<span class="math align-center">$(E)$</span> ist ein regex mit 
<span class="math align-center">$L((E)) = L(E)$</span></li>
</ul>
</li>
</ul>
<p>Vorrangregeln der Operatoren für reguläre Ausdrücke: *, Konkatenation, +</p>
<h2 id="wichtige-identitäten">Wichtige Identitäten</h2>
<p><strong>Satz:</strong> Sei 
<span class="math align-center">$A$</span> ein DFA 
<span class="math align-center">$\Rightarrow \exists$</span> regex 
<span class="math align-center">$R$</span> mit 
<span class="math align-center">$L(A) = L(R)$</span>.</p>
<p><strong>Satz:</strong> Sei 
<span class="math align-center">$E$</span> ein regex 
<span class="math align-center">$\Rightarrow \exists$</span> DFA 
<span class="math align-center">$A$</span> mit 
<span class="math align-center">$L(E) = L(A)$</span>.</p>
<h2 id="beispiel-umwandlung-eines-regex-in-einen-nfa">Beispiel: Umwandlung eines regex in einen NFA</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="formale-grammatiken">Formale Grammatiken</h2>
<p><strong>Def.:</strong> Eine <em>formale Grammatik</em> ist ein 4-Tupel 
<span class="math align-center">$G=(N,T,P,S)$</span> aus</p>
<ul>
<li>
<span class="math align-center">$N$</span>: einer endlichen Menge von 
<span class="math align-center">$Nichtterminalen$</span></li>
<li><em>T</em>: einer endlichen Menge von <em>Terminalen</em>, 
<span class="math align-center">$N \cap T = \emptyset$</span></li>
<li>
<span class="math align-center">$S \in N$</span>: dem <em>Startsymbol</em></li>
<li><em>P</em>: einer endlichen Menge von <em>Produktionen</em> der Form: 
<span class="math align-center">$X \rightarrow Y$</span> mit 
<span class="math align-center">$X \in (N \cup T)^{\ast} N (N \cup T)^{\ast}, Y \in (N \cup T)^{\ast}$</span></li>
</ul>
<h2 id="ableitungen">Ableitungen</h2>
<p><strong>Def.:</strong> Sei 
<span class="math align-center">$G = (N, T, P, S)$</span> eine Grammatik, sei 
<span class="math align-center">$\alpha A \beta$</span> eine Zeichenkette über

<span class="math align-center">$(N \cup T)^{\ast}$</span> und sei 
<span class="math align-center">$A$</span> 
<span class="math align-center">$\rightarrow \gamma$</span> eine Produktion von 
<span class="math align-center">$G$</span>.</p>
<p>Wir sagen:

<span class="math align-center">$\alpha A \beta \Rightarrow \alpha \gamma \beta$</span> (
<span class="math align-center">$\alpha A \beta$</span> leitet 
<span class="math align-center">$\alpha \gamma \beta$</span> ab).</p>
<p><strong>Def.:</strong> Wir definieren die Relation 
<span class="math align-center">$\overset{\ast}{\Rightarrow}$</span> induktiv wie folgt:</p>
<ul>
<li>Basis: 
<span class="math align-center">$\forall \alpha \in (N \cup T)^{\ast} \alpha \overset{\ast}{\Rightarrow} \alpha$</span> (Jede Zeichenkette leitet sich selbst ab.)</li>
<li>Induktion: Wenn 
<span class="math align-center">$\alpha \overset{\ast}{\Rightarrow} \beta$</span> und

<span class="math align-center">$\beta\Rightarrow \gamma$</span> dann 
<span class="math align-center">$\alpha \overset{\ast}{\Rightarrow} \gamma$</span></li>
</ul>
<p><strong>Def.:</strong> Sei 
<span class="math align-center">$G = (N, T ,P, S)$</span> eine formale Grammatik.
Dann ist 
<span class="math align-center">$L(G) = \lbrace w \in T^{\ast} \mid S \overset{\ast}{\Rightarrow} w\rbrace$</span> die von 
<span class="math align-center">$G$</span> erzeugte Sprache.</p>
<h2 id="reguläre-grammatiken">Reguläre Grammatiken</h2>
<p><strong>Def.:</strong> Eine <em>reguläre (oder type-3-) Grammatik</em> ist eine formale Grammatik mit den folgenden Einschränkungen:</p>
<ul>
<li>
<p>Alle Produktionen sind entweder von der Form</p>
<ul>
<li>
<span class="math align-center">$X \to aY$</span> mit 
<span class="math align-center">$X \in N, a \in T, Y \in N$</span> (<em>rechtsreguläre</em> Grammatik) oder</li>
<li>
<span class="math align-center">$X \to Ya$</span> mit 
<span class="math align-center">$X \in N, a \in T, Y \in N$</span> (<em>linksreguläre</em> Grammatik)</li>
</ul>
</li>
<li>
<p>
<span class="math align-center">$X\rightarrow\epsilon$</span> ist in beiden Fällen erlaubt.</p>
</li>
</ul>
<h2 id="reguläre-sprachen">Reguläre Sprachen</h2>
<p><strong>Satz:</strong> Die von rechtsregulären Grammatiken erzeugten Sprachen sind genau die von linksregulären Grammatiken erzeugten Sprachen. Beide werden <em>reguläre</em> Sprachen genannt.</p>
<p><strong>Satz:</strong> Die von regulären Ausdrücken beschriebenen Sprachen sind die regulären Sprachen.</p>
<h2 id="das-pumping-lemma-für-reguläre-sprachen">Das Pumping Lemma für reguläre Sprachen</h2>
<p><strong>Satz:</strong> Das <em>Pumping Lemma für reguläre Sprachen</em>:</p>
<p>Sei 
<span class="math align-center">$L$</span> eine reguläre Sprache.</p>
<p>
<span class="math align-center">$\Rightarrow \exists$</span> Konstante 
<span class="math align-center">$n \in \mathbb{N}$</span>:</p>
<p>
<span class="math align-center">$\underset{\underset{|w| \geq n} {w \in L}}\forall \exists x, y, z \in \Sigma^{*}$</span> mit 
<span class="math align-center">$w = xyz, y \neq \epsilon, |xy| \leq n:$</span></p>

<span class="math align-center">$\underset{k \geq 0} \forall xy^{k}z \in L$</span>
<h2 id="abschlusseigenschaften-regulärer-sprachen">Abschlusseigenschaften regulärer Sprachen</h2>
<p>Die Klasse der regulären Sprachen ist abgeschlossen unter</p>
<ul>
<li>Vereinigung</li>
<li>Konkatenation</li>
<li>Kleene-Stern</li>
<li>Komplementbildung</li>
<li>Durchschnitt</li>
</ul>
<h2 id="entscheidbarkeit-für-reguläre-sprachen">Entscheidbarkeit für reguläre Sprachen</h2>
<p><strong>Satz:</strong> Es ist entscheidbar,</p>
<ul>
<li>ob eine gegebene reguläre Sprache leer ist</li>
<li>ob 
<span class="math align-center">$w \in \Sigma^{\ast}$</span> in einer gegebenen regulären Sprache enthalten ist (Das &quot;Wort-Problem&quot;)</li>
<li>ob zwei reguläre Sprachen äquivalent sind</li>
</ul>
<h2 id="grenzen-der-regulären-sprachen">Grenzen der regulären Sprachen</h2>
<p>Reguläre Sprachen sind von ihrer Struktur her einfach. Schon Sprachen, in denen etwas &quot;gematcht&quot; werden muss, lassen sich nicht mehr regulär beschreiben, weil z. B. die fixe Anzahl von Zuständen eines DFAs die Erkennung solcher Sprachen verhindert.</p>
<h2 id="wozu-das-ganze">Wozu das Ganze?</h2>
<p>Im Compilerbau werden reguläre Ausdrücke benutzt, um die Schlüsselwörter und weitere Symbole der zu erkennenden Sprache anzugeben. Daraus wird mit Hilfe eines Generators, der aus den regulären Ausdrücken DFAs (oder einen großen DFA) macht, der sog. Scanner oder Lexer genannt, generiert. Seine Aufgabe ist es, die Folge von Zeichen in der Quelldatei in eine Folge von sog. Token umzuwandeln. Z. B. wird so aus den Zeichen des Schlüsselwortes <em>while</em> im Programmtext das Token für <em>while</em> gemacht, das in der Syntaxanalyse weiterverarbeitet wird. Die Tokenfolge eines Programms ist ein Wort einer Sprache, die der Parser erkennt. Jedes vom Lexer erkannte Token ist dort also ein terminales Symbol.</p>
<h2 id="ein-lexer-ist-mehr-als-ein-dfa">Ein Lexer ist mehr als ein DFA</h2>
<p>Was ist zu beachten:</p>
<ul>
<li>Man braucht mindestens eine Liste von Paaren aus regulären Ausdrücken und Tokennamen.</li>
<li>Neben den Schlüsselwörtern und Symbolen wie (,), *, 
<span class="math align-center">$\ldots$</span> müssen auch Namen für Variablen, Funktionen, Klassen, Methoden, 
<span class="math align-center">$\ldots$</span> (sog. Identifier) erkannt werden</li>
<li>Namen haben meist eine gewisse Struktur, die sich mit regulären Ausdrücken beschreiben lassen.</li>
<li>Erlaubte Token sind in der Grammatik des Parsers beschrieben, d. h. für literale Namen, Strings, Zahlen liefert der Scanner zwei Werte:
<ul>
<li>z.  B. <code>&lt;ID, &quot;radius&quot;&gt;</code>, <code>&lt;Integerzahl, 558&gt;</code></li>
</ul>
</li>
<li>Kommentare und Strings müssen richtig erkannt werden. (Schachtelungen)</li>
</ul>
<p>Man kann natürlich auch einen Lexer selbst programmieren, d. h. die DFAs für die regulären Ausdrücke implementieren.</p>
<h2 id="automatisch-oder-händisch">Automatisch oder händisch</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h1 id="wrap-up">Wrap-Up</h1>
<h2 id="wrap-up-1">Wrap-Up</h2>
<ul>
<li>Definition und Aufgaben von Lexern</li>
<li>DFAs und NFAs</li>
<li>Reguläre Ausdrücke</li>
<li>Reguläre Grammatiken</li>
<li>Zusammenhänge zwischen diesen Mechanismen und Lexern, bzw. Lexergeneratoren</li>
</ul>


    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_aho2013compilers'>[aho2013compilers] <strong>Compilers: Pearson New International Edition: Principles, Techniques, and Tools</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Education Limited, 2013. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-2920-3723-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-2920-3723-3</a>.<br><em>Abschnitt 2.6 und Kapitel 3</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li> <li id='id_Torczon2012'>[Torczon2012] <strong>Engineering a Compiler</strong><br>Torczon, L. und Cooper, K., Elsevier MK, 2012. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-1208-8478-0' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-1208-8478-0</a>.<br><em>Kapitel 2</em></li></ul></div>
</div>



    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) DFAs</li> <li>(K1) NFAs</li> <li>(K1) Reguläre Ausdrücke</li> <li>(K1) Reguläre Grammatiken</li> <li>(K2) Zusammenhänge und Gesetzmäßigkeiten bzgl. der oben genannten Konstrukte</li> <li>(K3) DFAs, NFAs, reguläre Ausdrücke, reguläre Grammatiken entwickeln</li> <li>(K3) Herausfinden, ob eine Sprache regulär ist</li> <li>(K3) Einen DFA entwickeln, der alle Schlüsselwörter, Namen und weitere Symbole einer Programmiersprache akzeptiert</li></ul></div>
</div>



    








<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Lexer: Tabellenbasierte Implementierung</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p><a href="#R-image-e2a9b91052dcc8e8aae5a97d143716b9" class="lightbox-link"><img src="images/architektur_cb_lexer.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e2a9b91052dcc8e8aae5a97d143716b9"><img src="images/architektur_cb_lexer.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Der Lexer (auch &quot;Scanner&quot;) soll den Zeichenstrom in eine Folge von Token
zerlegen. Zur Spezifikation der Token werden reguläre Ausdrücke verwendet.
Diese können über verschiedene Schritte in einen zugehörigen DFA transformiert
werden, der wiederum über Tabellen dargestellt werden kann (vgl. auch
<a href="regular.md">Reguläre Sprachen, Ausdrucksstärke</a>).</p>
<p>Mit Hilfe der (üblicherweise von Scanner-Generatoren generierten) Tabellen kann
ein Lexer implementiert werden (&quot;tabellenbasierte Implementierung&quot;). Zur Steigerung
der Effizienz kann die Tabelle in den Code integriert werden (etwa mit Sprungbefehlen,
&quot;direkt codierte Implementierung&quot;). Diese Lexer sind nur schwer nachvollziehbar und
werden üblicherweise generiert (vgl. <a href="flex.md">Flex</a>
und <a href="antlr.md">ANTLR</a>).</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/2GeEaU3qB6c' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Tabellenbasierte Scanner</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/36f62768351b19aa6453c819afa64cf2cc9ac698d3cf29137f3c7a5aeb5229de7c1102b8cf87981c27cbc1b250f03f1572e690dc96fb69e89a982f8200d54eb2' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Tabellenbasierte Scanner</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) Aufgaben eines Lexers</li> <li>(K2) Erkennen von Lexemen mit RE und DFA</li> <li>(K2) DFA-nahe Implementierung: Tabellenbasiert und direkt codiert</li></ul></div>
</div>




    <h2 id="lexer-erzeugen-eines-token-stroms-aus-einem-zeichenstrom">Lexer: Erzeugen eines Token-Stroms aus einem Zeichenstrom</h2>
<p>Aus dem Eingabe(-quell-)text</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* demo */</span>
</span></span><span style="display:flex;"><span>a<span style="color:#f92672">=</span> [<span style="color:#ae81ff">5</span>  , <span style="color:#ae81ff">6</span>]     ;</span></span></code></pre></div><p>erstellt der Lexer (oder auch Scanner genannt) eine Sequenz von Token:</p>
<pre><code>&lt;ID, &quot;a&quot;&gt; &lt;ASSIGN&gt; &lt;LBRACK&gt; &lt;NUM, 5&gt; &lt;COMMA&gt; &lt;NUM, 6&gt; &lt;RBRACK&gt; &lt;SEMICOL&gt;
</code></pre>
<ul>
<li>Input: Zeichenstrom (Eingabedatei o.ä.)</li>
<li>Verarbeitung: Finden sinnvoller Sequenzen im Zeichenstrom (&quot;Lexeme&quot;),
Einteilung in Kategorien und Erzeugen von Token (Paare: Typ/Name, Wert)</li>
<li>Ausgabe: Tokenstrom</li>
</ul>
<p>Normalerweise werden für spätere Phasen unwichtige Elemente wie White-Space
oder Kommentare entfernt.</p>
<p>Durch diese Vorverarbeitung wird eine höhere Abstraktionsstufe erreicht und es
können erste grobe Fehler gefunden werden. Dadurch kann der Parser auf einer
abstrakteren Stufe arbeiten und muss nicht mehr den gesamten ursprünglichen
Zeichenstrom verarbeiten.</p>
<p><em>Anmerkung</em>: In dieser Phase steht die Geschwindigkeit stark im Vordergrund:
Der Lexer &quot;sieht&quot; <em>alle</em> Zeichen im Input. Deshalb findet man häufig von
Hand kodierte Lexer, obwohl die Erstellung der Lexer auch durch Generatoren
erledigt werden könnte ...</p>
<p><em>Anmerkung</em>: Die Token sind die Terminalsymbole in den Parserregeln (Grammatik).</p>
<h2 id="definition-wichtiger-begriffe">Definition wichtiger Begriffe</h2>
<ul>
<li>
<p><strong>Token</strong>: Tupel (Tokenname, optional: Wert)</p>
<p>Der Tokenname ist ein abstraktes Symbol, welches eine lexikalische
Einheit repräsentiert (Kategorie). Die Tokennamen sind die Eingabesymbole
für den Parser.</p>
<p>Token werden i.d.R. einfach über ihren Namen referenziert. Token werden
häufig zur Unterscheidung von anderen Symbolen in der Grammatik in
Fettschrift oder mit großen Anfangsbuchstaben geschrieben.</p>
<p>Ein Token kann einen Wert haben, etwa eine Zahl oder einen Bezeichner, der
auf das zum Token gehörende Pattern gematcht hatte (also das Lexem). Wenn
der Wert des Tokens eindeutig über den Namen bestimmt ist (im Beispiel oben
beim Komma oder den Klammern), dann wird häufig auf den Wert verzichtet.</p>
</li>
<li>
<p><strong>Lexeme</strong>: Sequenz von Zeichen im Eingabestrom, die auf ein Tokenpattern
matcht und vom Lexer als Instanz dieses Tokens identifiziert wird.</p>
</li>
<li>
<p><strong>Pattern</strong>: Beschreibung der Form eines Lexems</p>
<p>Bei Schlüsselwörtern oder Klammern etc. sind dies die Schlüsselwörter oder
Klammern selbst. Bei Zahlen oder Bezeichnern (Namen) werden i.d.R.
reguläre Ausdrücke zur Beschreibung der Form des Lexems formuliert.</p>
</li>
</ul>
<h2 id="erkennung-mit-re-und-dfa">Erkennung mit RE und DFA</h2>
<p><a href="#R-image-1db52d4f058a4ce1ca850c1b226f554a" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table/lexer.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1db52d4f058a4ce1ca850c1b226f554a"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table/lexer.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Die obige Skizze ist eine Kurzzusammenfassung der Theorie-Vorlesung in der
letzten Woche und stellt die Verbindung zur heutigen Vorlesung her:</p>
<p>Die Lexeme werden mit Hilfe von <em>DFA</em> bestimmt. Die Formulierung der DFA ist
eher komplex (zumindest sehr umständlich), weshalb man die Pattern für die
Lexeme ersatzweise mit Hilfe von <em>Regulären Ausdrücken</em> (&quot;<em>RE</em>&quot;) formuliert.</p>
<p>Mit Hilfe der <em>Thompson's Construction</em> kann man diese in äquivalente <em>NFA</em>
umformen. Über die <em>Subset Construction</em> kann man daraus <em>DFA</em> erzeugen, die
wiederum mit Hilfe des <em>Hopcroft's Algorithm</em> minimiert werden.</p>
<p>Diese DFA erkennen die selbe Sprache wie die ursprünglichen REs. Man könnte
also durch Simulation der DFA die Lexeme erkennen und die Token bilden. Dabei
würde pro Eingabezeichen ein Übergang im DFA stattfinden und bei Erreichen
eines akzeptierenden Zustandes hätte man das durch diesen DFA (bzw. dessen
ursprünglichen RE) beschriebene Lexem identifiziert.</p>
<p>Falls mehrere REs matchen, muss man in geeigneter Weise entscheiden. I.d.R.
nimmt man den längsten Match. Zusätzlich wird eine Reihenfolge unter den REs
festgelegt, um bei mehreren gleich langen Matches ein Token bestimmen zu
können.</p>
<p>In der Praxis werden die DFA als Ausgangspunkt für die Implementierung des
Lexers genutzt (ob nun bei einer &quot;handgeklöppelten&quot; Implementierung oder beim
Einsatz eines Lexer-Generators). Als typische Implementierungsansätze sollen
nachfolgend die <em>tabellenbasierte Implementierung</em> sowie als etwas schnellere
Variante die <em>direkt codierte Implementierung</em> betrachtet werden. Während diese
beiden Varianten noch sehr nah an der Simulation eines DFA sind, ist die
<em>manuelle Implementierung</em>
(vgl. <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/recursive.html">Handcodierte Implementierung</a>)
noch einfacher in bestehenden Code zu integrieren (zum Preis einer erschwerten
Änderbarkeit).</p>
<p>Über die <em>Kleene's Construction</em> könnte man aus den DFA wieder <em>RE</em> erzeugen
und damit den Kreis schließen :-)</p>
<h2 id="erkennen-von-zeichenketten-für-strickmuster-10lrl">Erkennen von Zeichenketten für Strickmuster: &quot;10LRL&quot;</h2>
<p><a href="#R-image-be7471b035ffd747f99f5544e0027856" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table/dfa.png?width=45%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 45%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-be7471b035ffd747f99f5544e0027856"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table/dfa.png?width=45%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>DFA zur Erkennung von Strickanweisungen: Das erste Zeichen muss ein
Digit im Bereich 1..9 sein, gefolgt von weiteren Digits, gefolgt von
einer Anweisung für linke Maschen (&quot;L&quot;) oder rechte Maschen (&quot;R&quot;).</p>
<p>Ein passender regulärer Ausdruck dafür wäre &quot;<code>[1-9][0-9]*[LR]+</code>&quot;.</p>
<p>Die Eingabezeichen werden in relevante Kategorien sortiert. Dabei
werden nur die für die Aufgabe interessanten Zeichen (&quot;R&quot; bzw. &quot;L&quot;
und die Ziffern) einer konkreten Kategorie zugewiesen, der Rest wird
als &quot;<code>*</code>&quot; zusammengefasst.</p>
<p><a href="#R-image-15ea178d11834126f705c0d03f47faac" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table/delta.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-15ea178d11834126f705c0d03f47faac"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table/delta.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Für jeden Zustand wird in der Tabelle vermerkt, in welchen Folgezustand beim
Auftreten eines Zeichens einer bestimmten Kategorie gewechselt werden soll.
Dies ist eine alternative Darstellung des DFA in der obigen Darstellung.</p>
<p>Die Zustände des DFA werden den Tokentypen zugeordnet. Alle Zustände außer
&quot;<code>s2</code>&quot; entsprechen keinem gültigen Token, dies könnte man etwa als Token-Typ
&quot;<code>invalid</code>&quot; realisieren.</p>
<p><em>Anmerkung</em>: &quot;<code>se</code>&quot; ist ein Fehlerzustand, der im Automaten oben nicht
dargestellt ist und der dazu dient, falsche Zeichen zu erkennen und
entsprechend zu antworten.</p>
<h2 id="tabellenbasierte-implementierung">Tabellenbasierte Implementierung</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">nextToken</span>():
</span></span><span style="display:flex;"><span>    state <span style="color:#f92672">=</span> s0; lexeme <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>; stack <span style="color:#f92672">=</span> Stack()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (state <span style="color:#f92672">!=</span> se):
</span></span><span style="display:flex;"><span>        consume()       <span style="color:#75715e"># hole nächstes Zeichen (peek)</span>
</span></span><span style="display:flex;"><span>        lexeme <span style="color:#f92672">+=</span> peek
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">.</span>push(state)
</span></span><span style="display:flex;"><span>        state <span style="color:#f92672">=</span> TransitionTable[state, peek]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (state <span style="color:#f92672">!=</span> s2 <span style="color:#f92672">and</span> stack<span style="color:#f92672">.</span>notEmpty()):
</span></span><span style="display:flex;"><span>        state <span style="color:#f92672">=</span> stack<span style="color:#f92672">.</span>pop(); putBack(lexeme<span style="color:#f92672">.</span>truncate())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> state <span style="color:#f92672">==</span> s2: <span style="color:#66d9ef">return</span> s2(lexeme)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: <span style="color:#66d9ef">return</span> invalid()</span></span></code></pre></div><p>Der dargestellte Code implementiert direkt den DFA zur Erkennung von
Register-Namen unter Nutzung der Tabellen aus dem letzten Abschnitt.</p>
<p>Die Funktion <code>consume()</code> &quot;verbraucht&quot; das aktuelle Zeichen &quot;<code>peek</code>&quot; und
holt das nächste Zeichen aus dem Eingabestrom:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">consume</span>():
</span></span><span style="display:flex;"><span>    peek <span style="color:#f92672">=</span> nextChar()</span></span></code></pre></div><p>Nach einer Initialisierung wird in der Hauptschleife nach dem nächsten
Zeichen im Eingabestrom gefragt und das Lexem erweitert. Anschließend
wird der aktuelle Zustand auf dem Stack gesichert und mit Hilfe der
Transitionstabelle und des aktuellen Zustands sowie des aktuellen Zeichens
<code>peek</code> der Folgezustand bestimmt. Sobald der Fehlerzustand &quot;<code>se</code>&quot; erreicht
wird, bricht die Schleife ab.</p>
<p><em>Anmerkung</em>: Wenn wir in &quot;<code>s2</code>&quot; sind, wird so lange nach weiteren Buchstaben
&quot;L&quot; oder &quot;R&quot; gesucht, bis im Strom irgendetwas anderes auftaucht und wir
entsprechend in &quot;<code>se</code>&quot; landen.</p>
<p>In der zweiten Schleife wird der Stack aufgerollt, um zu schauen, ob wir
früher bereits in &quot;<code>s2</code>&quot; waren oder nicht. Das erste Element wird vom Stack
genommen, das Lexem wird um das letzte Zeichen gekürzt und dieses letzte
Zeichen wird mit <code>putBack()</code> in den Eingabestrom zurückgelegt. Falls wir
früher bereits in &quot;<code>s2</code>&quot; waren, wird dieser Zustand irgendwann vom Stack
genommen. Anderenfalls ist der Stack irgendwann leer.</p>
<p>Falls &quot;<code>s2</code>&quot; erreicht wurde, wird ein neues &quot;<code>s2</code>&quot;-Token generiert und das
Lexem wird als Attribut direkt gesetzt. Anderenfalls lag ein Fehler vor.</p>
<p><em>Anmerkung</em>: Diese Implementierung ist generisch: Wenn man im Code die
direkte Nennung des akzeptierenden Zustands &quot;<code>s2</code>&quot; durch einen Vergleich
mit einer Menge aller akzeptierender Zustände ersetzt (&quot;<code>state == s2</code>&quot;
=&gt; &quot;<code>state in acceptedStates</code>&quot;), bestimmen nur die Tabellen die
konkrete Funktionsweise.</p>
<p>Die Tabellen können allerdings schnell sehr groß werden, insbesondere
die Zustandsübergangstabelle!</p>
<h2 id="direkt-codierte-implementierung">Direkt codierte Implementierung</h2>
<p>Die Implementierung über die Tabellen ist sowohl generisch als auch effizient.
Allerdings kostet jeder Zugriff auf die Tabelle konstanten Aufwand (Erinnerung:
Zugriff auf Arrays, Pointerarithmetik), der sich in der Praxis deutlich
summieren kann. Außerdem müssen der Stack gepflegt (erweitert und später wieder
reduziert) werden und Objekte für die Zustände angelegt werden.</p>
<p>Die Lösung: Aufrollen der <code>while</code>-Schleife und direkt Umsetzung der Tabelle im
Code mit Sprungbefehlen (&quot;<code>goto</code>&quot;):</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">nextToken</span>():
</span></span><span style="display:flex;"><span>    lexeme <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>; stack <span style="color:#f92672">=</span> Stack()
</span></span><span style="display:flex;"><span>    goto s0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>s0:
</span></span><span style="display:flex;"><span>    consume()       <span style="color:#75715e"># hole nächstes Zeichen (peek)</span>
</span></span><span style="display:flex;"><span>    lexeme <span style="color:#f92672">+=</span> peek
</span></span><span style="display:flex;"><span>    stack<span style="color:#f92672">.</span>push(s0)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> peek <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span> <span style="color:#f92672">||</span> <span style="color:#f92672">...</span> <span style="color:#f92672">||</span> peek <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;9&#34;</span>:
</span></span><span style="display:flex;"><span>        goto s1
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        goto se
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span></span></span></code></pre></div><p>Durch die direkte Kodierung der Tabellen in Form von Sprungzielen für
<code>goto</code>-Befehle spart man sich die Formulierung der Tabellen und den Zugriff
auf die Inhalte. Allerdings ist der Code deutlich schwerer lesbar und auch
deutlich schwerer an eine andere Sprache anpassbar. Dies stellt aber keinen
echten Nachteil dar, wenn er durch einen Generator aus einer Grammatik o.ä.
erzeugt wird.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Zusammenhang DFA, RE und Lexer</p>
</li>
<li>
<p>Implementierungsansatz: Tabellenbasiert (DFA-Tabellen)</p>
</li>
</ul>


    



    



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Abschnitt 2.6 und Kapitel 3</em></li> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 1 (insbesondere Abschnitt 1.8)</em></li> <li id='id_Torczon2012'>[Torczon2012] <strong>Engineering a Compiler</strong><br>Torczon, L. und Cooper, K., Elsevier MK, 2012. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-1208-8478-0' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-1208-8478-0</a>.<br><em>Kapitel 2</em></li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Lexer: Handcodierte Implementierung</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p><a href="#R-image-20ce9c51402d8e5152a21b9a12d2b154" class="lightbox-link"><img src="images/architektur_cb_lexer.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-20ce9c51402d8e5152a21b9a12d2b154"><img src="images/architektur_cb_lexer.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Der Lexer (auch &quot;Scanner&quot;) soll den Zeichenstrom in eine Folge von Token zerlegen. Zur
Spezifikation der Token werden reguläre Ausdrücke verwendet.</p>
<p>Von Hand implementierte Lexer arbeiten üblicherweise rekursiv und verarbeiten immer
das nächste Zeichen im Eingabestrom. Die Arbeitsweise erinnert an LL-Parser (vgl.
<a href="../parsing/ll-parser-impl.md">LL-Parser</a>).</p>
<p>Lexer müssen sehr effizient sein, da sie noch direkt auf der niedrigsten Abstraktionsstufe
arbeiten und u.U. oft durchlaufen werden. Deshalb setzt man hier gern spezielle Techniken
wie Puffern von Zeichen über einen Doppel-Puffer ein.</p>
<p>Die Palette an Fehlerbehandlungsstrategien im Lexer reichen von &quot;aufgeben&quot; über den &quot;Panic
Mode&quot; (&quot;gobbeln&quot; von Zeichen, bis wieder eines passt) und Ein-Schritt-Transformationen bis
hin zu speziellen Lexer-Regeln, die beispielsweise besonders häufige Typos abfangen.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/N0WJQ4UkXkM' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Handcodierte Lexer</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/17a4958b1d4c0cf3488a7df02743806a33951d49f1cc22bccbdab7ad873738f0a24d0ad83f13c6d00ad48a669758659fde7a7e2ce19e793fe6f412e35ea0ee6d' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Handcodierte Lexer</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) Aufgaben eines Lexers</li> <li>(K2) Manuelle Implementierung: Rekursiver Abstieg</li> <li>(K2) Umgang mit dem Doppel-Puffer</li> <li>(K2) Varianten bei der Erkennung von Schlüsselwörtern</li> <li>(K2) Fehler und Lösungsansätze in der lexikalischen Analyse</li> <li>(K3) Typische Einteilung von Token</li> <li>(K3) Implementierung eines Top-Down-Lexers mit Read-Ahead und intelligenter Pufferung</li></ul></div>
</div>




    <h2 id="lexer-erzeugen-eines-token-stroms-aus-einem-zeichenstrom">Lexer: Erzeugen eines Token-Stroms aus einem Zeichenstrom</h2>
<p>Aus dem Eingabe(-quell-)text</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* demo */</span>
</span></span><span style="display:flex;"><span>a<span style="color:#f92672">=</span> [<span style="color:#ae81ff">5</span>  , <span style="color:#ae81ff">6</span>]     ;</span></span></code></pre></div><p>erstellt der Lexer (oder auch Scanner genannt) eine Sequenz von Token:</p>
<pre><code>&lt;ID, &quot;a&quot;&gt; &lt;ASSIGN&gt; &lt;LBRACK&gt; &lt;NUM, 5&gt; &lt;COMMA&gt; &lt;NUM, 6&gt; &lt;RBRACK&gt; &lt;SEMICOL&gt;
</code></pre>
<h2 id="manuelle-implementierung-rekursiver-abstieg">Manuelle Implementierung: Rekursiver Abstieg</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">nextToken</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (peek <span style="color:#f92672">!=</span> EOF):  <span style="color:#75715e"># globale Variable, über consume()</span>
</span></span><span style="display:flex;"><span>        switch (peek):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39; &#39;</span>: <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#39;</span>: <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>: WS(); <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;[&#39;</span>: consume(); <span style="color:#66d9ef">return</span> Token(LBRACK, <span style="color:#e6db74">&#39;[&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>            default:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> isLetter(peek): <span style="color:#66d9ef">return</span> NAME()
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">raise</span> Error(<span style="color:#e6db74">&#34;invalid character: &#34;</span><span style="color:#f92672">+</span>peek)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Token(EOF_Type, <span style="color:#e6db74">&#34;&lt;EOF&gt;&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">WS</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (peek <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">||</span> peek <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">||</span> <span style="color:#f92672">...</span>): consume()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">NAME</span>():
</span></span><span style="display:flex;"><span>    buf <span style="color:#f92672">=</span> StringBuilder()
</span></span><span style="display:flex;"><span>    do { buf<span style="color:#f92672">.</span>append(peek); consume(); } <span style="color:#66d9ef">while</span> (isLetter(peek))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Token(NAME, buf<span style="color:#f92672">.</span>toString())</span></span></code></pre></div><p>Die manuelle Implementierung &quot;denkt&quot; nicht in den Zuständen des DFA, sondern
orientiert sich immer am aktuellen Zeichen &quot;<code>peek</code>&quot;. Abhängig von dessen
Ausprägung wird entweder direkt ein Token erzeugt und das Zeichen aus dem
Eingabestrom entfernt sowie das nächste Zeichen eingelesen (mittels der
Funktion <code>consume()</code>, nicht dargestellt im Beispiel), oder man ruft weitere
Funktionen auf, die das Gewünschte erledigen, beispielsweise um White-Spaces
zu entfernen oder um einen Namen einzulesen: Nach einem Buchstaben werden
alle folgenden Buchstaben dem Namen (Bezeichner) hinzugefügt. Sobald ein
anderes Zeichen im Eingabestrom erscheint, wird das Namen-Token erzeugt.</p>
<p>Die Funktion <code>consume()</code> &quot;verbraucht&quot; das aktuelle Zeichen &quot;<code>peek</code>&quot; und holt
das nächste Zeichen aus dem Eingabestrom.</p>
<p><em>Anmerkung</em>: Häufig findet man im Lexer keinen &quot;schönen&quot; objektorientierten
Ansatz. Dies ist i.d.R. Geschwindigkeitsgründen geschuldet ...</p>
<h2 id="read-ahead-unterscheiden-von--und-">Read-Ahead: Unterscheiden von &quot;<em>&lt;</em>&quot; und &quot;<em>&lt;=</em>&quot;</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">nextToken</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (peek <span style="color:#f92672">!=</span> EOF):  <span style="color:#75715e"># globale Variable</span>
</span></span><span style="display:flex;"><span>        switch (peek):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;&lt;&#39;</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">match</span>(<span style="color:#e6db74">&#39;=&#39;</span>): consume(); <span style="color:#66d9ef">return</span> Token(LE, <span style="color:#e6db74">&#34;&lt;=&#34;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>: consume(); <span style="color:#66d9ef">return</span> Token(LESS, <span style="color:#e6db74">&#39;&lt;&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Token(EOF_Type, <span style="color:#e6db74">&#34;&lt;EOF&gt;&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">match</span>(c):   <span style="color:#75715e"># Lookahead: Ein Zeichen</span>
</span></span><span style="display:flex;"><span>    consume()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (peek <span style="color:#f92672">==</span> c): <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: rollBack(); <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span></span></span></code></pre></div><p>Um die Token &quot;<code>&lt;</code>&quot; und &quot;<code>&lt;=</code>&quot; unterscheiden zu können, müssen wir ein Zeichen
vorausschauen: Wenn nach dem &quot;<code>&lt;</code>&quot; noch ein &quot;<code>=</code>&quot; kommt, ist es &quot;<code>&lt;=</code>&quot;, sonst
&quot;<code>&lt;</code>&quot;.</p>
<p>Erinnerung: Die Funktion <code>consume()</code> liest das nächste Zeichen aus dem
Eingabestrom und speichert den Wert in der globalen Variable <code>peek</code>.</p>
<p>Für das Read-Ahead wird die Funktion <code>match()</code> definiert, die zunächst das
bereits bekannte Zeichen, in diesem Fall das &quot;<code>&lt;</code>&quot; durch das nächste Zeichen
im Eingabestrom ersetzt (Aufruf von <code>consume()</code>). Falls der Vergleich des
Lookahead-Zeichens mit dem gesuchten Zeichen erfolgreich ist, liegt das
&quot;größere&quot; Token vor, also &quot;<code>&lt;=</code>&quot;. Dann wird noch das &quot;<code>=</code>&quot; durch das nächste
Zeichen ersetzt und das Token <code>LE</code> gebildet. Anderenfalls muss das zuviel
gelesene Zeichen wieder in den Eingabestrom zurückgelegt werden (<code>rollBack()</code>).</p>
<h2 id="puffern-des-input-stroms-double-buffering">Puffern des Input-Stroms: Double Buffering</h2>
<p>Das Einlesen einzelner Zeichen führt zwar zu eleganten algorithmischen
Lösungen, ist aber zur Laufzeit deutlich &quot;teurer&quot; als das Einlesen mit
gepufferten I/O-Operationen, die eine ganze Folge von Zeichen einlesen
(typischerweise einen ganzen Disk-Block, beispielsweise 4096 Zeichen).</p>
<p>Dazu kann man einen Ringpuffer nutzen, den man mit Hilfe von zwei gleich
großen <code>char</code>-Puffern mit jeweils der Länge 
<span class="math align-center">$N$</span> simulieren kann. (
<span class="math align-center">$N$</span>
sollte dann der Länge eines Disk-Blocks entsprechen.)</p>
<p>Vergleiche auch <a href="https://en.wikipedia.org/wiki/Circular_buffer" target="_blank">Wikipedia: &quot;Circular Buffer&quot;</a>.</p>
<p><a href="#R-image-c3a965fe57bd118c17a6cac8b403c507" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/recursive/doublebuffer.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c3a965fe57bd118c17a6cac8b403c507"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/recursive/doublebuffer.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; end <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; fill(buffer[<span style="color:#ae81ff">0</span>:n])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">consume</span>():
</span></span><span style="display:flex;"><span>    peek <span style="color:#f92672">=</span> buffer[start]
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> (start<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) mod <span style="color:#ae81ff">2</span>n
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (start mod n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>        fill(buffer[start:start<span style="color:#f92672">+</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>        end <span style="color:#f92672">=</span> (start<span style="color:#f92672">+</span>n) mod <span style="color:#ae81ff">2</span>n
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rollBack</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (start <span style="color:#f92672">==</span> end): <span style="color:#66d9ef">raise</span> Error(<span style="color:#e6db74">&#34;roll back error&#34;</span>)
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> (start<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) mod <span style="color:#ae81ff">2</span>n</span></span></code></pre></div><p>Zunächst wird nur der vordere Pufferteil durch einen passenden Systemaufruf
gefüllt.</p>
<p>Beim Weiterschalten im simulierten DFA oder im manuell kodierten Lexer
(Funktionsaufruf von <code>consume()</code>) wird das nächste Zeichen aus dem vorderen
Pufferteil zurückgeliefert. Über die Modulo-Operation bleibt der Pointer
<code>start</code> immer im Speicherbereich der beiden Puffer.</p>
<p>Wenn man das Ende des vorderen Puffers erreicht, wird der hintere Puffer mit
einem Systemaufruf gefüllt. Gleichzeitig wird ein Hilfspointer <code>end</code> auf
den Anfang des vorderen Puffers gesetzt, um Fehler beim Roll-Back zu erkennen.</p>
<p>Wenn man das Ende des hinteren Puffers erreicht, wird der vordere Puffer
nachgeladen und der Hilfspointer auf den Anfang des hinteren Puffers gesetzt.</p>
<p>Im Grunde ist also immer ein Puffer der &quot;Arbeitspuffer&quot; und der andere enthält
die bereits gelesene (verarbeitete) Zeichenkette. Wenn beim Nachladen weniger
als 
<span class="math align-center">$N$</span> Zeichen gelesen werden, liefert der Systemaufruf als letztes &quot;Zeichen&quot;
ein <code>EOF</code>. Beim Verarbeiten wird <code>peek</code> entsprechend diesen Wert bekommen und
der Lexer muss diesen Wert abfragen und berücksichtigen.</p>
<p>Für das Roll-Back wird der <code>start</code>-Pointer einfach dekrementiert (und mit einer
Modulo-Operation auf den Speicherbereich der beiden Puffer begrenzt). Falls
dabei der <code>end</code>-Pointer &quot;eingeholt&quot; wird, ist der <code>start</code>-Pointer durch beide
Puffer zurückgelaufen und es gibt keinen früheren Input mehr. In diesem Fall
wird entsprechend ein Fehler gemeldet.</p>
<p><em>Anmerkung</em>: In der Regel sind die Lexeme kurz und man muss man nur ein bis
zwei Zeichen im Voraus lesen. Dann ist eine Puffergröße von 4096 Zeichen mehr
als ausreichend groß und man sollte nicht in Probleme laufen. Wenn der nötige
Look-Ahead aber beliebig groß werden kann, etwa bei Sprachen ohne reservierte
Schlüsselwörtern oder bei Kontext-sensitiven Lexer-Grammatiken (denken Sie etwa
an die Einrücktiefe bei Python), muss man andere Strategien verwenden. ANTLR
beispielsweise vergrößert in diesem Fall den Puffer dynamisch, alternativ könnte
man die Auflösung zwischen Schlüsselwörtern und Bezeichnern dem Parser überlassen.</p>
<h2 id="typische-muster-für-erstellung-von-token">Typische Muster für Erstellung von Token</h2>
<ol>
<li>
<p>Schlüsselwörter</p>
<ul>
<li>Ein eigenes Token (RE/DFA) für jedes Schlüsselwort, oder</li>
<li>Erkennung als Name und Vergleich mit Wörterbuch
und nachträgliche Korrektur des Tokentyps</li>
</ul>
<p>Wenn Schlüsselwörter über je ein eigenes Token abgebildet werden, benötigt
man für jedes Schlüsselwort einen eigenen RE bzw. DFA. Die Erkennung als
Bezeichner und das Nachschlagen in einem Wörterbuch (geeignete Hashtabelle)
sowie die entsprechende nachträgliche Korrektur des Tokentyps kann die
Anzahl der Zustände im Lexer signifikant reduzieren!</p>
</li>
<li>
<p>Operatoren</p>
<ul>
<li>Ein eigenes Token für jeden Operator, oder</li>
<li>Gemeinsames Token für jede Operatoren-Klasse</li>
</ul>
</li>
<li>
<p>Bezeichner: Ein gemeinsames Token für alle Namen</p>
</li>
<li>
<p>Zahlen: Ein gemeinsames Token für alle numerischen Konstante
(ggf. Integer und Float unterscheiden)</p>
<p>Für Zahlen führt man oft ein Token &quot;<code>NUM</code>&quot; ein. Als Attribut speichert man
das Lexem i.d.R. als String. Alternativ kann man (zusätzlich) das Lexem in
eine Zahl konvertieren und als (zusätzliches) Attribut speichern. Dies kann
in späteren Stufen viel Arbeit sparen.</p>
</li>
<li>
<p>String-Literale: Ein gemeinsames Token</p>
</li>
<li>
<p>Komma, Semikolon, Klammern, ...: Je ein eigenes Token</p>
</li>
<li>
<p>Regeln für White-Space und Kommentare etc. ...</p>
<p>Normalerweise benötigt man Kommentare und White-Spaces in den folgenden
Stufen nicht und entfernt diese deshalb aus dem Eingabestrom. Dabei könnte
man etwa White-Spaces in den Pattern der restlichen Token berücksichtigen,
was die Pattern aber sehr komplex macht. Die Alternative sind zusätzliche
Pattern, die auf die White-Space und anderen nicht benötigten Inhalt
matchen und diesen &quot;geräuschlos&quot; entfernen. Mit diesen Pattern werden
keine Token erzeugt, d.h. der Parser und die anderen Stufen bemerken nichts
von diesem Inhalt.</p>
<p>Gelegentlich benötigt man aber auch Informationen über White-Spaces,
beispielsweise in Python. Dann müssen diese Token wie normale Token
an den Parser weitergereicht werden.</p>
</li>
</ol>
<p>Jedes Token hat i.d.R. ein Attribut, in dem das Lexem gespeichert wird. Bei
eindeutigen Token (etwa bei eigenen Token je Schlüsselwort oder bei den
Interpunktions-Token) kann man sich das Attribut auch sparen, da das Lexem
durch den Tokennamen eindeutig rekonstruierbar ist.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Token</th>
<th style="text-align:left">Beschreibung</th>
<th style="text-align:left">Beispiel-Lexeme</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>if</code></td>
<td style="text-align:left">Zeichen <code>i</code> und <code>f</code></td>
<td style="text-align:left"><code>if</code></td>
</tr>
<tr>
<td style="text-align:left"><code>relop</code></td>
<td style="text-align:left"><code>&lt;</code> oder <code>&gt;</code> oder <code>&lt;=</code> oder <code>&gt;=</code> oder <code>==</code> oder <code>!=</code></td>
<td style="text-align:left"><code>&lt;</code>, <code>&lt;=</code></td>
</tr>
<tr>
<td style="text-align:left"><code>id</code></td>
<td style="text-align:left">Buchstabe, gefolgt von Buchstaben oder Ziffern</td>
<td style="text-align:left"><code>pi</code>, <code>count</code>, <code>x3</code></td>
</tr>
<tr>
<td style="text-align:left"><code>num</code></td>
<td style="text-align:left">Numerische Konstante</td>
<td style="text-align:left"><code>42</code>, <code>3.14159</code>, <code>0</code></td>
</tr>
<tr>
<td style="text-align:left"><code>literal</code></td>
<td style="text-align:left">Alle Zeichen außer <code>&quot;</code>, in <code>&quot;</code> eingeschlossen</td>
<td style="text-align:left"><code>&quot;core dumped&quot;</code></td>
</tr>
</tbody>
</table>
<p><em>Anmerkung</em>: Wenn es mehrere matchende REs gibt, wird in der Regel das längste
Lexem bevorzugt. Wenn es mehrere gleich lange Alternativen gibt, muss man mit
Vorrangregeln bzgl. der Token arbeiten.</p>
<h2 id="fehler-bei-der-lexikalischen-analyse">Fehler bei der Lexikalischen Analyse</h2>
<p>Problem: Eingabestrom sieht so aus: <code>fi (a==42) { ... }</code></p>
<p>Der Lexer kann nicht erkennen, ob es sich bei <code>fi</code> um ein vertipptes
Schlüsselwort handelt oder um einen Bezeichner: Es könnte sich um einen
Funktionsaufruf der Funktion <code>fi()</code> handeln ...
Dieses Problem kann erst in der nächsten Stufe sinnvoll erkannt und behoben
werden.</p>
<p>=&gt; Was tun, wenn keines der Pattern auf den Anfang des Eingabestroms passt?</p>
<p>Optionen:</p>
<ul>
<li>
<p>Aufgeben ...</p>
<p>Eventuell vielleicht sogar die beste und einfachste Variante :-)</p>
</li>
<li>
<p>&quot;Panic Mode&quot;: Entferne so lange Zeichen, bis ein Pattern passt.</p>
<p>Das verwirrt u.U. den Parser, kann aber insbesondere in interaktiven
Umgebungen hilfreich sein. Ggf. kann man dem Parser auch signalisieren,
dass hier ein Problem vorlag.</p>
</li>
<li>
<p>Ein-Schritt-Transformationen:</p>
<ul>
<li>Füge fehlendes Zeichen in Eingabestrom ein.</li>
<li>Entferne ein Zeichen aus Eingabestrom.</li>
<li>Vertausche ein Zeichen:
<ul>
<li>Ersetze ein Zeichen durch ein anderes.</li>
<li>Vertausche zwei benachbarte Zeichen.</li>
</ul>
</li>
</ul>
<p>Diese Transformationen versuchen, den Input in einem Schritt zu reparieren.
Das ist durchaus sinnvoll, da in der Praxis die meisten Fehler in dieser
Stufe durch ein einzelnes Zeichen hervorgerufen werden: Es fehlt ein
Zeichen oder es ist eines zuviel im Input. Es liegt ein falsches Zeichen
vor (Tippfehler) oder zwei benachbarte Zeichen wurden verdreht ...</p>
<p>Im Prinzip könnte man auch eine allgemeinere Strategie versuchen, indem man
diejenige Transformation mit der <em>kleinsten Anzahl von Schritten</em> zur
Fehlerbehebung bestimmt. Beispiele dafür finden sich im Bereich Natural
Language Processing (<em>NLP</em>), etwa die Levenshtein-Distanz oder der
SoundEx-Algorithmus oder sogar Hidden-Markov-Modelle. Allerdings muss
man sich in Erinnerung rufen, dass gerade in dieser ersten Phase eines
Compilers die Geschwindigkeit stark im Fokus steht und eine ausgefeilte
Fehlerkorrekturstrategie die vielen kleinen Optimierungen schnell wieder
zunichte machen kann.</p>
</li>
<li>
<p>Fehler-Regeln: Matche typische Typos</p>
<p>Gelegentlich findet man in den Grammatiken für den Lexer extra Regeln, die
häufige bzw. typische Typos matchen und dann passend darauf reagieren.</p>
</li>
</ul>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Zusammenhang DFA, RE und Lexer</p>
</li>
<li>
<p>Implementierungsansatz: Manuell codiert (rekursiver Abstieg)</p>
</li>
<li>
<p>Read-Ahead</p>
</li>
<li>
<p>Puffern mit Doppel-Puffer-Strategie</p>
</li>
<li>
<p>Typische Fehler beim Scannen</p>
</li>
</ul>


    



    



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Abschnitt 2.6 und Kapitel 3</em></li> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 1 (insbesondere Abschnitt 1.8)</em></li> <li id='id_Torczon2012'>[Torczon2012] <strong>Engineering a Compiler</strong><br>Torczon, L. und Cooper, K., Elsevier MK, 2012. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-1208-8478-0' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-1208-8478-0</a>.<br><em>Kapitel 2</em></li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Lexer mit ANTLR generieren</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>ANTLR ist ein Parser-Generator, der aus einer Grammatik einen Parser in verschiedenen
Zielsprachen (Java, Python, C++, ...) generieren kann.</p>
<p>In der ANTLR-Grammatik werden die Parser-Regeln klein geschrieben, die Lexer-Regeln werden
mit <strong>Großbuchstaben</strong> geschrieben. Jede Lexer-Regel liefert ein Token zurück, dabei
ist der Tokenname die linke Seite der Regel. Wie bei Flex gewinnt der längste Match,
und bei Gleichstand (mehrere längste Regeln matchen) gewinnt die zuerst definierte Regel.</p>
<p>Die Lexer-Regeln können mit Aktionen annotiert werden, die beim Matchen der jeweiligen Regel
abgearbeitet werden. Diese Aktionen müssen in der Zielprogrammiersprache formuliert werden,
da sie in die generierte Lexerklasse in die jeweiligen Methoden eingebettet werden.</p>
<p>ANTLR kennt Lexer-Kommandos wie <code>skip</code> (entferne das aktuelle Zeichen), <code>more</code> (lese mehr
Input, um ein Token zu generieren) und andere. Mit &quot;Fragmenten&quot; kann man Hilfsregeln definieren,
die keine Token darstellen.</p>
<p>ANTLR kennt &quot;Modes&quot;, mit denen man zustandsbehaftete Lexer erzeugen kann. Dies ist nützlich
für &quot;Insel-Grammatiken&quot;, etwa für das Bearbeiten von XML oder HTML. Zusätzlich gibt es &quot;Channels&quot;
zum Vorsortieren von Tokens in verschiedene parallele Tokenstreams.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
        
        
            
        
    
        
        
            
        
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/I119N04WIYA' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Lexer mit ANTLR</a></li> <li><a href='https://youtu.be/pbjGThqVLkU' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Demo ANTLR Basics</a></li> <li><a href='https://youtu.be/vnJIm6S-898' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Demo Verhalten Lexer-Regeln</a></li> <li><a href='https://youtu.be/bNpgqctiQM8' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Demo Lexer-Regeln mit Aktionen</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/10e0ed907bb767e8304c0cf197293588f9497a217e0dee792c458887ec73299a415da96fd2ea12e0f054ba478772239ec2581db5cedadb3aba14203c590493d1' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Lexer mit ANTLR</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K3) Lexer-Regeln in ANTLR formulieren und einsetzen</li> <li>(K2) Verhalten des Lexers: längste Matches, Reihenfolge</li> <li>(K3) Nutzung von Lexer-Aktionen</li> <li>(K3) Einsatz von Fragmenten</li> <li>(K3) Nutzung von Lexer-Kommandos</li> <li>(K3) Zustandsbehaftete Lexer (Modes)</li> <li>(K3) Nutzung von Channels</li> <li>(K2) Importieren von Grammatiken</li></ul></div>
</div>




    <h2 id="hello-world">Hello World</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span><span style="color:#66d9ef">grammar</span> <span style="color:#a6e22e">Hello</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>start       : <span style="color:#e6db74">&#39;hello&#39;</span> <span style="color:#66d9ef">GREETING</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>GREETING    : [a-zA-Z]<span style="color:#f92672">+</span> ;
</span></span><span style="display:flex;"><span>WHITESPACE  : [ \t\n]<span style="color:#f92672">+</span> <span style="color:#f92672">-&gt;</span> skip ;</span></span></code></pre></div><div style="text-align: right;">
<span class="btn cstyle default">
  <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/lecture/frontend/lexing/src/Hello.g4" target="_blank">
    Konsole: Hello (Classpath, Aliase, grun, Main, Dateien, Ausgabe)
  </a>
</span></div>
<h3 id="hinweis-zur-grammatik-regeln">Hinweis zur Grammatik (Regeln)</h3>
<ul>
<li><code>start</code> ist eine <span class='alert'>Parser-Regel</span>
=&gt; Eine Parser-Regel pro Grammatik wird benötigt, damit man den generierten
Parser am Ende auch starten kann ...</li>
<li>Die anderen beiden Regeln (mit großem Anfangsbuchstaben) aus der obigen Grammatik
zählen zum Lexer</li>
</ul>
<h3 id="antlr-einrichten">ANTLR einrichten</h3>
<ul>
<li>Aktuelle Version herunterladen: <a href="https://www.antlr.org/download.html" target="_blank">antlr.org</a>,
für Java als Zielsprache: <a href="https://www.antlr.org/download/antlr-4.11.1-complete.jar" target="_blank">&quot;Complete ANTLR 4.x Java binaries jar&quot;</a></li>
<li>CLASSPATH setzen: <code>export CLASSPATH=&quot;.:/&lt;pathToJar&gt;/antlr-4.11.1-complete.jar:$CLASSPATH&quot;</code></li>
<li>Aliase einrichten (<code>.bashrc</code>):
<ul>
<li><code>alias antlr='java org.antlr.v4.Tool'</code></li>
<li><code>alias grun='java org.antlr.v4.gui.TestRig'</code></li>
</ul>
</li>
<li>Alternativ über den Python-Installer: <code>pip install antlr4-tools</code></li>
<li>Im Web ohne lokale Installation: <a href="http://lab.antlr.org/" target="_blank">ANTLR Lab</a></li>
</ul>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/getting-started.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/getting-started.md</a>)</p>
<h3 id="hello-world-übersetzen-und-ausführen">&quot;Hello World&quot; übersetzen und ausführen</h3>
<ol>
<li>Grammatik übersetzen und Code generieren: <code>antlr Hello.g4</code></li>
<li>Java-Code kompilieren: <code>javac *.java</code></li>
<li>Lexer ausführen:
<ul>
<li>
<p><code>grun Hello start -tokens</code> (Grammatik &quot;Hello&quot;, Startregel &quot;start&quot;)</p>
</li>
<li>
<p>Alternativ mit kleinem Java-Programm:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> org.antlr.v4.runtime.*<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        Lexer l <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HelloLexer<span style="color:#f92672">(</span>CharStreams<span style="color:#f92672">.</span><span style="color:#a6e22e">fromStream</span><span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        Token t <span style="color:#f92672">=</span> l<span style="color:#f92672">.</span><span style="color:#a6e22e">nextToken</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>t<span style="color:#f92672">.</span><span style="color:#a6e22e">getType</span><span style="color:#f92672">()</span> <span style="color:#f92672">!=</span> Token<span style="color:#f92672">.</span><span style="color:#a6e22e">EOF</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>t<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            t <span style="color:#f92672">=</span> l<span style="color:#f92672">.</span><span style="color:#a6e22e">nextToken</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div></li>
</ul>
</li>
</ol>
<h3 id="generierte-dateien-und-klassen">Generierte Dateien und Klassen</h3>
<p>Nach dem Übersetzen finden sich folgende Dateien und Klassen vor:</p>
<pre><code>.
├── bin
│   ├── HelloBaseListener.class
│   ├── HelloBaseVisitor.class
│   ├── HelloLexer.class
│   ├── HelloListener.class
│   ├── HelloParser.class
│   ├── HelloParser$RContext.class
│   ├── HelloVisitor.class
│   └── Main.class
├── Hello.g4
└── src
    ├── HelloBaseListener.java
    ├── HelloBaseVisitor.java
    ├── HelloLexer.java
    ├── HelloLexer.tokens
    ├── HelloListener.java
    ├── HelloParser.java
    ├── Hello.tokens
    ├── HelloVisitor.java
    └── Main.java
</code></pre>
<p><em>Anmerkung</em>: Die Ordnerstruktur wurde durch ein ANTLR-Plugin für Eclipse
erzeugt. Bei Ausführung in der Konsole liegen alle Dateien in einem Ordner.</p>
<p><em>Anmerkung</em>: Per Default werden nur die Listener angelegt, für die Visitoren
muss eine extra Option mitgegeben werden.</p>
<p>Die Dateien <code>Hello.tokens</code> und <code>HelloLexer.tokens</code> enthalten die Token samt
einer internen Nummer. (Der Inhalt beider Dateien ist identisch.)</p>
<p>Die Datei <code>HelloLexer.java</code> enthält den generierten Lexer, der eine
Spezialisierung der abstrakten Basisklasse <code>Lexer</code> darstellt. Über den
Konstruktor wird der zu scannende <code>CharStream</code> gesetzt. Über die Methode
<code>Lexer#nextToken()</code> kann man sich die erkannten Token der Reihe nach
zurückgeben lassen. (Diese Methode wird letztlich vom Parser benutzt.)</p>
<p>Die restlichen Dateien werden für den Parser und verschiedene Arten der
Traversierung des AST generiert (vgl.
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/astdriven-part1.html">AST-basierte Interpreter</a>).</p>
<h3 id="bedeutung-der-ausgabe">Bedeutung der Ausgabe</h3>
<p>Wenn man dem Hello-Lexer die Eingabe</p>
<pre><code>hello world
&lt;EOF&gt;
</code></pre>
<p>(das <code>&lt;EOF&gt;</code> wird durch die Tastenkombination <code>STRG-D</code> erreicht) gibt, dann
lautet die Ausgabe</p>
<pre><code>$ grun Hello start -tokens
hello world
&lt;EOF&gt;
[@0,0:4='hello',&lt;'hello'&gt;,1:0]
[@1,6:10='world',&lt;GREETING&gt;,1:6]
[@2,12:11='&lt;EOF&gt;',&lt;EOF&gt;,2:0]
</code></pre>
<p>Die erkannten Token werden jeweils auf einer eigenen Zeile ausgegeben.</p>
<ul>
<li><code>@0</code>: Das erste Token (fortlaufend nummeriert, beginnend mit 0)</li>
<li><code>0:4</code>: Das Token umfasst die Zeichen 0 bis 4 im Eingabestrom</li>
<li><code>='hello'</code>: Das gefundene Lexem (Wert des Tokens)</li>
<li><code>&lt;'hello'&gt;</code>: Das Token (Name/Typ des Tokens)</li>
<li><code>1:0</code>: Das Token wurde in Zeile 1 gefunden (Start der Nummerierung mit
Zeile 1), und startet in dieser Zeile an Position 0</li>
</ul>
<p>Entsprechend bekommt man mit</p>
<pre><code>$ grun Hello start -tokens
hello
  world

&lt;EOF&gt;
[@0,0:4='hello',&lt;'hello'&gt;,1:0]
[@1,8:12='world',&lt;GREETING&gt;,2:2]
[@2,15:14='&lt;EOF&gt;',&lt;EOF&gt;,4:0]
</code></pre>
<h3 id="antlr-grammatik-für-die-lexer-generierung">ANTLR-Grammatik für die Lexer-Generierung</h3>
<ul>
<li>
<p>Start der Grammatik mit dem Namen &quot;<code>XYZ</code>&quot; mit</p>
<pre><code>grammar XYZ;
</code></pre>
<p>oder (nur Lexer)</p>
<pre><code>lexer grammar XYZ;
</code></pre>
</li>
<li>
<p>Token und Lexer-Regeln starten mit <em>großen Anfangsbuchstaben</em>
(Ausblick: Parser-Regeln starten mit kleinen Anfangsbuchstaben)</p>
<p>Format: <code>TokenName : Alternative1 | ... | AlternativeN ;</code></p>
<p>Rekursive Lexer-Regeln sind erlaubt. <strong>Achtung</strong>: Es dürfen keine
<em>links-rekursiven</em> Regeln genutzt werden, etwa wie <code>ID : ID '*' ID ;</code> ...
(Eine genauere Definition und die Transformation in nicht-linksrekursive
Regeln siehe <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory.html">LL-Parser</a>).</p>
</li>
<li>
<p>Alle Literale werden in <em>einfache</em> Anführungszeichen eingeschlossen
(es erfolgt keine Unterscheidung zwischen einzelnen Zeichen und Strings
wie in anderen Sprachen)</p>
</li>
<li>
<p>Zeichenmengen: <code>[a-z\n]</code> umfasst alle Zeichen von <code>'a'</code> bis <code>'z'</code> sowie
<code>'\n'</code></p>
<p><code>'a'..'z'</code> ist identisch zu <code>[a-z]</code></p>
</li>
<li>
<p>Schlüsselwörter: Die folgenden Strings stellen reservierte Schlüsselwörter
dar und dürfen nicht als Token, Regel oder Label genutzt werden:</p>
<pre><code>import, fragment, lexer, parser, grammar, returns, locals, throws, catch, finally, mode, options, tokens
</code></pre>
<p><em>Anmerkung</em>: <code>rule</code> ist zwar kein Schlüsselwort, wird aber als Methodenname
bei der Codegenerierung verwendet. =&gt; Wie ein Schlüsselwort behandeln!</p>
</li>
</ul>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/lexicon.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/lexicon.md</a>)</p>
<h3 id="greedy-und-non-greedy-lexer-regeln">Greedy und Non-greedy Lexer-Regeln</h3>
<p>Die regulären Ausdrücke <code>(...)?</code>, <code>(...)*</code> und <code>(...)+</code> sind <em>greedy</em> und
versuchen soviel Input wie möglich zu matchen.</p>
<p>Falls dies nicht sinnvoll sein sollte, kann man mit einem weiteren <code>?</code> das
Verhalten auf <em>non-greedy</em> umschalten. Allerdings können non-greedy Regeln
das Verhalten des Lexers u.U. schwer vorhersehbar machen!</p>
<p>Die Empfehlung ist, non-greedy Lexer-Regeln nur sparsam einzusetzen
(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/wildcard.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/wildcard.md</a>).</p>
<h2 id="verhalten-des-lexers-1-längster-match">Verhalten des Lexers: 1. Längster Match</h2>
<p>Primäres Ziel: Erkennen der längsten Zeichenkette</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>CHARS   : [a-z]<span style="color:#f92672">+</span> ;
</span></span><span style="display:flex;"><span>DIGITS  : [0-9]<span style="color:#f92672">+</span> ;
</span></span><span style="display:flex;"><span>FOO     : [a-z]<span style="color:#f92672">+</span> [0-9]<span style="color:#f92672">+</span> ;</span></span></code></pre></div><p>Die Regel, die den längsten Match für die aktuelle Eingabesequenz produziert,
&quot;gewinnt&quot;.</p>
<p>Im Beispiel würde ein &quot;foo42&quot; als <code>FOO</code> erkannt und nicht als <code>CHARS DIGITS</code>.</p>
<h2 id="verhalten-des-lexers-2-reihenfolge">Verhalten des Lexers: 2. Reihenfolge</h2>
<p>Reihenfolge in Grammatik definiert Priorität</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>FOO     : <span style="color:#e6db74">&#39;f&#39;</span> <span style="color:#f92672">.*?</span> <span style="color:#e6db74">&#39;r&#39;</span> ;
</span></span><span style="display:flex;"><span>BAR     : <span style="color:#e6db74">&#39;foo&#39;</span> <span style="color:#f92672">.*?</span> <span style="color:#e6db74">&#39;bar&#39;</span> ;</span></span></code></pre></div><p>Falls mehr als eine Lexer-Regel die selbe Inputsequenz matcht, dann
hat die in der Grammatik zuerst genannte Regel Priorität.</p>
<p>Im Beispiel würden für die Eingabe &quot;foo42bar&quot; beide Regeln den selben längsten
Match liefern - die Regel <code>FOO</code> ist in der Grammatik früher definiert und
&quot;gewinnt&quot;.</p>
<h2 id="verhalten-des-lexers-3-non-greedy-regeln">Verhalten des Lexers: 3. Non-greedy Regeln</h2>
<p>Non-greedy Regeln versuchen <em>so wenig</em> Zeichen wie möglich zu matchen</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>FOO     : <span style="color:#e6db74">&#39;foo&#39;</span> <span style="color:#f92672">.*?</span> <span style="color:#e6db74">&#39;bar&#39;</span> ;
</span></span><span style="display:flex;"><span>BAR     : <span style="color:#e6db74">&#39;bar&#39;</span> ;</span></span></code></pre></div><p>Hier würde ein &quot;foo42barbar&quot; zu <code>FOO</code> gefolgt von <code>BAR</code> erkannt werden.</p>
<p><span class='alert'>Achtung</span>: Nach dem Abarbeiten einer non-greedy Sub-Regel in einer Lexer-Regel
gilt &quot;<em>first match wins</em>&quot;</p>
<p><code>.*? ('4' | '42')</code></p>
<p>=&gt; Der Teil <code>'42'</code> auf der rechten Seite ist
&quot;toter Code&quot; (wegen der non-greedy Sub-Regel <code>.*?</code>)!</p>
<p>Die Eingabe &quot;x4&quot; würde korrekt erkannt, währende &quot;x42&quot; nur als &quot;x4&quot; erkannt wird und für
die verbleibende &quot;2&quot; würde ein <em>token recognition error</em> geworfen.</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/wildcard.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/wildcard.md</a>)</p>
<h2 id="attribute-und-aktionen">Attribute und Aktionen</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span><span style="color:#66d9ef">grammar</span> <span style="color:#a6e22e">Demo</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@header {
</span></span><span style="display:flex;"><span>import java.util.*;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@members {
</span></span><span style="display:flex;"><span>String s = &#34;&#34;;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>start   : <span style="color:#66d9ef">TYPE</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> <span style="color:#66d9ef">INT</span> <span style="color:#e6db74">&#39;;&#39;</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>TYPE    : <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;float&#39;</span><span style="color:#f92672">)</span> {s = getText();} ;
</span></span><span style="display:flex;"><span>INT     : [0-9]<span style="color:#f92672">+</span>            {System.out.println(s+&#34;:&#34;+Integer.valueOf(getText()));};
</span></span><span style="display:flex;"><span>ID      : [a-z]<span style="color:#f92672">+</span>            {setText(String.valueOf(getText().charAt(0)));} ;
</span></span><span style="display:flex;"><span>WS      : [ \t\n]<span style="color:#f92672">+</span> <span style="color:#f92672">-&gt;</span> skip ;</span></span></code></pre></div><h3 id="attribute-bei-token-auswahl">Attribute bei Token (Auswahl)</h3>
<p>Token haben Attribute, die man abfragen kann. Dies umfasst u.a. folgende Felder:</p>
<ul>
<li><code>text</code>: Das gefundene Lexem als String</li>
<li><code>type</code>: Der Token-Typ als Integer</li>
<li><code>index</code>: Das wievielte Token (als Integer)</li>
</ul>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/actions.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/actions.md</a>)</p>
<p>Zur Auswertung in den Lexer-Regeln muss man anders vorgehen als in
Parser-Regeln: Nach der Erstellung eines Tokens kann man die zum Attribut
gehörenden <code>getX()</code> und <code>setX()</code>-Methoden aufrufen, um die Werte abzufragen
oder zu ändern.</p>
<p>Dies passiert im obigen Beispiel für das Attribut <code>text</code>: Abfrage mit
<code>getText()</code>, Ändern/Setzen mit <code>setText()</code>.</p>
<p>Die Methodenaufrufe wirken sich immer auf das gerade erstellte Token aus.</p>
<p><em>Achtung</em>: Bei Aktionen in Parser-Regeln gelten andere Spielregeln!</p>
<h3 id="aktionen-mit-den-lexer-regeln">Aktionen mit den Lexer-Regeln</h3>
<p>Aktionen für Lexer-Regeln sind Code-Blöcke in der Zielsprache, eingeschlossen
in geschweifte Klammern. Die Code-Blöcke werden direkt in die generierten
Lexer-Methoden kopiert.</p>
<p>Zusätzlich:</p>
<ul>
<li><code>@header</code>: Package-Deklarationen und/oder Importe (wird vor der
Klassendefinition eingefügt)</li>
<li><code>@members</code>: zusätzliche Attribute für die generierten Lexer- (und
Parser-) Klassen.</li>
</ul>
<p>Mit <code>@lexer::header</code> bzw. <code>@lexer::members</code> werden diese Codeblöcke nur in den
generierten Lexer eingefügt.</p>
<p><em>Anmerkung</em>: Lexer-Aktionen müssen am Ende der äußersten Alternative erscheinen.
Wenn eine Lexer-Regel mehr als eine Alternative hat, müssen diese in runde
Klammern eingeschlossen werden.</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/grammars.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/grammars.md</a>)</p>
<h2 id="hilfsregeln-mit-fragmenten">Hilfsregeln mit Fragmenten</h2>
<p>Fragmente sind Lexer-Regeln, die keine Token darstellen/erzeugen, aber
bei der Formulierung von Regeln für mehr Übersicht oder Wiederverwendung
sorgen. Fragmente werden mit dem Schlüsselwort <code>fragment</code> eingeleitet.</p>
<p><strong>Beispiel</strong>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>NUM         : <span style="color:#66d9ef">DIGIT</span><span style="color:#f92672">+</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fragment</span>
</span></span><span style="display:flex;"><span>DIGIT       : [0-9] ;</span></span></code></pre></div><p>=&gt; Keine Token (für den Parser)!</p>
<p>Hier würde der Parser nur <code>NUM</code> &quot;bekommen&quot;, aber keine <code>DIGIT</code>-Token.</p>
<h2 id="lexer-kommandos-auswahl">Lexer Kommandos (Auswahl)</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>TokenName : <span style="color:#66d9ef">Alternative</span> <span style="color:#f92672">-&gt;</span> command<span style="color:#960050;background-color:#1e0010">-</span>name</span></span></code></pre></div><ul>
<li>
<p><code>skip</code></p>
<p>Verwerfe den aktuellen Text: <code>WS : [ \t]+ -&gt; skip ;</code>
(liefert kein Token)</p>
</li>
<li>
<p><code>more</code></p>
<p>Lese weiter ...</p>
<p>Die Regel matcht zwar, aber es wird kein Token erzeugt. Die nächste
matchende Regel wird den hier gematchten Text mit in ihr Token einbauen.
Der Token-Typ ist der der zuletzt matchenden Regel.</p>
<p><em>Anmerkung</em>: Wird typischerweise zusammen mit Modes verwendet.</p>
</li>
<li>
<p><code>mode</code> (siehe unten)</p>
</li>
<li>
<p><code>channel</code> (siehe unten)</p>
</li>
</ul>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/lexer-rules.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/lexer-rules.md</a>)</p>
<h2 id="modes-und-insel-grammatiken">Modes und Insel-Grammatiken</h2>
<p>Umschalten zwischen verschiedenen Lexer-Modes: Wie verschiedene Sub-Lexer -
einen für jeden Kontext.</p>
<p>=&gt; Parsen von &quot;<em>Insel-Grammatiken</em>&quot; (beispielsweise XML).</p>
<p><em>Anmerkung</em>: <code>mode</code>-Spezifikation sind nur im Lexer-Teil der Grammatik erlaubt.</p>
<h3 id="allgemeines-schema">Allgemeines Schema</h3>
<pre><code>rules in default mode
...

mode MODE_1;
rules in MODE_1
...

mode MODE_N;
rules in MODE_N
...
</code></pre>
<h3 id="beispiel">Beispiel</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span><span style="color:#66d9ef">lexer</span> <span style="color:#66d9ef">grammar</span> <span style="color:#a6e22e">ModeLexer</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LCOMMENT    : <span style="color:#e6db74">&#39;/*&#39;</span> <span style="color:#f92672">-&gt;</span> more, mode<span style="color:#f92672">(</span><span style="color:#66d9ef">CMNT</span><span style="color:#f92672">)</span> ;
</span></span><span style="display:flex;"><span>WS          : [ \t\n]<span style="color:#f92672">+</span> <span style="color:#f92672">-&gt;</span> skip ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mode <span style="color:#960050;background-color:#1e0010">CMNT;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">COMMENT</span>     : <span style="color:#e6db74">&#39;*/&#39;</span> <span style="color:#f92672">-&gt;</span> mode<span style="color:#f92672">(</span><span style="color:#66d9ef">DEFAULT_MODE</span><span style="color:#f92672">)</span> ;
</span></span><span style="display:flex;"><span>CHAR        : <span style="color:#f92672">.</span> <span style="color:#f92672">-&gt;</span> more ;</span></span></code></pre></div><p>Nach dem Matchen des Tokens wird mit <code>mode(X)</code> in den Mode <code>X</code> umgeschaltet.
Der Lexer beachtet dann nur die Lexer-Regeln unter Mode <code>X</code>.</p>
<p>Mit <code>pushMode(X)</code> erreicht man das selbe Verhalten wie mit <code>mode(X)</code>,
allerdings wird vor dem Umschalten der aktuelle Mode auf einem Stack abgelegt.
Mit <code>popMode</code> kann der oberste Mode vom Stack wieder herunter genommen werden
und als aktueller Lexer-Mode gesetzt werden.</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/lexer-rules.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/lexer-rules.md</a>)</p>
<h2 id="channels">Channels</h2>
<p>Man kann die Token in verschiedene Kanäle (&quot;Channels&quot;) schicken. Beispielsweise
werden beim Parsen von Python-Programmen die White-Spaces evtl. noch benötigt.</p>
<p>Anstatt diese mit <code>skip</code> komplett zu verwerfen, kann man sie in einen anderen
Channel schicken, wo man sie im Parser bei Bedarf wieder abfragen kann. Der
Token-Index bleibt dabei erhalten, auch wenn die Token in verschiedene Kanäle
verteilt werden.</p>
<p><strong>Anmerkung</strong>: Channel-Spezifikationen sind nur im Lexer-Teil der Grammatik
erlaubt.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>channels { WHITESPACE, COMMENTS }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">BLOCK_COMMENT</span> : <span style="color:#e6db74">&#39;/*&#39;</span> <span style="color:#f92672">.*?</span> <span style="color:#e6db74">&#39;*/&#39;</span> <span style="color:#f92672">-&gt;</span> channel<span style="color:#f92672">(</span><span style="color:#66d9ef">COMMENTS</span><span style="color:#f92672">)</span> ;
</span></span><span style="display:flex;"><span>LINE_COMMENT  : <span style="color:#e6db74">&#39;//&#39;</span> <span style="color:#f92672">~</span>[\n]<span style="color:#f92672">*</span>   <span style="color:#f92672">-&gt;</span> channel<span style="color:#f92672">(</span><span style="color:#66d9ef">COMMENTS</span><span style="color:#f92672">)</span> ;
</span></span><span style="display:flex;"><span>WS            : [ \t\n]<span style="color:#f92672">+</span>      <span style="color:#f92672">-&gt;</span> channel<span style="color:#f92672">(</span><span style="color:#66d9ef">WHITESPACE</span><span style="color:#f92672">)</span> ;</span></span></code></pre></div><h2 id="grammatiken-importieren">Grammatiken importieren</h2>
<p>Mit <code>import XZY;</code> bindet man eine andere Grammatik <code>XYZ</code> ein. Dabei werden nur
Regeln eingebunden, die bisher noch nicht definiert wurden.</p>
<p>Aus einer anderen Perspektive kann man diesen Mechanismus mit dem Überschreiben
von Methoden in einer abgeleiteten Klasse vergleichen: Dann bekommt man beim
Aufruf einer überschriebenen Methode ebenfalls nur die &quot;neueste&quot;
Implementierung ...</p>
<p>Wenn mehrere verschachtelte Grammatiken eingebunden werden (wie im Beispiel),
dann wird per <em>Tiefensuche</em> der Einbindungsbaum durchlaufen.</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/grammars.md#grammar-imports" target="_blank">github.com/antlr/antlr4/blob/master/doc/grammars.md</a>)</p>
<h2 id="wrap-up">Wrap-Up</h2>
<p>Lexer mit ANTLR generieren: Lexer-Regeln werden mit <strong>Großbuchstaben</strong> geschrieben</p>
<ul>
<li>Längster Match gewinnt, Gleichstand: zuerst definierte Regel</li>
<li><em>non greedy</em>-Regeln: versuche so <em>wenig</em> Zeichen zu matchen wie möglich</li>
<li>Aktionen beim Matchen</li>
<li>Hilfsregeln mit &quot;Fragments&quot;</li>
<li>Lexer Kommandos: <code>skip</code>, <code>more</code>, ...</li>
<li>Modes für Insel-Grammatiken</li>
<li>Channels als parallele Tokenstreams (Vorsortieren)</li>
<li>Teilgrammatiken importieren</li>
</ul>


    



    



    

    
<div class="box notices cstyle note">
  <div class="box-label"><i class="fas fa-puzzle-piece"></i> Challenges</div>
  <div class="box-content">

<p><strong>Token und Lexer-Regeln mit ANTLR</strong></p>
<p>Formulieren Sie für ANTLR Lexer-Regeln, mit denen folgende Token erkannt werden:</p>
<ul>
<li>White-Space: Leerzeichen, Tabs, Zeilenumbrüche</li>
<li>Vergleichsoperatoren: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>&lt;&gt;</code></li>
<li>If: <code>if</code></li>
<li>Then: <code>then</code></li>
<li>Else: <code>else</code></li>
<li>Namen: Ein Buchstabe, gefolgt von beliebig vielen weiteren Buchstaben und/oder Ziffern</li>
<li>Numerische Konstanten: Mindestens eine Ziffer, gefolgt von maximal einem Paar bestehend aus einem Punkt und mindestens einer Ziffer, gefolgt von maximal einem Paar bestehend aus dem Buchstaben &quot;E&quot; gefolgt von einem &quot;+&quot; oder &quot;-&quot; und mindestens einer Ziffer.</li>
</ul>
<p>Formulieren Sie Hilfskonstrukte zur Verwendung in mehreren Lexer-Regeln als ANTLR-Fragmente.</p>
<p>White-Spaces sollen entfernt werden und nicht als Token weitergereicht werden.</p>
<p><strong>Real-World-Lexer mit ANTLR: Programmiersprache Lox</strong></p>
<p>Betrachten Sie folgenden Code-Schnipsel in der Sprache <a href="https://www.craftinginterpreters.com/the-lox-language.html" target="_blank">&quot;Lox&quot;</a>:</p>
<pre><code>fun fib(x) {
    if (x == 0) {
        return 0;
    } else {
        if (x == 1) {
            return 1;
        } else {
            fib(x - 1) + fib(x - 2);
        }
    }
}

var wuppie = fib(4);
</code></pre>
<p>Erstellen Sie für diese fiktive Sprache einen Lexer mit ANTLR. Die genauere Sprachdefinition finden Sie unter <a href="https://www.craftinginterpreters.com/the-lox-language.html" target="_blank">craftinginterpreters.com/the-lox-language.html</a>.</p>
<p><strong>Pig-Latin mit ANTLR-Lexer</strong></p>
<p>Schreiben Sie eine Lexer-Grammatik mit eingebetteten Aktionen für ANTLR sowie ein passendes Programm zur Einbindung des generierten Lexers, welches einen Text nach <a href="https://de.wikipedia.org/wiki/Pig_Latin" target="_blank">Pig Latin</a> übersetzt:</p>
<ul>
<li>Ist der erste Buchstabe eines Wortes ein Konsonant, schiebe ihn ans Ende des Wortes und füge &quot;ay&quot; an.</li>
<li>Ist der erste Buchstabe eines Wortes ein Vokal, hänge an das Wort ein &quot;ay&quot; an.</li>
</ul>
<p><strong>Lexing mit ANTLR</strong></p>
<p>In einem Telefonbuch sind zeilenweise Namen und Telefonnummern gespeichert.</p>
<p>Definieren Sie eine Lexer-Grammatik für ANTLR, mit der Sie die Zeilen einlesen können. Können Sie dabei verschiedene Formate der Telefonnummern berücksichtigen?</p>
<pre><code>Heinz 030 5346 983
Kalle +49 30 1234 567
Lina +49.571.8385-255
Rosi (0571) 8385-268
</code></pre>
<p>Können Sie die Grammatik so anpassen, dass Sie nur möglichst wenige verschiedene Token an den Parser weitergeben?</p>
<p>Ergänzen Sie Ihre Grammatik um Lexer-Aktionen, so dass Sie die Zeilen, die Zeichen (in den Namen) und die Ziffern (in den Telefonnummern) zählen können.</p>
</div>
</div>



    





    




    
    
        
        

        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

          </section>
        </div>
      </main>
    </div>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/clipboard.min.js?1697015446" defer></script>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/perfect-scrollbar.min.js?1697015446" defer></script>
    <script>
      function useMathJax( config ){
        if( !Object.assign ){
          
          return;
        }
        window.MathJax = Object.assign( window.MathJax || {}, {
          loader: {
            load: ['[tex]/mhchem']
          },
          startup: {
            elements: [
              '.math'
            ]
          },
          tex: {
            inlineMath: [
              ['$', '$'], 
              ['\\(', '\\)']
            ]
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/mathjax/tex-mml-chtml.js?1697015446"></script>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/theme.js?1697015446" defer></script>
  </body>
</html>
