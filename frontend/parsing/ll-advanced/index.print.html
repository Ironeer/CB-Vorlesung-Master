<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.119.0">
    <meta name="generator" content="Relearn 5.22.1">
    <meta name="description" content="">
    <meta name="author" content="cagix">
    <title>LL-Parser: Fortgeschrittene Techniken</title>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html" rel="canonical" type="text/html" title="LL-Parser: Fortgeschrittene Techniken">

    
    

    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/images/logo.png?1697015446" rel="icon" type="image/png">

    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fontawesome-all.min.css?1697015446" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fontawesome-all.min.css?1697015446" rel="stylesheet"></noscript>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/nucleus.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/auto-complete.css?1697015446" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/auto-complete.css?1697015446" rel="stylesheet"></noscript>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/perfect-scrollbar.min.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fonts.css?1697015446" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fonts.css?1697015446" rel="stylesheet"></noscript>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/theme.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/theme-auto.css?1697015446" rel="stylesheet" id="R-variant-style">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/variant.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/print.css?1697015446" rel="stylesheet" media="print">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/format-print.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/ie.css?1697015446" rel="stylesheet">
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/url.js?1697015446"></script>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/variant.js?1697015446"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/index.search.js";
      var root_url="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_Reset_view = 'Reset view';
      window.T_View_reset = 'View reset!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/www.hsbi.de\/elearning\/data\/FH-Bielefeld\/lm_data\/lm_1371719/';
      window.variants && variants.init( [ 'auto', 'zen-light', 'zen-dark', 'relearn-bright', 'relearn-light', 'relearn-dark' ] );
    </script><style type="text/css">

 
.center {
    align-content: center;
    text-align: center;
    margin: auto;
}
.alert {
    color: #ff3333;
}
.bsp {
    padding: 0.05cm;
    border-width: 0.05cm;
    border-style: solid;
    border-color: #ddd;
    background-color: #ddd;
    border-radius: 25px;
    float: right;
}
.cbox {
    padding: 0.2cm;
    border-width: 0.1cm;
    border-style: solid;
    border-color: #4070a0;
    background-color: #f2f2f2;
    margin: auto;
    width: 60%;
    text-align: center;
    overflow: auto;
}
.blueArrow {
    color: #4070a0;
    font-family: "Courier New", "Courier", monospace;
    font-weight: bold;
}
.origin {
    background-color: #ededed;
    font-size: 0.8em;
}
.showme {
    background-color: #ededed;
    font-size: 0.8em;
}


 
.tldr {
    background: #dbe4ed;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.recap {
    
    
   margin: 4px 0px 26px 0px;
}
.bib {
    background: #dbe4ed;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.outcomes {
    background: #d9e9d5;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.quizzes {
    background: #d9e9d5;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.challenges {
    background: #ebe4d6;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.assignments {
    background: #ebe4d6;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
h1.tldr, h1.recap, h1.bib, h1.outcomes, h1.quizzes, h1.challenges, h1.assignments {
    padding: 0px;
}


 
.noJsAlert {
    padding: 20px;
    background-color: #f44336;  
    color: white;
    margin-bottom: 15px;
}


 
.embed-video-player {
    position: relative;
    padding-bottom: 56%;
    height: 0;
    overflow: hidden;
}
.youtube-player {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border:0;
}


 
#header-wrapper {
    padding:0.6rem;
}


 
#shortcuts {
    padding-top: 2.0rem;
}


 
#chapter p {
    text-align: left;
}


 
figcaption h4 {
    margin-top:-2.5rem;
}
.border1 {
    border:1px solid black;
}

 
td ul, td ol {
    margin: 0 0 1rem 0.5rem;
    padding: 0 0 0 0.5rem;
}

 
h1 { font-size:2.8rem !important;}
h2 { font-size:2.2rem; margin:1.2rem 0}
h3 { font-size:1.9rem; text-align:left !important; font-weight:400 !important;}
h4 { font-size:1.6rem}
h5 { font-size:1.3rem}
h6 { font-size:1rem}

h2 {
    width:100% !important;
    border-bottom:1px solid #5e5e5e !important;
    padding-bottom: 2px;
}
.tldr h2, .recap h2, .bib h2, .outcomes h2, .quizzes h2, .challenges h2, .assignments h2 {
    margin:0.5rem 0
}

.btn-crossreference, .btn-crossreference:hover {
    cursor: initial;
}

</style>

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <span class="topbar-breadcrumbs highlightable">
            LL-Parser: Fortgeschrittene Techniken
          </span>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable " tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
<h1>LL-Parser: Fortgeschrittene Techniken</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p><a href="#R-image-fe0b6cbbf79deae0be869c70351cc1e3" class="lightbox-link"><img src="images/architektur_cb_parser.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fe0b6cbbf79deae0be869c70351cc1e3"><img src="images/architektur_cb_parser.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Man kann einen LL(k)-Parser bei Bedarf um ein &quot;spekulatives Matching&quot; ergänzen. Dies ist in Situationen
relevant, wo man das 
<span class="math align-center">$k$</span> nicht vorhersehen kann, etwa bei der Unterscheidung einer Vorwärtsdeklaration
und einer Funktionsdefinition in C. Hier kann man erst nach dem Parsen des Funktionsnamens entscheiden,
welche Situation vorliegt; der Funktionsname kann dabei (nahezu) beliebig lang sein.</p>
<p>Beim spekulativen Matching muss man sich merken, an welcher Position im Tokenstrom man die Spekulation
gestartet hat, um im Fall des Nichterfolgs dorthin wieder zurückspringen zu können (&quot;Backtracking&quot;).</p>
<p>Das Backtracking kann sehr langsam werden durch das Ausprobieren mehrerer Alternativen und das jeweils
nötige Zurückrollen. Zudem kann es passieren, dass eine bestimmte Sequenz immer wieder erkannt werden
muss. Hier hilft eine weitere Technik: <strong>Packrat Parsing</strong> <a href="#id_Packrat2006">[Packrat2006]</a> (nutzt
<a href="https://en.wikipedia.org/wiki/Memoization" target="_blank">&quot;<em>memoisation</em>&quot;</a>). Hierbei führt man pro Regel eine Map mit,
in der zu einer Position im Tokenstrom festgehalten wird, ob diese Regel an/ab dieser Position bereits
erfolgreich oder nicht erfolgreich war. Dies kann man dann nutzen, um bei einem erneuten Parsen der
selben Regel &quot;vorzuspulen&quot;.</p>
<p>In ANTLR kann man <em>semantische Prädikate</em> benutzen, um Alternativen &quot;abzuschalten&quot;. Dies ist beispielsweise
nützlich, wenn man nur eine Grammatik für unterschiedliche Versionen einer Sprache implementieren will.</p>
<p>Eine gute Darstellung finden Sie in <a href="#id_Parr2010">[Parr2010]</a> (Kapitel 3) und in [Packrat2006].</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/12GT2WxZsxY' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL LL-Parser: Fortgeschrittene Techniken</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/c3dc479884ce6b50bbd0fe85a8dd49f7b250576ac73742b879c564d6cba4b83c79fa499f9164b947e81e597add85e6addfd91a41a4eb85438c51218846aac0cb' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL LL-Parser: Fortgeschrittene Techniken</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K3) Implementierung von LL(1)- und LL(k)-Parsern</li> <li>(K3) Dynamischer Lookahead mittels Backtracking; Verbesserung der Laufzeiteigenschaften mit Packrat</li> <li>(K3) Einsatz von semantischen Prädikaten zum (De-) Aktivieren von Regeln oder Token</li></ul></div>
</div>




    <h2 id="ll-parser-mit-backtracking">LL-Parser mit Backtracking</h2>
<p>Problem: Manchmal kennt man den nötigen Lookahead nicht vorher. Beispiel:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>wuppie();         <span style="color:#75715e">// Vorwärtsdeklaration
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>wuppie() { ...}   <span style="color:#75715e">// Definition
</span></span></span></code></pre></div><p>Entsprechend sähe die Grammatik aus:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>func : fdef <span style="color:#f92672">|</span> fdecl ;
</span></span><span style="display:flex;"><span>fdef : head <span style="color:#e6db74">&#39;{&#39;</span> body <span style="color:#e6db74">&#39;}&#39;</span> ;
</span></span><span style="display:flex;"><span>fdecl: head <span style="color:#e6db74">&#39;;&#39;</span> ;
</span></span><span style="display:flex;"><span>head : <span style="color:#f92672">...</span> ;</span></span></code></pre></div><p>Hier müsste man erst den gesamten Funktionskopf parsen, bevor man entscheiden kann, ob es sich um
eine Deklaration oder eine Definition handelt. Unglücklicherweise gibt es keine Längenbeschränkung
bei den Funktionsnamen ...</p>
<p>Mit Hilfe von Backtracking kann man zunächst spekulativ matchen und beim Auftreten eines Fehlers
die Spekulation rückgängig machen:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">func</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> speculate(fdef): fdef()      <span style="color:#75715e"># Spekuliere auf &#34;fdef&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> speculate(fdecl): fdecl()  <span style="color:#75715e"># Spekuliere auf &#34;fdecl&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">Exception</span>()</span></span></code></pre></div><p>Die erste Alternative, die passt, gewinnt. Über die Reihenfolge der Spekulationen kann man
entsprechend Vorrangregeln implementieren.</p>
<h3 id="anmerkung">Anmerkung</h3>
<p>Man könnte die obige Grammatik umformen ...</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>func : head <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;{&#39;</span> body <span style="color:#e6db74">&#39;}&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;;&#39;</span><span style="color:#f92672">)</span> ;
</span></span><span style="display:flex;"><span>head : <span style="color:#f92672">...</span> ;</span></span></code></pre></div><p>...und bräuchte dann kein spekulatives Parsen mit Backtracking.</p>
<p>Da wir aber das Parsen mit Backtracking betrachten wollen, blenden wir diese Möglichkeit
jetzt einfach aus ;)</p>
<h2 id="details-spekulatives-matchen">Details: Spekulatives Matchen</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">speculate</span>(fn):
</span></span><span style="display:flex;"><span>    success <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    mark()                  <span style="color:#75715e"># markiere aktuelle Position</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>:   fn()             <span style="color:#75715e"># probiere Regel fn()</span>
</span></span><span style="display:flex;"><span>    catch: success <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    clear()                 <span style="color:#75715e"># Rollback</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> success</span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, p. 60]</a></span></p>
<p>Der Funktion <code>speculate</code> wird die zu testende Regel (Funktion) als Parameter übergeben, im obigen
Beispiel wären dies <code>fdef</code> bzw. <code>fdecl</code>.</p>
<p>Vor dem spekulativen Matchen muss die aktuelle Position im Tokenstrom markiert werden. Falls der
Versuch, die Deklaration zu matchen nicht funktioniert, wird der Regel-Aufruf eine Exception werfen,
entsprechend wird die Hilfsvariable gesetzt. Anschließend muss noch mit <code>clear()</code> das aktuelle
Token wieder hergestellt werden (wir sind ja nur im Spekulationsmodus, d.h. selbst im Erfolgsfall
wird ja die Regel noch &quot;richtig&quot; aufgerufen).</p>
<h2 id="spekulatives-matchen-hilfsmethoden-iii">Spekulatives Matchen: Hilfsmethoden I/II</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Parser</span>:
</span></span><span style="display:flex;"><span>    Lexer lexer
</span></span><span style="display:flex;"><span>    markers <span style="color:#f92672">=</span> []    <span style="color:#75715e"># Integer-Stack: speichere Tokenpositionen</span>
</span></span><span style="display:flex;"><span>    lookahead <span style="color:#f92672">=</span> []  <span style="color:#75715e"># Puffer (1 Token vorbefüllt via Konstruktor)</span>
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>       <span style="color:#75715e"># aktuelle Tokenposition im lookahead-Puffer</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">mark</span>():
</span></span><span style="display:flex;"><span>        markers<span style="color:#f92672">.</span>push(start)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">clear</span>():
</span></span><span style="display:flex;"><span>        start <span style="color:#f92672">=</span> markers<span style="color:#f92672">.</span>pop()</span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, pp. 61/62]</a></span></p>
<h2 id="spekulatives-matchen-hilfsmethoden-iiii">Spekulatives Matchen: Hilfsmethoden II/II</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">consume</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">++</span>start
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> start <span style="color:#f92672">==</span> lookahead<span style="color:#f92672">.</span>count() <span style="color:#f92672">and</span> markers<span style="color:#f92672">.</span>isEmpty():
</span></span><span style="display:flex;"><span>        start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; lookahead<span style="color:#f92672">.</span>clear()
</span></span><span style="display:flex;"><span>    sync(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lookahead</span>(i):
</span></span><span style="display:flex;"><span>    sync(i)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> lookahead<span style="color:#f92672">.</span>get(start<span style="color:#f92672">+</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sync</span>(i):
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> start <span style="color:#f92672">+</span> i <span style="color:#f92672">-</span> lookahead<span style="color:#f92672">.</span>count()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>        lookahead<span style="color:#f92672">.</span>add(lexer<span style="color:#f92672">.</span>nextToken()); <span style="color:#f92672">--</span>n</span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, pp. 61/62]</a></span></p>
<p><code>consume</code> holt wie immer das nächste Token, hier indem der Index <code>start</code> weiter gesetzt
wird und ein weiteres Token über <code>sync</code> in den Puffer geladen wird. Falls wir nicht am
Spekulieren sind und das Ende des Puffers erreicht haben, nutzen wir die Gelegenheit und
setzen den Puffer zurück. (Dies geht nicht, wenn wir spekulieren -- hier müssen wir ja
ggf. ein Rollback vornehmen und benötigen also den aktuellen Puffer dann noch.)</p>
<p>Die Funktion <code>sync</code> stellt sicher, dass ab der Position <code>start</code> noch <code>i</code> unverbrauchte
Token im Puffer sind.</p>
<h3 id="hinweis">Hinweis</h3>
<p>Die Methode <code>count</code> liefert die Anzahl der aktuell gespeicherten Elemente in <code>lookahead</code>
zurück (nicht die Gesamtzahl der Plätze in der Liste -- diese kann größer sein). Mit der
Methode <code>add</code> wird ein Element hinten an die Liste angefügt, dabei wird das Token auf den
nächsten Index-Platz (<code>count</code>) geschrieben und ggf. die Liste ggf. automatisch um weitere
Speicherplätze ergänzt. Über <code>clear</code> werden die Elemente in der Liste gelöscht, aber der
Speicherplatz erhalten (d.h. <code>count()</code> liefert den Wert 0, aber ein <code>add</code> müsste nicht erst
die Liste mit weiteren Plätzen erweitern, sondern könnte direkt an Index 0 das Token schreiben).</p>
<h3 id="backtracking-führt-zu-problemen">Backtracking führt zu Problemen</h3>
<ol>
<li>Backtracking kann <em>sehr</em> langsam sein (Ausprobieren vieler Alternativen)</li>
<li>Der spekulative Match muss ggf. rückgängig gemacht werden</li>
<li>Man muss bereits gematchte Strukturen erneut matchen (=&gt; Abhilfe: Packrat-Parsing)</li>
</ol>
<h2 id="verbesserung-backtracking-packrat-parser-memoizing">Verbesserung Backtracking: Packrat Parser (Memoizing)</h2>
<p><a href="#R-image-af4c00c1db659d4009b74342db18c290" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced/packrat.png?width=60%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 60%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-af4c00c1db659d4009b74342db18c290"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced/packrat.png?width=60%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Bei der Eingabe <code>wuppie();</code> wird zunächst spekulativ die erste Alternative <code>fdef</code> untersucht
und ein <code>head</code> gematcht. Da die Alternative nicht komplett passt (es kommt ein &quot;;&quot; statt
einem &quot;{&quot;), muss die Spekulation rückgängig gemacht werden und die zweite Alternative
<code>fdecl</code> untersucht werden. Dabei muss man den selben Input erneut auf <code>head</code> matchen!
(Und wenn die Spekulation (irgendwann) erfolgreich war, muss noch einmal ein <code>head</code> gematcht
werden ...)</p>
<p>Idee: Wenn <code>head</code> sich merken würde, ob damit ein bestimmter Teil des Tokenstroms bereits
behandelt wurde (erfolgreich oder nicht), könnte man das Spekulieren effizienter gestalten.
Jede Regel muss also durch eine passende Regel mit Speicherung ergänzt werden.</p>
<p>Dies wird auch als <a href="https://en.wikipedia.org/wiki/Memoization" target="_blank">&quot;Memoization&quot;</a> bezeichnet
und ist eine zentrales Technik des Packrat Parsers (vgl. <a href="#id_Packrat2006">[Packrat2006]</a>).</p>
<h2 id="skizze-idee-des-packrat-parsing">Skizze: Idee des Packrat-Parsing</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>head_memo <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">head</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> head_memo<span style="color:#f92672">.</span>get(start) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">Exception</span>()                         <span style="color:#75715e"># kein Match</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> head_memo<span style="color:#f92672">.</span>get(start) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        start <span style="color:#f92672">=</span> head_memo[start]; <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>     <span style="color:#75715e"># Vorspulen</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>; start_ <span style="color:#f92672">=</span> start
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span>: <span style="color:#f92672">...</span>     <span style="color:#75715e"># rufe die ursprüngliche head()-Regel auf</span>
</span></span><span style="display:flex;"><span>        catch(e): failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>; <span style="color:#66d9ef">raise</span> e
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">finally</span>: head_memo[start_] <span style="color:#f92672">=</span> (failed <span style="color:#960050;background-color:#1e0010">?</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> : start)</span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, pp. 65/66]</a></span></p>
<ul>
<li>Wenn bereits untersucht (Eintrag vorhanden): Vorspulen bzw. Exception werfen</li>
<li>Sonst (aktuelle Position noch nicht in der Tabelle =&gt; Regel noch nicht an
dieser Position getestet):
<ul>
<li>Original-Regel ausführen</li>
<li>Exception: Regel hatte keinen Erfolg =&gt; merken und Exception weiter reichen</li>
</ul>
</li>
<li>Ergebnis für diese Startposition und diese Regel merken:
<ul>
<li>Falls Regel erfolgreich, dann Start-Position und die aktuelle Position
(Stopp-Position) in der Tabelle für diese Regel notieren</li>
<li>Falls Regel nicht erfolgreich, zur Start-Position eine ungültige Position setzen</li>
</ul>
</li>
</ul>
<h3 id="anmerkung-consume">Anmerkung <em>consume()</em></h3>
<p>Die Funktion <code>consume()</code> muss passend ergänzt werden: Wann immer man den <code>lookahead</code>-Puffer
zurücksetzt, werden alle <code>*_memo</code> ungültig und müssen ebenfalls zurückgesetzt werden!</p>
<h2 id="semantische-prädikate">Semantische Prädikate</h2>
<p>Problem in Java: <code>enum</code> ab Java5 Schlüsselwort (vorher als Identifier-Name verwendbar)</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>prog : <span style="color:#f92672">(</span>enumDecl <span style="color:#f92672">|</span> stat<span style="color:#f92672">)+</span> ;
</span></span><span style="display:flex;"><span>stat : <span style="color:#f92672">...</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>enumDecl : <span style="color:#66d9ef">ENUM</span> id <span style="color:#e6db74">&#39;{&#39;</span> id <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;,&#39;</span> id<span style="color:#f92672">)*</span> <span style="color:#e6db74">&#39;}&#39;</span> ;</span></span></code></pre></div><p>Wie kann ich eine Grammatik bauen, die sowohl für Java5 und später als auch für die Vorgänger
von Java5 funktioniert?</p>
<p>Angenommen, man hätte eine Hilfsfunktion (&quot;Prädikat&quot;), mit denen man aus dem Kontext heraus
die Unterscheidung treffen kann, dann würde die Umsetzung der Regel ungefähr so aussehen:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">prog</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> lookahead(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> ENUM <span style="color:#f92672">and</span> java5: enumDecl()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: stat()</span></span></code></pre></div><h2 id="semantische-prädikate-in-antlr">Semantische Prädikate in ANTLR</h2>
<h3 id="semantische-prädikate-in-parser-regeln">Semantische Prädikate in Parser-Regeln</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>@parser::members {public static boolean java5;}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>prog : <span style="color:#f92672">(</span>{java5}<span style="color:#f92672">?</span> enumDecl <span style="color:#f92672">|</span> stat<span style="color:#f92672">)+</span> ;
</span></span><span style="display:flex;"><span>stat : <span style="color:#f92672">...</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>enumDecl : <span style="color:#66d9ef">ENUM</span> id <span style="color:#e6db74">&#39;{&#39;</span> id <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;,&#39;</span> id<span style="color:#f92672">)*</span> <span style="color:#e6db74">&#39;}&#39;</span> ;</span></span></code></pre></div><p>Prädikate in Parser-Regeln aktivieren bzw. deaktivieren alles, was nach der Abfrage
des Prädikats gematcht werden könnte.</p>
<h3 id="semantische-prädikate-in-lexer-regeln">Semantische Prädikate in Lexer-Regeln</h3>
<p>Alternativ für Lexer-Regeln:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>ENUM : <span style="color:#e6db74">&#39;enum&#39;</span> {java5}<span style="color:#f92672">?</span> ;
</span></span><span style="display:flex;"><span>ID   : [a-zA-Z]<span style="color:#f92672">+</span> ;</span></span></code></pre></div><p>Bei Token kommt das Prädikat erst am rechten Ende einer Lexer-Regel vor, da der Lexer keine
Vorhersage macht, sondern nach dem längsten Match sucht und die Entscheidung erst trifft,
wenn das ganze Token gesehen wurde. Bei Parser-Regeln steht das Prädikat links vor der
entsprechenden Alternative, da der Parser mit Hilfe des Lookaheads Vorhersagen trifft, welche
Regel/Alternative zutrifft.</p>
<p><em>Anmerkung</em>: Hier wurden nur Variablen eingesetzt, es können aber auch Methoden/Funktionen
genutzt werden. In Verbindung mit einer Symboltabelle (<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html/cb_symboltabellen1.html">&quot;Symboltabellen&quot;</a>)
und/oder mit Attributen und Aktionen in der Grammatik (<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html/cb_attribute.html">&quot;Attribute&quot;</a> und
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html/cb_interpreter2.html">&quot;Interpreter: Attribute+Aktionen&quot;</a>) hat man hier ein mächtiges Hilfswerkzeug!</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>LL(1) und LL(k): Erweiterungen
<ul>
<li>Dynamischer Lookahead: BT-Parser mit Packrat-Ergänzung</li>
<li>Semantische Prädikate zum Abschalten von Alternativen</li>
</ul>
</li>
</ul>


    



    



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Abschnitte 2.4 und 4.4</em></li> <li id='id_Grune2012'>[Grune2012] <strong>Modern Compiler Design</strong><br>Grune, D. und van, Reeuwijk, K. und Bal, H. E. und Jacobs, C. J. H. und Langendoen, K., Springer, 2012. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-4614-4698-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-4614-4698-9</a>.<br><em>Abschnitte 3.1 bis (einschließlich) 3.4</em></li> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 2 (insbesondere Abschnitte 2.3 bis (einschließlich) 2.19)</em></li> <li id='id_Packrat2006'>[Packrat2006] <a href='http://arxiv.org/abs/cs/0603077' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>Packrat Parsing: Simple, Powerful, Lazy, Linear Time</strong></a><br>Ford, B., 2006.</li> <li id='id_Parr2010'>[Parr2010] <strong>Language Implementation Patterns</strong><br>Parr, T., Pragmatic Bookshelf, 2010. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5645-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5645-6</a>.<br><em>Kapitel 3</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

        </div>
      </main>
    </div>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/clipboard.min.js?1697015446" defer></script>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/perfect-scrollbar.min.js?1697015446" defer></script>
    <script>
      function useMathJax( config ){
        if( !Object.assign ){
          
          return;
        }
        window.MathJax = Object.assign( window.MathJax || {}, {
          loader: {
            load: ['[tex]/mhchem']
          },
          startup: {
            elements: [
              '.math'
            ]
          },
          tex: {
            inlineMath: [
              ['$', '$'], 
              ['\\(', '\\)']
            ]
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/mathjax/tex-mml-chtml.js?1697015446"></script>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/theme.js?1697015446" defer></script>
  </body>
</html>
