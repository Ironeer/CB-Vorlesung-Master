<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.119.0">
    <meta name="generator" content="Relearn 5.22.1">
    <meta name="description" content="">
    <meta name="author" content="cagix">
    <title>Parser</title>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing.html" rel="canonical" type="text/html" title="Parser">

    
    

    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/images/logo.png?1697015446" rel="icon" type="image/png">

    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fontawesome-all.min.css?1697015446" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fontawesome-all.min.css?1697015446" rel="stylesheet"></noscript>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/nucleus.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/auto-complete.css?1697015446" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/auto-complete.css?1697015446" rel="stylesheet"></noscript>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/perfect-scrollbar.min.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fonts.css?1697015446" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fonts.css?1697015446" rel="stylesheet"></noscript>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/theme.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/theme-auto.css?1697015446" rel="stylesheet" id="R-variant-style">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/variant.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/print.css?1697015446" rel="stylesheet" media="print">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/format-print.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/ie.css?1697015446" rel="stylesheet">
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/url.js?1697015446"></script>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/variant.js?1697015446"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/index.search.js";
      var root_url="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_Reset_view = 'Reset view';
      window.T_View_reset = 'View reset!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/www.hsbi.de\/elearning\/data\/FH-Bielefeld\/lm_data\/lm_1371719/';
      window.variants && variants.init( [ 'auto', 'zen-light', 'zen-dark', 'relearn-bright', 'relearn-light', 'relearn-dark' ] );
    </script><style type="text/css">

 
.center {
    align-content: center;
    text-align: center;
    margin: auto;
}
.alert {
    color: #ff3333;
}
.bsp {
    padding: 0.05cm;
    border-width: 0.05cm;
    border-style: solid;
    border-color: #ddd;
    background-color: #ddd;
    border-radius: 25px;
    float: right;
}
.cbox {
    padding: 0.2cm;
    border-width: 0.1cm;
    border-style: solid;
    border-color: #4070a0;
    background-color: #f2f2f2;
    margin: auto;
    width: 60%;
    text-align: center;
    overflow: auto;
}
.blueArrow {
    color: #4070a0;
    font-family: "Courier New", "Courier", monospace;
    font-weight: bold;
}
.origin {
    background-color: #ededed;
    font-size: 0.8em;
}
.showme {
    background-color: #ededed;
    font-size: 0.8em;
}


 
.tldr {
    background: #dbe4ed;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.recap {
    
    
   margin: 4px 0px 26px 0px;
}
.bib {
    background: #dbe4ed;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.outcomes {
    background: #d9e9d5;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.quizzes {
    background: #d9e9d5;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.challenges {
    background: #ebe4d6;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.assignments {
    background: #ebe4d6;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
h1.tldr, h1.recap, h1.bib, h1.outcomes, h1.quizzes, h1.challenges, h1.assignments {
    padding: 0px;
}


 
.noJsAlert {
    padding: 20px;
    background-color: #f44336;  
    color: white;
    margin-bottom: 15px;
}


 
.embed-video-player {
    position: relative;
    padding-bottom: 56%;
    height: 0;
    overflow: hidden;
}
.youtube-player {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border:0;
}


 
#header-wrapper {
    padding:0.6rem;
}


 
#shortcuts {
    padding-top: 2.0rem;
}


 
#chapter p {
    text-align: left;
}


 
figcaption h4 {
    margin-top:-2.5rem;
}
.border1 {
    border:1px solid black;
}

 
td ul, td ol {
    margin: 0 0 1rem 0.5rem;
    padding: 0 0 0 0.5rem;
}

 
h1 { font-size:2.8rem !important;}
h2 { font-size:2.2rem; margin:1.2rem 0}
h3 { font-size:1.9rem; text-align:left !important; font-weight:400 !important;}
h4 { font-size:1.6rem}
h5 { font-size:1.3rem}
h6 { font-size:1rem}

h2 {
    width:100% !important;
    border-bottom:1px solid #5e5e5e !important;
    padding-bottom: 2px;
}
.tldr h2, .recap h2, .bib h2, .outcomes h2, .quizzes h2, .challenges h2, .assignments h2 {
    margin:0.5rem 0
}

.btn-crossreference, .btn-crossreference:hover {
    cursor: initial;
}

</style>

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <span class="topbar-breadcrumbs highlightable">
            Parser
          </span>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="parser">Parser</h1>

<p>Der Parser arbeitet mit dem Tokenstrom, der vom Lexer kommt. Mit Hilfe einer Grammatik wird
geprüft, ob hier gültige Sätze im Sinne der Sprache/Grammatik gebildet wurden. Der Parser
erzeugt dabei den Parse-Tree.</p>

<ul class="children children-li children-sort-">
	
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/cfg.html">CFG</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory.html">LL-Parser (Theorie)</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-impl.html">LL-Parser selbst implementiert</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html">LL-Parser: Fortgeschrittene Techniken</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing.html">Parser mit ANTLR generieren</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/finalwords.html">Grenze Lexer und Parser</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser1.html">Syntaxanalyse: LR-Parser (Teil 1)</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2.html">Syntaxanalyse: LR-Parser (Teil 2)</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery.html">Error-Recovery</a></li>
</ul>

            <footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Parser</h1>
<article class="default">
<h1>CFG</h1>



    
    




    
    
        
        
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="far fa-file-powerpoint"></i> Annotierte Folien</div>
  <div class="box-content">

<ul> <li><a href='https://raw.githubusercontent.com/Compiler-CampusMinden/AnnotatedSlides/master/frontend_parsing_cfg.ann.ma.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Annotierte Folien: CFG, LL-Parser</a></li></ul></div>
</div>




    <h1 id="wiederholung">Wiederholung</h1>
<h2 id="endliche-automaten-reguläre-ausdrücke-reguläre-grammatiken-reguläre-sprachen">Endliche Automaten, reguläre Ausdrücke, reguläre Grammatiken, reguläre Sprachen</h2>
<ul>
<li>Wie sind DFAs und NFAs definiert?</li>
<li>Was sind reguläre Ausdrücke?</li>
<li>Was sind formale und reguläre Grammatiken?</li>
<li>In welchem Zusammenhang stehen all diese Begriffe?</li>
<li>Wie werden DFAs und reguläre Ausdrücke im Compilerbau eingesetzt?</li>
</ul>
<h1 id="motivation">Motivation</h1>
<h2 id="wofür-reichen-reguläre-sprachen-nicht">Wofür reichen reguläre Sprachen nicht?</h2>
<p>Für z. B. alle Sprachen, in deren Wörtern Zeichen über eine Konstante hinaus gezählt werden müssen. Diese Sprachen lassen sich oft mit Variablen im Exponenten beschreiben, die unendlich viele Werte annehmen können.</p>
<ul>
<li>
<p>
<span class="math align-center">$a^ib^{2*i}$</span> ist nicht regulär</p>
</li>
<li>
<p>
<span class="math align-center">$a^ib^{2*i}$</span> für 
<span class="math align-center">$0 \leq i \leq 3$</span> ist regulär</p>
</li>
<li>
<p>Wo finden sich die oben genannten VAriablen bei einem DFA wieder?</p>
</li>
<li>
<p>Warum ist die erste Sprache oben nicht regulär, die zweite aber?</p>
</li>
</ul>
<h2 id="themen-für-heute">Themen für heute</h2>
<ul>
<li>PDAs: mächtiger als DFAs, NFAs</li>
<li>kontextfreie Grammatiken und Sprachen: mächtiger als reguläre Grammatiken und Sprachen</li>
<li>DPDAs und deterministisch kontextfreie Grammatiken: die Grundlage der Syntaxanalyse im Compilerbau</li>
</ul>
<h2 id="einordnung-erweiterung-der-automatenklasse-dfa-um-komplexere-sprachen-als-die-regulären-akzeptieren-zu-können">Einordnung: Erweiterung der Automatenklasse DFA, um komplexere Sprachen als die regulären akzeptieren zu können</h2>
<p>Wir spendieren den DFAs einen möglichst einfachen, aber beliebig großen, Speicher, um zählen und matchen zu können. Wir suchen dabei konzeptionell die &quot;kleinstmögliche&quot; Erweiterung, die die akzeptierte Sprachklasse gegenüber DFAs vergrößert.</p>
<ul>
<li>Der konzeptionell einfachste Speicher ist ein Stack. Wir haben keinen wahlfreien Zugriff auf die gespeicherten Werte.</li>
<li>Es soll eine deterministische und eine indeterministische Variante der neuen Automatenklasse geben.</li>
<li>In diesem Zusammenhang wird der Stack auch Keller genannt.</li>
</ul>
<h2 id="kellerautomaten-push-down-automata-pdas">Kellerautomaten (Push-Down-Automata, PDAs)</h2>
<p><strong>Def.:</strong> Ein Kellerautomat (PDA) 
<span class="math align-center">$P = (Q,\ \Sigma,\ \Gamma,\  \delta,\ q_0,\ \perp,\ F)$</span>
ist ein Septupel mit:</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/cfg/Def_PDA.png" alt="Definition eines PDAs" width="60%" height="auto">
    <figcaption><p>Definition eines PDAs</p></figcaption>
</figure>
<p>Ein PDA ist per Definition nichtdeterministisch und kann spontane Zustandsübergänge durchführen.</p>
<h2 id="was-kann-man-damit-akzeptieren">Was kann man damit akzeptieren?</h2>
<p>Strukturen mit paarweise zu matchenden Symbolen.</p>
<p>Bei jedem Zustandsübergang wird ein Zeichen (oder 
<span class="math align-center">$\epsilon$</span>) aus der Eingabe gelesen, ein Symbol von Keller genommen. Diese und das Eingabezeichen bestimmen den Folgezustand und eine Zeichenfolge, die auf den Stack gepackt wird. Dabei wird ein Symbol, das später mit einem Eingabesymbol zu matchen ist, auf den Stack gepackt.</p>
<p>Soll das automatisch vom Stack genommene Symbol auf dem Stack bleiben, muss es wieder gepusht werden.</p>
<h2 id="beispiel">Beispiel</h2>
<p>Ein PDA für 
<span class="math align-center">$L=\lbrace ww^{R}\mid w\in \lbrace a,b\rbrace^{\ast}\rbrace$</span>:</p>
<p><a href="#R-image-a729d67a963e5be38ca5a1c576fd1c5e" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/cfg/pda2.png?width=45%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 45%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a729d67a963e5be38ca5a1c576fd1c5e"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/cfg/pda2.png?width=45%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<h2 id="konfigurationen-von-pdas">Konfigurationen von PDAs</h2>
<p><strong>Def.:</strong> Eine Konfiguration (ID) eines PDAs 3-Tupel 
<span class="math align-center">$(q, w, \gamma)$</span>
mit</p>
<ul>
<li>
<span class="math align-center">$q$</span> ist ein Zustand</li>
<li>
<span class="math align-center">$w$</span> ist der verbleibende Input, 
<span class="math align-center">$w\in\Sigma^{\ast}$</span></li>
<li>
<span class="math align-center">$\gamma$</span> ist der Kellerinhalt 
<span class="math align-center">$\gamma\in \Gamma^{\ast}$</span></li>
</ul>
<p>eines PDAs zu einem gegebenen Zeitpunkt.</p>
<h2 id="die-übergangsrelation-eines-pdas">Die Übergangsrelation eines PDAs</h2>
<p><strong>Def.:</strong> Die Relation 
<span class="math align-center">$\vdash$</span> definiert Übergänge von einer Konfiguration zu einer anderen:</p>
<p>Sei 
<span class="math align-center">$(p, \alpha) \in \delta(q, a, X)$</span>, dann gilt 
<span class="math align-center">$\forall w\ \epsilon \ \Sigma^{\ast}$</span> und

<span class="math align-center">$\beta \in \Gamma^{\ast}$</span>:</p>
<p>
<span class="math align-center">$(q, aw, X\beta)\vdash(p, w, \alpha\beta)$</span>.</p>
<p><strong>Def.:</strong> Wir definieren mit 
<span class="math align-center">$\overset{\ast}{\vdash}$</span> 0 oder endlich viele Schritte des PDAs
induktiv wie folgt:</p>
<ul>
<li>Basis: 
<span class="math align-center">$I\overset{\ast}{\vdash} I$</span> für eine ID 
<span class="math align-center">$I$</span>.</li>
<li>Induktion: 
<span class="math align-center">$I\overset{\ast}{\vdash}J$</span>, wenn 
<span class="math align-center">$\exists$</span> ID 
<span class="math align-center">$K$</span> mit 
<span class="math align-center">$I\vdash K$</span> und 
<span class="math align-center">$K \overset{\ast}{\vdash}J$</span>.</li>
</ul>
<h2 id="eigenschaften-der-konfigurationsübergänge">Eigenschaften der Konfigurationsübergänge</h2>
<p><strong>Satz:</strong> Sei 
<span class="math align-center">$P=(Q, \Sigma, \Gamma, \delta, q_{0}, \perp, F)$</span> ein PDA und 
<span class="math align-center">$(q, x,\alpha)\overset{\ast}{\vdash} (p, y, \beta)$</span>. Dann gilt für beliebige Strings 
<span class="math align-center">$w\in\Sigma^{\ast}$</span>, 
<span class="math align-center">$\gamma$</span> in 
<span class="math align-center">$\Gamma^{\ast}$</span>:</p>

<span class="math align-center">$(q, xw, \alpha \gamma) \overset{\ast}{\vdash}(p, yw, \beta\gamma)$</span>
<p><strong>Satz:</strong> Sei 
<span class="math align-center">$P = (Q, \Sigma, \Gamma, \gamma, q_0, \perp, F)$</span> ein PDA und 
<span class="math align-center">$(q,xw,\alpha) \overset{\ast}{\vdash} (p,y w, \beta)$</span>.</p>
<p>Dann gilt: 
<span class="math align-center">$(q, x, a) \overset{\ast}{\vdash} (p, y, \beta)$</span></p>
<h2 id="akzeptierte-sprachen">Akzeptierte Sprachen</h2>
<p><strong>Def.:</strong> Sei 
<span class="math align-center">$P=(Q, \Sigma, \Gamma, \delta, q_0, \perp, F)$</span> ein PDA. Dann ist die <em>über einen Endzustand</em>
akzeptierte Sprache 
<span class="math align-center">$L(P) = \lbrace w \mid (q_0, w, \perp) \overset{\ast}{\vdash} (q, \epsilon, \alpha)\rbrace$</span>
für einen Zustand 
<span class="math align-center">$q \in F, \alpha \in \Gamma^{\ast}$</span>.</p>
<p><strong>Def.:</strong> Für einen PDA 
<span class="math align-center">$P=(Q, \Sigma, \Gamma, \delta, q_{0}, \perp, F)$</span>
definieren wir die über den <em>leeren Keller</em> akzeptierte Sprache

<span class="math align-center">$N(P) = \lbrace (w \mid (q_0, w, \perp) \overset{\ast}{\vdash} (q, \epsilon, \epsilon)\rbrace$</span>.</p>
<h2 id="akzeptanzäquivalenzen">Akzeptanzäquivalenzen</h2>
<p><strong>Satz:</strong> Wenn 
<span class="math align-center">$L = N(P_N)$</span> für einen PDA 
<span class="math align-center">$P_N$</span>, dann gibt es einen PDA 
<span class="math align-center">$P_L$</span> mit

<span class="math align-center">$L = L(P_L)$</span>.</p>
<p><strong>Satz:</strong> Für einen PDA 
<span class="math align-center">$P$</span> mit 
<span class="math align-center">$\epsilon$</span>-Transitionen existiert ein PDA 
<span class="math align-center">$Q$</span> ohne

<span class="math align-center">$\epsilon$</span>-Transitionen mit 
<span class="math align-center">$L(P) = N(P) = L(Q) = N(Q)$</span>.</p>
<p>Die Transitionsfunktion 
<span class="math align-center">$\delta$</span> ist dann von der Form

<span class="math align-center">$\delta: Q \times \Sigma \times \Gamma \to2^{Q \times \Gamma^{\ast}}$</span>.</p>
<h2 id="deterministische-pdas">Deterministische PDAs</h2>
<p><strong>Def.</strong> Ein PDA 
<span class="math align-center">$P = (Q, \Sigma, \Gamma, \delta, q_0, \perp, F)$</span> ist <em>deterministisch</em>

<span class="math align-center">$: \Leftrightarrow$</span></p>
<ul>
<li>
<span class="math align-center">$\delta(q, a, X)$</span> hat höchstens ein Element für jedes 
<span class="math align-center">$q \in Q, a \in\Sigma$</span> oder 
<span class="math align-center">$(a = \epsilon$</span> und 
<span class="math align-center">$X \in \Gamma)$</span>.</li>
<li>Wenn 
<span class="math align-center">$\delta (q, a, x)$</span> nicht leer ist für ein 
<span class="math align-center">$a \in \Sigma$</span>, dann muss 
<span class="math align-center">$\delta (q, \epsilon, x)$</span> leer sein.</li>
</ul>
<p>Deterministische PDAs werden auch <em>DPDAs</em> genannt.</p>
<h2 id="der-kleine-unterschied">Der kleine Unterschied</h2>
<p><strong>Satz:</strong> Die von DPDAs akzeptierten Sprachen sind eine echte Teilmenge der von
PDAs akzeptierten Sprachen.</p>
<p>Die Sprachen, die von <em>regex</em> beschrieben werden, sind eine echte Teilmenge der von
DPDAs akzeptierten Sprachen.</p>
<h1 id="kontextfreie-grammatiken-und-sprachen">Kontextfreie Grammatiken und Sprachen</h1>
<h2 id="kontextfreie-grammatiken">Kontextfreie Grammatiken</h2>
<p><strong>Def.</strong> Eine <em>kontextfreie (cf-)</em> Grammatik ist ein 4-Tupel 
<span class="math align-center">$G = (N, T, P, S)$</span> mit <em>N, T, S</em> wie in
(formalen) Grammatiken und <em>P</em> ist eine endliche Menge von Produktionen der Form:</p>
<p>
<span class="math align-center">$X \rightarrow Y$</span> mit 
<span class="math align-center">$X \in N, Y \in {(N \cup T)}^{\ast}$</span>.</p>
<p>
<span class="math align-center">$\Rightarrow, \overset{\ast}{\Rightarrow}$</span> sind definiert wie bei regulären Sprachen. Bei cf-Grammatiken nennt man die Ableitungsbäume oft <em>Parse trees</em>.</p>
<h2 id="beispiel-1">Beispiel</h2>

<span class="math align-center">$S \rightarrow a \mid S\ +\  S\ |\  S \ast S$</span>
<p>Ableitungsbäume für 
<span class="math align-center">$a + a \ast a$</span>:</p>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="mehrdeutige-grammatiken">Mehrdeutige Grammatiken</h2>
<p><strong>Def.:</strong> Gibt es in einer von einer kontextfreien Grammatik erzeugten Sprache ein
Wort, für das mehr als ein Ableitungsbaum existiert, so heißt diese Grammatik
<em>mehrdeutig</em>. Anderenfalls heißt sie <em>eindeutig</em>.</p>
<p><strong>Satz:</strong> Es gibt kontextfreie Sprachen, für die keine eindeutige Grammatik existiert.</p>
<h2 id="kontextfreie-grammatiken-und-pdas">Kontextfreie Grammatiken und PDAs</h2>
<p><strong>Satz:</strong> Die kontextfreien Sprachen und die Sprachen, die von PDAs akzeptiert werden, sind dieselbe
Sprachklasse.</p>
<p><strong>Satz:</strong> Sei 
<span class="math align-center">$L = N(P)$</span> für einen DPDA <em>P</em>, dann hat <em>L</em> eine eindeutige Grammatik.</p>
<p><strong>Def.:</strong> Die Klasse der Sprachen, die von einem DPDA akzeptiert werden, heißt
Klasse der <em>deterministisch kontextfreien (oder LR(k)-) Sprachen</em>.</p>
<h2 id="das-pumping-lemma-für-kontextfreie-sprachen">Das Pumping Lemma für kontextfreie Sprachen</h2>
<p>Wenn wir beweisen müssen, dass eine Sprache nicht cf ist, hilft das Pumping Lemma für cf-Sprachen:</p>
<p><strong>Satz:</strong> Sei <em>L</em> eine kontextfreie Sprache</p>
<p>
<span class="math align-center">$\Rightarrow \exists$</span> eine Konstante 
<span class="math align-center">$p \in \mathbb{N}$</span>:</p>
<p>
<span class="math align-center">$\underset{\underset{|z| \geq p} {z \in L}}\forall \exists$</span> 
<span class="math align-center">$u, v, w, x, y \in \Sigma ^{\ast}$</span> mit 
<span class="math align-center">$z = uvwxy$</span> und</p>
<ul>
<li>
<span class="math align-center">$\mid vwx\mid \leq p$</span></li>
<li>
<span class="math align-center">$vx \neq \epsilon$</span></li>
<li>
<span class="math align-center">$\forall i \geq 0 : uv^i wx^i y \in L$</span></li>
</ul>
<h2 id="abschlusseigenschaften-von-kontextfreien-sprachen">Abschlusseigenschaften von kontextfreien Sprachen</h2>
<p><strong>Satz:</strong> Die kontextfreien Sprachen sind abgeschlossen unter:</p>
<ul>
<li>Vereinigung</li>
<li>Konkatenation</li>
<li>Kleene-Hüllen 
<span class="math align-center">$L^{\ast}$</span> und 
<span class="math align-center">$L^+$</span></li>
</ul>
<p><strong>Satz:</strong> Wenn <em>L</em> kontextfrei ist, dann ist 
<span class="math align-center">$L^R$</span> kontextfrei.</p>
<h2 id="entscheidbarkeit-von-kontextfreien-grammatiken-und-sprachen">Entscheidbarkeit von kontextfreien Grammatiken und Sprachen</h2>
<p><strong>Satz:</strong> Es ist entscheidbar für eine kontextfreie Grammatik <em>G</em>,</p>
<ul>
<li>ob 
<span class="math align-center">$L(G) = \emptyset$</span></li>
<li>welche Symbole nach 
<span class="math align-center">$\epsilon$</span> abgeleitet werden können</li>
<li>welche Symbole erreichbar sind</li>
<li>ob 
<span class="math align-center">$w \in L(G)$</span> für ein gegebenes 
<span class="math align-center">$w \in {\Sigma}^{\ast}$</span></li>
</ul>
<p><strong>Satz:</strong> Es ist nicht entscheidbar,</p>
<ul>
<li>ob eine gegebene kontextfreie Grammatik eindeutig ist</li>
<li>ob der Durchschnitt zweier kontextfreier Sprachen leer ist</li>
<li>ob zwei kontextfreie Sprachen identisch sind</li>
<li>ob eine gegebene kontextfreie Sprache gleich 
<span class="math align-center">$\Sigma^{\ast}$</span> ist</li>
</ul>
<h2 id="abschlusseigenschaften-deterministisch-kontextfreier-sprachen">Abschlusseigenschaften deterministisch kontextfreier Sprachen</h2>
<p><strong>Satz:</strong> Deterministisch kontextfreie Sprachen sind abgeschlossen unter</p>
<ul>
<li>Durchschnitt mit regulären Sprachen</li>
<li>Komplement</li>
</ul>
<p>Sie sind nicht abgeschlossen unter</p>
<ul>
<li>Umkehrung</li>
<li>Vereinigung</li>
<li>Konkatenation</li>
</ul>
<h1 id="wrap-up">Wrap-Up</h1>
<h2 id="das-sollen-sie-mitnehmen">Das sollen Sie mitnehmen</h2>
<ul>
<li>Die Struktur von gängigen Programmiersprachen lässt sich nicht mit regulären Ausdrücken beschreiben und damit nicht mit DFAs akzeptieren.</li>
<li>Das Automatenmodell der DFAs wird um einen endlosen Stack erweitert, das ergibt PDAs.</li>
<li>Kontextfreie Grammatiken (CFGs) erweitern die regulären Grammatiken.</li>
<li>Deterministisch parsebare Sprachen haben eine eindeutige kontextfreie Grammatik.</li>
<li>Es ist nicht entscheidbar, ob eine gegebene kontextfreie Grammatik eindeutig ist.</li>
</ul>


    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_aho2013compilers'>[aho2013compilers] <strong>Compilers: Pearson New International Edition: Principles, Techniques, and Tools</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Education Limited, 2013. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-2920-3723-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-2920-3723-3</a>.</li> <li id='id_hopcroft2003'>[hopcroft2003] <strong>Einführung in die Automatentheorie, formale Sprachen und Komplexitätstheorie</strong><br>Hopcroft, J. E. und Motwani, R. und Ullman, J. D., Pearson Education Deutschland GmbH, 2003. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7020-4' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7020-4</a>.</li></ul></div>
</div>



    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) PDAs</li> <li>(K1) Deterministische PDAs</li> <li>(K1) Kontextfreie Grammatiken</li> <li>(K1) Deterministisch kontextfreie Grammatiken</li> <li>(K2) Zusammenhang zwischen PDAs und kontextfreien Grammatiken</li></ul></div>
</div>



    








<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>LL-Parser (Theorie)</h1>



    
    




    
    
        
        
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="far fa-file-powerpoint"></i> Annotierte Folien</div>
  <div class="box-content">

<ul> <li><a href='https://raw.githubusercontent.com/Compiler-CampusMinden/AnnotatedSlides/master/ll-parser-theory.ann.ma.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Annotierte Folien: LL-Parser (Theorie)</a></li></ul></div>
</div>




    <h1 id="wiederholung">Wiederholung</h1>
<h2 id="pdas-und-kontextfreie-grammatiken">PDAs und kontextfreie Grammatiken</h2>
<ul>
<li>Warum reichen uns DFAs nicht zum Matchen von Eingabezeichen?</li>
<li>Wie könnnen wir sie minimal erweitern?</li>
<li>Sind PDAs deterministisch?</li>
<li>Wie sind kontextfreie Grammatiken definiert?</li>
<li>Sind kontextfreie Grammatiken eindeutig?</li>
</ul>
<h1 id="motivation">Motivation</h1>
<h2 id="was-brauchen-wir-für-die-syntaxanalyse-von-programmen">Was brauchen wir für die Syntaxanalyse von Programmen?</h2>
<ul>
<li>einen Grammatiktypen, aus dem sich manuell oder automatisiert ein Programm zur deterministischen Syntaxanalyse erstellen lässt</li>
<li>einen Algorithmus zum sog. Parsen von Programmen mit Hilfe einer solchen Grammatik</li>
</ul>
<h2 id="themen-für-heute">Themen für heute</h2>
<ul>
<li>Arten der Syntaxanlyse</li>
<li>mehrdeutige Sprachen</li>
<li>Top-down-Analyse</li>
<li>LL(k)-Grammtiken</li>
</ul>
<h1 id="syntaxanalyse">Syntaxanalyse</h1>
<h2 id="syntax">Syntax</h2>
<p>Wir verstehen unter Syntax eine Menge von Regeln, die die Struktur von Daten (z. B. Programmen) bestimmen.</p>
<p>Syntaxanalyse ist die Bestimmung, ob Eingabedaten einer vorgegebenen Syntax entsprechen.</p>
<p>Diese vorgegebene Syntax wird im Compilerbau mit einer Grammatik beschrieben.</p>
<h2 id="ziele-der-syntaxanalyse">Ziele der Syntaxanalyse</h2>
<ul>
<li>aussagekräftige Fehlermeldungen, wenn ein Eingabeprogramm syntaktisch nicht korrekt ist</li>
<li>evtl. Fehlerkorrektur</li>
<li>Bestimmung der syntaktischen Struktur eines Programms</li>
<li>Erstellung des AST (abstrakter Syntaxbaum): Der Parse Tree ohne Symbole, die nach der Syntaxanalyse inhaltlich irrelevant sind (z. B. Semikolons, manche Schlüsselwörter)</li>
<li>die Symboltablelle(n) mit Informationen bzgl. Bezeichner (Variable, Funktionen und Methoden, Klassen, benutzerdefinierte Typen, Parameter, ...), aber auch die Gültigkeitsbereiche.</li>
</ul>
<h2 id="arten-der-syntaxanalyse">Arten der Syntaxanalyse</h2>
<p>Die Syntax bezieht sich auf die Struktur der zu analysierenden Eingabe, z. B. einem Computerprogramm in einer Hochsprache. Diese Struktur wird mit formalen Grammatiken beschrieben. Einsetzbar sind Grammatiken, die deterministisch kontextfreie Sprachen erzeugen.</p>
<ul>
<li>Top-Down-Analyse: Aufbau des Parse trees von oben
<ul>
<li>Parsen durch rekursiven Abstieg</li>
<li>LL-Parsing</li>
</ul>
</li>
<li>Bottom-Up-Analyse: LR-Parsing</li>
</ul>
<h2 id="mehrdeutigkeiten">Mehrdeutigkeiten</h2>
<p>Wir können nur mit eindeutigen Grammatiken arbeiten, aber:</p>
<p><strong>Def.:</strong> Eine formale Sprache L heißt <em>inhärent mehrdeutige Sprache</em>, wenn jede formale Grammatik <em>G</em> mit 
<span class="math align-center">$L(G) = L$</span> mehrdeutig ist.</p>
<p>Das heißt, solche Grammatiken existieren.</p>
<p>
<span class="math align-center">$\Rightarrow$</span> Es gibt keinen generellen Algorithmus, um Grammatiken eindeutig zu machen.</p>
<h2 id="bevor-wir-richtig-anfangen">Bevor wir richtig anfangen...</h2>
<p><strong>Def.:</strong> Ein Nichtterminal <em>A</em> einer kontextfreien Grammatik <em>G</em> heißt <em>unerreichbar</em>, falls es kein 
<span class="math align-center">$a,b \in {(N \cup T)}^{\ast}$</span> gibt mit 
<span class="math align-center">$S \overset{\ast}{\Rightarrow} aAb$</span>. Ein Nichtterminal <em>A</em> einer Grammatik <em>G</em> heißt <em>nutzlos</em>, wenn es kein Wort 
<span class="math align-center">$w \in T^{\ast}$</span> gibt mit 
<span class="math align-center">$A \overset{\ast}{\Rightarrow} w$</span>.</p>
<p><strong>Def.:</strong> Eine kontextfreie Grammatik 
<span class="math align-center">$G=(N, T, P, S)$</span> heißt <em>reduziert</em>, wenn es keine nutzlosen oder unerreichbaren Nichtterminale in <em>N</em> gibt.</p>
<p>Bevor mit einer Grammatik weitergearbeitet wird, müssen erst alle nutzlosen und dann alle unerreichbaren Symbole eliminiert werden. Wir betrachten ab jetzt nur reduzierte Grammatiken.</p>
<h1 id="top-down-analyse">Top-Down-Analyse</h1>
<h2 id="wie-würden-sie-manuell-parsen">Wie würden Sie manuell parsen?</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="algorithmus-rekursiver-abstieg">Algorithmus: Rekursiver Abstieg</h2>
<p>Hier ist ein einfacher Algorithmus, der (indeterministisch) einen Ableitungsbaum vom Nonterminal <em>X</em> von oben nach unten aufbaut:</p>
<p><strong>Eingabe:</strong> Ein Nichtterminal 
<span class="math align-center">$X$</span> und das nächste zu verarbeitende Eingabezeichen 
<span class="math align-center">$a$</span>.</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory/recursive_descent.png" alt="Recursive Descent-Algorithmus" width="55%" height="auto">
    <figcaption><p>Recursive Descent-Algorithmus</p></figcaption>
</figure>
<h2 id="grenzen-des-algorithmus">Grenzen des Algorithmus</h2>
<p>Was ist mit</p>
<ol>
<li>
<span class="math align-center">$X \rightarrow a \alpha \mid b \beta$</span></li>
<li>
<span class="math align-center">$X \rightarrow B\alpha \mid C \beta$</span></li>
<li>
<span class="math align-center">$X \rightarrow B \alpha \mid B \beta$</span></li>
<li>
<span class="math align-center">$X \rightarrow B \alpha \mid C \beta$</span> und 
<span class="math align-center">$C\rightarrow B$</span></li>
<li>
<span class="math align-center">$X \rightarrow X \beta$</span></li>
<li>
<span class="math align-center">$X \rightarrow B \alpha$</span> und 
<span class="math align-center">$B \rightarrow X \beta$</span></li>
</ol>
<p>
<span class="math align-center">$X, B, C, D \in N^{\ast}; a, b, c, d \in T^{\ast}; \beta$</span>, 
<span class="math align-center">$\alpha, \beta \in (N \cup T)^{\ast}$</span></p>
<h2 id="linksfaktorisierung">Linksfaktorisierung</h2>

<span class="math align-center">$X \rightarrow BC\  \vert \  BD$</span>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="algorithmus-linksfaktorisierung">Algorithmus: Linksfaktorisierung</h2>
<p><strong>Eingabe:</strong> Eine Grammatik G = (N, T, P, S)</p>
<p><strong>Ausgabe:</strong> Eine äquivalente links-faktorisierte Grammatik 
<span class="math align-center">$G'$</span></p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory/Linksfaktorisierung.png" alt="Algorithmus zur Linksfaktorisierung" width="85%" height="auto">
    <figcaption><p>Algorithmus zur Linksfaktorisierung</p></figcaption>
</figure>
<h2 id="linksrekursion">Linksrekursion</h2>
<p><strong>Def.:</strong> Eine Grammatik 
<span class="math align-center">$G=(N, T, P, S)$</span> heißt <em>linksrekursiv</em>, wenn sie ein Nichtterminal <em>X</em> hat, für das es eine Ableitung 
<span class="math align-center">$X \overset{+}{\Rightarrow} X\ \alpha$</span> für ein 
<span class="math align-center">$\alpha \in (N \cup T)^{\ast}$</span> gibt.</p>
<p>Linksrekursion gibt es</p>
<p><em>direkt</em>: 
<span class="math align-center">$X \rightarrow X \alpha$</span></p>
<p>und</p>
<p><em>indirekt</em>: 
<span class="math align-center">$X \rightarrow \ldots \rightarrow \ldots \rightarrow X \alpha$</span></p>
<h2 id="algorithmus-entfernung-von-direkter-linksrekursion" class="fragile">Algorithmus: Entfernung von direkter Linksrekursion</h2>
<p><strong>Eingabe:</strong> Eine Grammatik G = (N, T, P, S)</p>
<p><strong>Ausgabe:</strong> Eine äquivalente Grammatik 
<span class="math align-center">$G'$</span> ohne direkte Linksrekursion</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory/direkte_Linksrekursion_Elim.png" alt="Algorithmus zur Entfernung direkter Linksrekursion" width="55%" height="auto">
    <figcaption><p>Algorithmus zur Entfernung direkter Linksrekursion</p></figcaption>
</figure>
<h2 id="algorithmus-entfernung-von-indirekter-linksrekursion" class="fragile">Algorithmus: Entfernung von indirekter Linksrekursion</h2>
<p><strong>Eingabe:</strong> Eine Grammatik G = (N, T, P, S) mit 
<span class="math align-center">$N= \lbrace X_1, X_2, \ldots X_n\rbrace$</span> ohne 
<span class="math align-center">$\epsilon$</span>-Regeln oder Zyklen der Form 
<span class="math align-center">$X_1 \rightarrow X_2, X_2 \rightarrow X_3, \ldots X_{m-1} \rightarrow X_m, X_m \rightarrow X_1$</span></p>
<p><strong>Ausgabe:</strong> Eine äquivalente Grammatik 
<span class="math align-center">$G'$</span> ohne Linksrekursion</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory/indirekte_Linksrekursion_Elim.png" alt="Algorithmus zur Entfernung indirekter Linksrekursion" width="60%" height="auto">
    <figcaption><p>Algorithmus zur Entfernung indirekter Linksrekursion</p></figcaption>
</figure>
<h1 id="arbeiten-mit-generierten-parsern-llk-grammatiken">Arbeiten mit generierten Parsern: LL(k)-Grammatiken</h1>
<h2 id="first-mengen">First-Mengen</h2>

<span class="math align-center">$S \rightarrow A \ \vert \ B \ \vert \ C$</span>
<p>Welche Produktion nehmen?</p>
<p>Wir brauchen die &quot;terminalen k-Anfänge&quot; von Ableitungen von Nichtterminalen, um eindeutig die nächste zu benutzende Produktion festzulegen. 
<span class="math align-center">$k$</span> ist dabei die Anzahl der Vorschautoken.</p>
<p><strong>Def.:</strong> Wir definieren 
<span class="math align-center">$First$</span> - Mengen einer Grammatik wie folgt:</p>
<ul>
<li>
<span class="math align-center">$a \in T^\ast, |a| \leq k: {First}_k (a) = \lbrace a\rbrace$</span></li>
<li>
<span class="math align-center">$a \in T^\ast, |a| > k: {First}_k (a) = \lbrace v \in T^\ast \mid a = vw, |v| = k\rbrace$</span></li>
<li>
<span class="math align-center">$\alpha \in (N \cup T)^\ast \backslash T^\ast: {First}_k (\alpha) = \lbrace v \in T^\ast \mid \alpha \overset{\ast}{\Rightarrow} w,\text{mit}\ w \in T^\ast, First_k(w) = \lbrace v \rbrace \rbrace$</span></li>
</ul>
<h2 id="linksableitungen">Linksableitungen</h2>
<p><strong>Def.:</strong> Bei einer kontextfreien Grammatik 
<span class="math align-center">$G$</span> ist die <em>Linksableitung</em> von 
<span class="math align-center">$\alpha \in (N \cup T)^{\ast}$</span> die Ableitung, die man erhält, wenn in jedem Schritt das am weitesten links stehende Nichtterminal in 
<span class="math align-center">$\alpha$</span> abgeleitet wird.</p>
<p>Man schreibt 
<span class="math align-center">$\alpha \overset{\ast}{\Rightarrow}_l \beta.$</span></p>
<h2 id="follow-mengen">Follow-Mengen</h2>
<p>Manchmal müssen wir wissen, welche terminalen Zeichen hinter einem Nichtterminal stehen können.</p>
<p><strong>Def.</strong> Wir definieren <em>Follow</em> - Mengen einer Grammatik wie folgt:</p>

<span class="math align-center">$\forall \beta \in (N \cup T)^*:$</span>

<span class="math align-center">$$Follow_k(\beta) = \lbrace w \in T^\ast \mid \exists \alpha, \gamma \in  (N \cup T)^\ast\ \text{ mit }\ S \overset{\ast}{\Rightarrow}_l \alpha \beta \gamma\ \text{ und }\ w \in First_k(\gamma) \rbrace$$</span>
<h2 id="llk-grammatiken">LL(k)-Grammatiken</h2>
<p><strong>Def.:</strong> Eine kontextfreie Grammatik <em>G = (N, T, P, S)</em> ist genau dann eine <em>LL(k)</em>-Grammatik, wenn für alle Linksableitungen der Form:</p>

<span class="math align-center">$S \overset{\ast}{\Rightarrow}_l\ wA \gamma\ {\Rightarrow}_l\ w\alpha\gamma \overset{\ast}{\Rightarrow}_l wx$</span>
<p>und</p>

<span class="math align-center">$S \overset{\ast}{\Rightarrow}_l wA \gamma {\Rightarrow}_l w\beta\gamma \overset{\ast}{\Rightarrow}_l wy$</span>
<p>mit 
<span class="math align-center">$(w, x, y \in T^\ast, \alpha, \beta, \gamma \in (N \cup T)^\ast, A \in N)$</span> und 
<span class="math align-center">$First_k(x) = First_k(y)$</span>
gilt:</p>

<span class="math align-center">$\alpha = \beta$</span>
<h2 id="llk-grammatiken-1">LL(k)-Grammatiken</h2>
<p>Das hilft manchmal:</p>
<p>Für 
<span class="math align-center">$k = 1$</span>:
G ist 
<span class="math align-center">$LL(1): \forall A \rightarrow \alpha, A \rightarrow \beta \in P, \alpha \neq \beta$</span> gilt:</p>
<ol>
<li>
<span class="math align-center">$\lnot \exists a \in T: \alpha \overset{\ast}{\Rightarrow}_l a\alpha_1$</span> und 
<span class="math align-center">$\beta \overset{\ast}{\Rightarrow}_l a\beta_1$</span></li>
<li>
<span class="math align-center">$((\alpha \overset{\ast}{\Rightarrow}_l \epsilon) \Rightarrow (\lnot (\beta \overset{\ast}{\Rightarrow}_l \epsilon)))$</span> und 
<span class="math align-center">$((\beta \overset{\ast}{\Rightarrow}_l \epsilon) \Rightarrow (\lnot (\alpha\overset{\ast}{\Rightarrow}_l \epsilon)))$</span></li>
<li>
<span class="math align-center">$((\beta \overset{\ast}{\Rightarrow}_l \epsilon)$</span> und 
<span class="math align-center">$(\alpha \overset{\ast}{\Rightarrow}_l a\alpha_1)) \Rightarrow a \notin Follow(A)$</span></li>
<li>
<span class="math align-center">$((\alpha \overset{\ast}{\Rightarrow}_l \epsilon)$</span> und 
<span class="math align-center">$(\beta \overset{\ast}{\Rightarrow}_l a\beta_1)) \Rightarrow a \notin Follow(A)$</span></li>
</ol>
<p>Die ersten beiden Zeilen bedeuten:</p>
<p>
<span class="math align-center">$\alpha$</span> und 
<span class="math align-center">$\beta$</span> können nicht beide 
<span class="math align-center">$\epsilon$</span> ableiten, 
<span class="math align-center">$First_1(\alpha) \cap First_1(\beta) = \emptyset$</span></p>
<p>Die dritte und vierte Zeile bedeuten:</p>

<span class="math align-center">$(\epsilon \in First_1(\beta)) \Rightarrow (First_1(\alpha) \cap Follow_1(A) = \emptyset)$</span>

<span class="math align-center">$(\epsilon \in First_1(\alpha)) \Rightarrow (First_1(\beta) \cap Follow_1(A) = \emptyset)$</span>
<h2 id="ll1-grammatiken">LL(1)-Grammatiken</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="llk-sprachen">LL(k)-Sprachen</h2>
<p>Die von <em>LL(k)</em>-Grammatiken erzeugten Sprachen sind eine echte Teilmenge der deterministisch parsbaren Sprachen.</p>
<p>Die von <em>LL(k)</em>-Grammatiken erzeugten Sprachen sind eine echte Teilmenge der von <em>LL(k+1)</em>-Grammatiken erzeugten Sprachen.</p>
<p>Für eine kontextfreie Grammatik <em>G</em> ist nicht entscheidbar, ob es eine <em>LL(1)</em> - Grammatik <em>G'</em> gibt mit 
<span class="math align-center">$L(G) = L(G')$</span>.</p>
<p>In der Praxis reichen 
<span class="math align-center">$LL(1)$</span> - Grammatiken oft. Hier gibt es effiziente Parsergeneratoren, deren Eingabe eine LL(k)- (meist LL(1)-) Grammatik ist, und die als Ausgabe den Quellcode eines (effizienten) tabellengesteuerten Parsers generieren.</p>
<h2 id="algorithmus-konstruktion-einer-ll-parsertabelle" class="fragile">Algorithmus: Konstruktion einer LL-Parsertabelle</h2>
<p><strong>Eingabe:</strong> Eine Grammatik G = (N, T, P, S)</p>
<p><strong>Ausgabe:</strong> Eine Parsertabelle <em>P</em></p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory/LL-Parsertabelle.png" alt="Algorithmus zur Generierung einer LL-Parsertabelle" width="60%" height="auto">
    <figcaption><p>Algorithmus zur Generierung einer LL-Parsertabelle</p></figcaption>
</figure>
<p>Hier ist 
<span class="math align-center">$\perp$</span> das Endezeichen des Inputs.
Statt 
<span class="math align-center">$First_1(\alpha)$</span> und 
<span class="math align-center">$Follow_1(\alpha)$</span> wird oft nur 
<span class="math align-center">$First(\alpha)$</span> und 
<span class="math align-center">$Follow(\alpha)$</span> geschrieben.</p>
<h2 id="ll-parsertabellen">LL-Parsertabellen</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="ll-parsertabellen-1">LL-Parsertabellen</h2>
<p>Rekursive Programmierung bedeutet, dass das Laufzeitsystem einen Stack benutzt (bei einem Recursive-Descent-Parser, aber auch bei der Parsertabelle). Diesen Stack kann man auch &quot;selbst programmieren&quot;, d. h. einen PDA implementieren. Dabei wird ebenfalls die oben genannte Tabelle zur Bestimmung der nächsten anzuwendenden Produktion benutzt. Der Stack enthält die zu erwartenden Eingabezeichen, wenn immer eine Linksableitung gebildet wird. Diese Zeichen im Stack werden mit dem Input gematcht.</p>
<h2 id="algorithmus-tabellengesteuertes-ll-parsen-mit-einem-pda" class="fragile">Algorithmus: Tabellengesteuertes LL-Parsen mit einem PDA</h2>
<p><strong>Eingabe:</strong> Eine Grammatik G = (N, T, P, S), eine Parsertabelle <em>P</em> mit 
<span class="math align-center">$w\perp$</span> als initialem Kellerinhalt</p>
<p><strong>Ausgabe:</strong> Wenn 
<span class="math align-center">$w \in L(G)$</span>, eine Linksableitung von 
<span class="math align-center">$w$</span>, Fehler sonst</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory/LL-Parser.png" alt="Algorithmus zum tabellengesteuerten LL-Parsen" width="50%" height="auto">
    <figcaption><p>Algorithmus zum tabellengesteuerten LL-Parsen</p></figcaption>
</figure>
<p>Der Eingabestring sei 
<span class="math align-center">$w\perp$</span>, der initiale Kellerinhalt sei 
<span class="math align-center">$\perp$</span>.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>Syntaxanalyse wird mit deterministisch kontextfreien Grammatiken durchgeführt.</li>
<li>Eine Teilmenge der dazu gehörigen Sprachen lässt sich top-down parsen.</li>
<li>Ein einfacher Recursive-Descent-Parser arbeitet mit Backtracking.</li>
<li>Ein effizienter LL(k)-Parser realisiert einen DPDA und kann automatisch aus einer LL(k)-Grammatik generiert werden.</li>
<li>Der Parser liefert in der Regel einen abstrakten Syntaxbaum.</li>
</ul>


    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_aho2013compilers'>[aho2013compilers] <strong>Compilers: Pearson New International Edition: Principles, Techniques, and Tools</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Education Limited, 2013. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-2920-3723-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-2920-3723-3</a>.</li> <li id='id_hopcroft2003'>[hopcroft2003] <strong>Einführung in die Automatentheorie, formale Sprachen und Komplexitätstheorie</strong><br>Hopcroft, J. E. und Motwani, R. und Ullman, J. D., Pearson Education Deutschland GmbH, 2003. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7020-4' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7020-4</a>.</li></ul></div>
</div>



    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) Top-Down-Analyse</li> <li>(K1) Recursive-Descent-Parser</li> <li>(K1) First- und Follow-Mengen</li> <li>(K1) LL-Parser</li> <li>(K2) Zusammenhang zwischen PDAs und kontextfreien Grammatiken</li> <li>(K2) Schreiben von LL-Parsern</li> <li>(K3) Top-Down Analyse programmieren</li></ul></div>
</div>



    








<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>LL-Parser selbst implementiert</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p><a href="#R-image-50771504926c371efe57cccd005207e1" class="lightbox-link"><img src="images/architektur_cb_parser.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-50771504926c371efe57cccd005207e1"><img src="images/architektur_cb_parser.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>LL-Parser können über einen &quot;rekursiven Abstieg&quot; direkt aus einer Grammatik implementiert werden:</p>
<ul>
<li>Zu jeder Produktionsregel erstellt man eine gleichnamige Funktion.</li>
<li>Wenn in der Produktionsregel andere Regeln &quot;aufgerufen&quot; werden, erfolgt in der Funktion an
dieser Stelle der entsprechende Funktionsaufruf.</li>
<li>Bei Terminalsymbolen wird das erwartete Token geprüft.</li>
</ul>
<p>Dabei findet man wie bereits im Lexer die Funktionen <code>match</code> und <code>consume</code>, die sich hier aber
auf den Tokenstrom beziehen. LL(1)-Parser schauen dabei immer das nächste Token an, LL(k) haben
ein entsprechendes Look-Ahead von 
<span class="math align-center">$k$</span> Token. Dies kann man mit einem Ringpuffer für die Token
realisieren.</p>
<p>Zur Beachtung der Vorrang- und Assoziativitätsregeln muss die Grammatik entsprechend umgebaut
werden. LL-Parser haben durch die Betrachtung des aktuellen Vorschau-Tokens ein Problem mit
Linksrekursion in der Grammatik, diese muss zunächst beseitigt werden. (ANTLR bietet hier gewisse
Vereinfachungen an, kann aber mit indirekter Linksrekursion auch nicht umgehen.)</p>
<p>Eine gute Darstellung finden Sie in <a href="#id_Parr2010">[Parr2010]</a> (Kapitel 2).</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/3djLtMtW82k' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL LL-Parser selbst implementiert</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/fc75fe2bfb0c45447689e386f3e0c227bb30a0d081374134c60e20392a1f8c54536a749aefec5c5825c4d8c9e9aa77c30b37acb56e9b3c314da17691d9c5eee8' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL LL-Parser selbst implementiert</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K2) Prinzipieller Aufbau von LL-Parsern</li> <li>(K3) Implementierung von LL(1)- und LL(k)-Parsern</li> <li>(K3) Implementierung von Vorrang und Assoziativität</li> <li>(K3) Umgang mit Linksrekursion, insbesondere bei ANTLR</li></ul></div>
</div>




    <h2 id="erinnerung-lexer-zeichenstrom--tokenstrom">Erinnerung Lexer: Zeichenstrom =&gt; Tokenstrom</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">nextToken</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (peek <span style="color:#f92672">!=</span> EOF):  <span style="color:#75715e"># globale Variable, über consume()</span>
</span></span><span style="display:flex;"><span>        switch (peek):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39; &#39;</span>: <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#39;</span>: <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>: WS(); <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;[&#39;</span>: consume(); <span style="color:#66d9ef">return</span> Token(LBRACK, <span style="color:#e6db74">&#39;[&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>            default: <span style="color:#66d9ef">raise</span> Error(<span style="color:#e6db74">&#34;invalid character: &#34;</span><span style="color:#f92672">+</span>peek)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Token(EOF_Type, <span style="color:#e6db74">&#34;&lt;EOF&gt;&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">match</span>(c):   <span style="color:#75715e"># Lookahead: Ein Zeichen</span>
</span></span><span style="display:flex;"><span>    consume()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (peek <span style="color:#f92672">==</span> c): <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: rollBack(); <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">consume</span>():
</span></span><span style="display:flex;"><span>    peek <span style="color:#f92672">=</span> buffer[start]
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> (start<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) mod <span style="color:#ae81ff">2</span>n
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (start mod n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>        fill(buffer[start:start<span style="color:#f92672">+</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>        end <span style="color:#f92672">=</span> (start<span style="color:#f92672">+</span>n) mod <span style="color:#ae81ff">2</span>n</span></span></code></pre></div><p>Erinnerung: Der Lexer arbeitet direkt auf dem Zeichenstrom und versucht über längste Matches daraus
einen Tokenstrom zu erzeugen. Dabei wird immer das nächste Zeichen angeschaut (Funktion <code>match</code>) und
mit <code>consume</code> das aktuelle Zeichen &quot;verbraucht&quot; und das nächste Zeichen geladen. Hier kann man über
die Doppel-Puffer-Strategie das Einlesen einzelner Zeichen aus einer Datei vermeiden und immer blockweise
in den Puffer einlesen.</p>
<h2 id="grundidee-ll-parser">Grundidee LL-Parser</h2>
<p>Grammatik:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>r : <span style="color:#66d9ef">X</span> s ;</span></span></code></pre></div><p>LL-Implementierung:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">r</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span>(X)
</span></span><span style="display:flex;"><span>    s()</span></span></code></pre></div><ul>
<li>Für jede Regel in der Grammatik wird eine Methode/Funktion mit dem selben Namen definiert</li>
<li>Referenzen auf ein Token <code>T</code> werden durch den Aufruf der Methode <code>match(T)</code> aufgelöst
<ul>
<li><code>match(T)</code> &quot;konsumiert&quot; das aktuelle Token, falls dieses mit <code>T</code> übereinstimmt</li>
<li>Anderenfalls löst <code>match()</code> eine Exception aus</li>
</ul>
</li>
<li>Referenzen auf Regeln <code>s</code> werden durch Methodenaufrufe <code>s()</code> aufgelöst</li>
</ul>
<p><em>Erinnerung</em>: In ANTLR werden Parser-Regeln (non-Terminale) mit einem kleinen und Lexer-Regeln
(Terminale/Token) mit einem großen Anfangsbuchstaben geschrieben.</p>
<h2 id="alternative-subregeln">Alternative Subregeln</h2>
<pre><code>a | b | c
</code></pre>
<p>kann zu einem <code>switch</code>-Konstrukt aufgelöst werden:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>switch (lookahead):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> predicting_a:
</span></span><span style="display:flex;"><span>        a(); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> predicting_b:
</span></span><span style="display:flex;"><span>        b(); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    default: <span style="color:#66d9ef">raise</span> Error()</span></span></code></pre></div><p>Dabei ist <code>lookahead</code> eine globale Variable, die das zu betrachtende Token enthält
(vergleichbar mit <code>peek</code> beim Lexer).</p>
<p>Das Prädikat <code>predicting_a</code> soll andeuten, dass man mit dem aktuellen Token eine
Vorhersage für die Regel <code>a</code> versucht (hier kommen die FIRST- und FOLLOW-Mengen
ins Spiel ...). Wenn das der Fall ist, springt man entsprechend in die Funktion
bzw. Methode <code>a()</code>.</p>
<h2 id="optionale-subregeln-eins-oder-keins">Optionale Subregeln: Eins oder keins</h2>
<pre><code>(T)?
</code></pre>
<p>wird zu einem <code>if</code> ohne <code>else</code>-Teil:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> lookahead<span style="color:#f92672">.</span>predicting_T: <span style="color:#66d9ef">match</span>(T)</span></span></code></pre></div><h2 id="optionale-subregeln-mindestens-eins">Optionale Subregeln: Mindestens eins</h2>
<pre><code>(T)+
</code></pre>
<p>wird zu einer <code>do-while</code>-Schleife (mind. ein Durchlauf):</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span>(T)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> lookahead<span style="color:#f92672">.</span>predicting_T: <span style="color:#66d9ef">break</span></span></span></code></pre></div><h2 id="ll1-parser">LL(1)-Parser</h2>
<p>Beispiel: Parsen von Listen, also Sequenzen wie <code>[1,2,3,4]</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>list     : <span style="color:#e6db74">&#39;[&#39;</span> elements <span style="color:#e6db74">&#39;]&#39;</span> ;
</span></span><span style="display:flex;"><span>elements : <span style="color:#66d9ef">INT</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;,&#39;</span> <span style="color:#66d9ef">INT</span><span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>INT      : <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">..</span><span style="color:#e6db74">&#39;9&#39;</span><span style="color:#f92672">)+</span> ;</span></span></code></pre></div><p>Formal berechnet man die Lookahead-Mengen mit <code>FIRST</code> und <code>FOLLOW</code>, um eine Entscheidung
für die nächste Regel zu treffen. Praktisch betrachtet kann man sich fragen, welche(s)
Token eine Phrase in der aktuellen Alternative starten können.</p>
<p>Für LL(1)-Parser betrachtet man immer das <strong>aktuelle</strong> Token (<strong>genau <em>EIN</em> Lookahead-Token</strong>),
um eine Entscheidung zu treffen.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">list</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span>(LBRACK); elements(); <span style="color:#66d9ef">match</span>(RBRACK);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">elements</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span>(INT)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> lookahead <span style="color:#f92672">==</span> COMMA:  <span style="color:#75715e"># globale Variable, über consume()</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span>(COMMA); <span style="color:#66d9ef">match</span>(INT)</span></span></code></pre></div><h2 id="detail-match-und-consume">Detail: <em>match()</em> und <em>consume()</em></h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">match</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> lookahead <span style="color:#f92672">==</span> x: consume()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">Exception</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">consume</span>():
</span></span><span style="display:flex;"><span>    lookahead <span style="color:#f92672">=</span> lexer<span style="color:#f92672">.</span>nextToken()</span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, p. 43]</a></span></p>
<p>Dabei setzt man in der Klasse <code>Parser</code> zwei Attribute voraus:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Parser</span>:
</span></span><span style="display:flex;"><span>    Lexer lexer
</span></span><span style="display:flex;"><span>    Token lookahead</span></span></code></pre></div><p>Starten würde man den Parser nach dem Erzeugen einer Instanz (dabei wird ein Lexer mit
durchgereicht) über den Aufruf der Start-Regel, also beispielsweise <code>parser.list()</code>.</p>
<p><em>Anmerkung</em>: Mit dem generierten Parse-Tree bzw. <em>AST</em> beschäftigen wir uns später
(=&gt; <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/astdriven-part1.html">AST-basierte Interpreter</a>).</p>
<h2 id="vorrangregeln">Vorrangregeln</h2>
<pre><code>1+2*3 == 1+(2*3) != (1+2)*3
</code></pre>
<p>Die Eingabe <code>1+2*3</code> muss als <code>1+(2*3)</code> interpretiert werden, da <code>*</code> Vorrang vor <code>+</code> hat.</p>
<p>Dies formuliert man üblicherweise in der Grammatik:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : expr <span style="color:#e6db74">&#39;+&#39;</span> term
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> term
</span></span><span style="display:flex;"><span>     ;
</span></span><span style="display:flex;"><span>term : term <span style="color:#e6db74">&#39;*&#39;</span> <span style="color:#66d9ef">INT</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">INT</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p>ANTLR nutzt die Strategie des <a href="https://www.antlr.org/papers/Clarke-expr-parsing-1986.pdf" target="_blank">&quot;<em>precedence climbing</em>&quot;</a>
und löst nach der <em>Reihenfolge der Alternativen</em> in einer Regel auf. Entsprechend könnte man die obige Grammatik
unter Beibehaltung der Vorrangregeln so in ANTLR (v4) formulieren:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : expr <span style="color:#e6db74">&#39;*&#39;</span> expr
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;+&#39;</span> expr
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">INT</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><h2 id="linksrekursion">Linksrekursion</h2>
<p>Normalerweise sind linksrekursive Grammatiken nicht mit einem LL-Parser behandelbar. Man muss die Linksrekursion
manuell auflösen und die Grammatik umschreiben.</p>
<p><strong>Beispiel</strong>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : expr <span style="color:#e6db74">&#39;*&#39;</span> expr <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;+&#39;</span> expr <span style="color:#f92672">|</span> <span style="color:#66d9ef">INT</span> ;</span></span></code></pre></div><p>Diese linksrekursive Grammatik könnte man (unter Beachtung der Vorrangregeln) etwa so umformulieren:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr     : addExpr ;
</span></span><span style="display:flex;"><span>addExpr  : multExpr <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;+&#39;</span> multExpr<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>multExpr : <span style="color:#66d9ef">INT</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;*&#39;</span> <span style="color:#66d9ef">INT</span><span style="color:#f92672">)*</span> ;</span></span></code></pre></div><p>ANTLR (v4) kann Grammatiken mit <em>direkter</em> Linksrekursion auflösen. Für frühere Versionen von ANTLR muss man die
Rekursion manuell beseitigen.</p>
<p>Vergleiche <a href="https://www.antlr.org/papers/allstar-techreport.pdf" target="_blank">&quot;ALL(*)&quot; bzw. &quot;Adaptive LL(*)&quot;</a>.</p>
<p><strong>Achtung</strong>: Mit <em>indirekter</em> Linksrekursion kann ANTLR (v4) <em>nicht</em> umgehen:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : expM <span style="color:#f92672">|</span> <span style="color:#f92672">...</span> ;
</span></span><span style="display:flex;"><span>expM : expr <span style="color:#e6db74">&#39;*&#39;</span> expr ;</span></span></code></pre></div><p>=&gt; <em>Nicht</em> erlaubt!</p>
<h2 id="assoziativität">Assoziativität</h2>
<p>Die Eingabe <code>2^3^4</code> sollte als <code>2^(3^4)</code> geparst werden. Analog sollte <code>a=b=c</code> in C als <code>a=(b=c)</code> verstanden werden.</p>
<p>Per Default werden Operatoren wie <code>+</code> in ANTLR <em>links-assoziativ</em> behandelt, d.h. die Eingabe <code>1+2+3</code> wird
als <code>(1+2)+3</code> gelesen. Für <em>rechts-assoziative</em> Operatoren muss man ANTLR dies in der Grammatik mitteilen:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : expr <span style="color:#e6db74">&#39;^&#39;</span><span style="color:#960050;background-color:#1e0010">&lt;</span>assoc<span style="color:#f92672">=</span>right<span style="color:#960050;background-color:#1e0010">&gt;</span> expr
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">INT</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p><em>Anmerkung</em>: Laut <a href="https://github.com/antlr/antlr4/blob/master/doc/left-recursion.md" target="_blank">Doku</a> gilt die Angabe
<code>&lt;assoc=right&gt;</code> immer für die jeweilige Alternative und muss seit Version 4.2 an den Alternativen-Operator <code>|</code>
geschrieben werden. In der Übergangsphase sei die Annotation an Tokenreferenzen noch zulässig, würde aber
ignoriert?!</p>
<h2 id="llk-parser">LL(k)-Parser</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;++&#39;</span>    <span style="color:#75715e">// x++</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;--&#39;</span>    <span style="color:#75715e">// x--</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p>Die obige Regel ist für einen LL(1)-Parser nicht deterministisch behandelbar, da die Alternativen
mit dem selben Token beginnen (die Lookahead-Mengen überlappen sich). Entweder benötigt man zwei
Lookahead-Tokens, also einen LL(2)-Parser, oder man muss die Regel in eine äquivalente LL(1)-Grammatik
umschreiben:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : <span style="color:#66d9ef">ID</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;++&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;--&#39;</span><span style="color:#f92672">)</span> ;    <span style="color:#75715e">// x++ oder x--</span></span></span></code></pre></div><h2 id="llk-parser-implementierung-mit-ringpuffer">LL(k)-Parser: Implementierung mit Ringpuffer</h2>
<p>Für einen größeren Lookahead benötigt man einen Puffer für die Token. Für einen Lookahead von

<span class="math align-center">$k$</span> Token (also einen LL(k)-Parser) würde man einen Puffer mit 
<span class="math align-center">$k$</span> Plätzen anlegen und diesen
wie einen Ringpuffer benutzen. Dabei ist <code>start</code> der Index des aktuellen Lookahead-Tokens. Über
die neue Funktion <code>lookahead(1)</code> ist dieses aktuelle Lookahead-Token abrufbar.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Parser</span>:
</span></span><span style="display:flex;"><span>    Lexer lexer
</span></span><span style="display:flex;"><span>    k <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>               <span style="color:#75715e"># Lookahead: 3 Token =&gt; LL(3)</span>
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>           <span style="color:#75715e"># aktuelle Tokenposition im Ringpuffer</span>
</span></span><span style="display:flex;"><span>    Token[k] lookahead  <span style="color:#75715e"># Ringpuffer mit k Plätzen (vorbefüllt via Konstruktor)</span></span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">match</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> lookahead(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> x: consume()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">Exception</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">consume</span>():
</span></span><span style="display:flex;"><span>    lookahead[start] <span style="color:#f92672">=</span> lexer<span style="color:#f92672">.</span>nextToken()
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> (start<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> k
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lookahead</span>(i):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> lookahead[(start<span style="color:#f92672">+</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> k]  <span style="color:#75715e"># i==1: start</span></span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, p. 47]</a></span></p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>LL(1) und LL(k) mit festem Lookahead</li>
<li>Implementierung von Vorrang- und Assoziativitätsregeln</li>
<li>Beachtung und Auflösung von Linksrekursion</li>
</ul>


    



    



    

    
<div class="box notices cstyle note">
  <div class="box-label"><i class="fas fa-puzzle-piece"></i> Challenges</div>
  <div class="box-content">

<ul>
<li>Wie kann man aus einer LL(1)-Grammatik einen LL(1)-Parser mit rekursivem Abstieg implementieren? Wie &quot;übersetzt&quot; man dabei Token und Regeln?</li>
<li>Wie geht man mit Alternativen um? Wie mit optionalen Subregeln?</li>
<li>Warum ist Linksrekursion i.A. bei LL-Parsern nicht erlaubt? Wie kann man Linksrekursion beseitigen?</li>
<li>Wie kann man Vorrangregeln implementieren?</li>
<li>Wann braucht man mehr als ein Token Lookahead? Geben Sie ein Beispiel an.</li>
</ul>
</div>
</div>



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Abschnitte 2.4 und 4.4</em></li> <li id='id_Grune2012'>[Grune2012] <strong>Modern Compiler Design</strong><br>Grune, D. und van, Reeuwijk, K. und Bal, H. E. und Jacobs, C. J. H. und Langendoen, K., Springer, 2012. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-4614-4698-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-4614-4698-9</a>.<br><em>Abschnitte 3.1 bis (einschließlich) 3.4</em></li> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 2 (insbesondere Abschnitte 2.3 bis (einschließlich) 2.19)</em></li> <li id='id_Parr2010'>[Parr2010] <strong>Language Implementation Patterns</strong><br>Parr, T., Pragmatic Bookshelf, 2010. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5645-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5645-6</a>.<br><em>Kapitel 2</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>LL-Parser: Fortgeschrittene Techniken</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p><a href="#R-image-fe0b6cbbf79deae0be869c70351cc1e3" class="lightbox-link"><img src="images/architektur_cb_parser.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fe0b6cbbf79deae0be869c70351cc1e3"><img src="images/architektur_cb_parser.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Man kann einen LL(k)-Parser bei Bedarf um ein &quot;spekulatives Matching&quot; ergänzen. Dies ist in Situationen
relevant, wo man das 
<span class="math align-center">$k$</span> nicht vorhersehen kann, etwa bei der Unterscheidung einer Vorwärtsdeklaration
und einer Funktionsdefinition in C. Hier kann man erst nach dem Parsen des Funktionsnamens entscheiden,
welche Situation vorliegt; der Funktionsname kann dabei (nahezu) beliebig lang sein.</p>
<p>Beim spekulativen Matching muss man sich merken, an welcher Position im Tokenstrom man die Spekulation
gestartet hat, um im Fall des Nichterfolgs dorthin wieder zurückspringen zu können (&quot;Backtracking&quot;).</p>
<p>Das Backtracking kann sehr langsam werden durch das Ausprobieren mehrerer Alternativen und das jeweils
nötige Zurückrollen. Zudem kann es passieren, dass eine bestimmte Sequenz immer wieder erkannt werden
muss. Hier hilft eine weitere Technik: <strong>Packrat Parsing</strong> <a href="#id_Packrat2006">[Packrat2006]</a> (nutzt
<a href="https://en.wikipedia.org/wiki/Memoization" target="_blank">&quot;<em>memoisation</em>&quot;</a>). Hierbei führt man pro Regel eine Map mit,
in der zu einer Position im Tokenstrom festgehalten wird, ob diese Regel an/ab dieser Position bereits
erfolgreich oder nicht erfolgreich war. Dies kann man dann nutzen, um bei einem erneuten Parsen der
selben Regel &quot;vorzuspulen&quot;.</p>
<p>In ANTLR kann man <em>semantische Prädikate</em> benutzen, um Alternativen &quot;abzuschalten&quot;. Dies ist beispielsweise
nützlich, wenn man nur eine Grammatik für unterschiedliche Versionen einer Sprache implementieren will.</p>
<p>Eine gute Darstellung finden Sie in <a href="#id_Parr2010">[Parr2010]</a> (Kapitel 3) und in [Packrat2006].</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/12GT2WxZsxY' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL LL-Parser: Fortgeschrittene Techniken</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/c3dc479884ce6b50bbd0fe85a8dd49f7b250576ac73742b879c564d6cba4b83c79fa499f9164b947e81e597add85e6addfd91a41a4eb85438c51218846aac0cb' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL LL-Parser: Fortgeschrittene Techniken</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K3) Implementierung von LL(1)- und LL(k)-Parsern</li> <li>(K3) Dynamischer Lookahead mittels Backtracking; Verbesserung der Laufzeiteigenschaften mit Packrat</li> <li>(K3) Einsatz von semantischen Prädikaten zum (De-) Aktivieren von Regeln oder Token</li></ul></div>
</div>




    <h2 id="ll-parser-mit-backtracking">LL-Parser mit Backtracking</h2>
<p>Problem: Manchmal kennt man den nötigen Lookahead nicht vorher. Beispiel:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>wuppie();         <span style="color:#75715e">// Vorwärtsdeklaration
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>wuppie() { ...}   <span style="color:#75715e">// Definition
</span></span></span></code></pre></div><p>Entsprechend sähe die Grammatik aus:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>func : fdef <span style="color:#f92672">|</span> fdecl ;
</span></span><span style="display:flex;"><span>fdef : head <span style="color:#e6db74">&#39;{&#39;</span> body <span style="color:#e6db74">&#39;}&#39;</span> ;
</span></span><span style="display:flex;"><span>fdecl: head <span style="color:#e6db74">&#39;;&#39;</span> ;
</span></span><span style="display:flex;"><span>head : <span style="color:#f92672">...</span> ;</span></span></code></pre></div><p>Hier müsste man erst den gesamten Funktionskopf parsen, bevor man entscheiden kann, ob es sich um
eine Deklaration oder eine Definition handelt. Unglücklicherweise gibt es keine Längenbeschränkung
bei den Funktionsnamen ...</p>
<p>Mit Hilfe von Backtracking kann man zunächst spekulativ matchen und beim Auftreten eines Fehlers
die Spekulation rückgängig machen:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">func</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> speculate(fdef): fdef()      <span style="color:#75715e"># Spekuliere auf &#34;fdef&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> speculate(fdecl): fdecl()  <span style="color:#75715e"># Spekuliere auf &#34;fdecl&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">Exception</span>()</span></span></code></pre></div><p>Die erste Alternative, die passt, gewinnt. Über die Reihenfolge der Spekulationen kann man
entsprechend Vorrangregeln implementieren.</p>
<h3 id="anmerkung">Anmerkung</h3>
<p>Man könnte die obige Grammatik umformen ...</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>func : head <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;{&#39;</span> body <span style="color:#e6db74">&#39;}&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;;&#39;</span><span style="color:#f92672">)</span> ;
</span></span><span style="display:flex;"><span>head : <span style="color:#f92672">...</span> ;</span></span></code></pre></div><p>...und bräuchte dann kein spekulatives Parsen mit Backtracking.</p>
<p>Da wir aber das Parsen mit Backtracking betrachten wollen, blenden wir diese Möglichkeit
jetzt einfach aus ;)</p>
<h2 id="details-spekulatives-matchen">Details: Spekulatives Matchen</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">speculate</span>(fn):
</span></span><span style="display:flex;"><span>    success <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    mark()                  <span style="color:#75715e"># markiere aktuelle Position</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>:   fn()             <span style="color:#75715e"># probiere Regel fn()</span>
</span></span><span style="display:flex;"><span>    catch: success <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    clear()                 <span style="color:#75715e"># Rollback</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> success</span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, p. 60]</a></span></p>
<p>Der Funktion <code>speculate</code> wird die zu testende Regel (Funktion) als Parameter übergeben, im obigen
Beispiel wären dies <code>fdef</code> bzw. <code>fdecl</code>.</p>
<p>Vor dem spekulativen Matchen muss die aktuelle Position im Tokenstrom markiert werden. Falls der
Versuch, die Deklaration zu matchen nicht funktioniert, wird der Regel-Aufruf eine Exception werfen,
entsprechend wird die Hilfsvariable gesetzt. Anschließend muss noch mit <code>clear()</code> das aktuelle
Token wieder hergestellt werden (wir sind ja nur im Spekulationsmodus, d.h. selbst im Erfolgsfall
wird ja die Regel noch &quot;richtig&quot; aufgerufen).</p>
<h2 id="spekulatives-matchen-hilfsmethoden-iii">Spekulatives Matchen: Hilfsmethoden I/II</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Parser</span>:
</span></span><span style="display:flex;"><span>    Lexer lexer
</span></span><span style="display:flex;"><span>    markers <span style="color:#f92672">=</span> []    <span style="color:#75715e"># Integer-Stack: speichere Tokenpositionen</span>
</span></span><span style="display:flex;"><span>    lookahead <span style="color:#f92672">=</span> []  <span style="color:#75715e"># Puffer (1 Token vorbefüllt via Konstruktor)</span>
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>       <span style="color:#75715e"># aktuelle Tokenposition im lookahead-Puffer</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">mark</span>():
</span></span><span style="display:flex;"><span>        markers<span style="color:#f92672">.</span>push(start)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">clear</span>():
</span></span><span style="display:flex;"><span>        start <span style="color:#f92672">=</span> markers<span style="color:#f92672">.</span>pop()</span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, pp. 61/62]</a></span></p>
<h2 id="spekulatives-matchen-hilfsmethoden-iiii">Spekulatives Matchen: Hilfsmethoden II/II</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">consume</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">++</span>start
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> start <span style="color:#f92672">==</span> lookahead<span style="color:#f92672">.</span>count() <span style="color:#f92672">and</span> markers<span style="color:#f92672">.</span>isEmpty():
</span></span><span style="display:flex;"><span>        start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; lookahead<span style="color:#f92672">.</span>clear()
</span></span><span style="display:flex;"><span>    sync(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lookahead</span>(i):
</span></span><span style="display:flex;"><span>    sync(i)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> lookahead<span style="color:#f92672">.</span>get(start<span style="color:#f92672">+</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sync</span>(i):
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> start <span style="color:#f92672">+</span> i <span style="color:#f92672">-</span> lookahead<span style="color:#f92672">.</span>count()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>        lookahead<span style="color:#f92672">.</span>add(lexer<span style="color:#f92672">.</span>nextToken()); <span style="color:#f92672">--</span>n</span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, pp. 61/62]</a></span></p>
<p><code>consume</code> holt wie immer das nächste Token, hier indem der Index <code>start</code> weiter gesetzt
wird und ein weiteres Token über <code>sync</code> in den Puffer geladen wird. Falls wir nicht am
Spekulieren sind und das Ende des Puffers erreicht haben, nutzen wir die Gelegenheit und
setzen den Puffer zurück. (Dies geht nicht, wenn wir spekulieren -- hier müssen wir ja
ggf. ein Rollback vornehmen und benötigen also den aktuellen Puffer dann noch.)</p>
<p>Die Funktion <code>sync</code> stellt sicher, dass ab der Position <code>start</code> noch <code>i</code> unverbrauchte
Token im Puffer sind.</p>
<h3 id="hinweis">Hinweis</h3>
<p>Die Methode <code>count</code> liefert die Anzahl der aktuell gespeicherten Elemente in <code>lookahead</code>
zurück (nicht die Gesamtzahl der Plätze in der Liste -- diese kann größer sein). Mit der
Methode <code>add</code> wird ein Element hinten an die Liste angefügt, dabei wird das Token auf den
nächsten Index-Platz (<code>count</code>) geschrieben und ggf. die Liste ggf. automatisch um weitere
Speicherplätze ergänzt. Über <code>clear</code> werden die Elemente in der Liste gelöscht, aber der
Speicherplatz erhalten (d.h. <code>count()</code> liefert den Wert 0, aber ein <code>add</code> müsste nicht erst
die Liste mit weiteren Plätzen erweitern, sondern könnte direkt an Index 0 das Token schreiben).</p>
<h3 id="backtracking-führt-zu-problemen">Backtracking führt zu Problemen</h3>
<ol>
<li>Backtracking kann <em>sehr</em> langsam sein (Ausprobieren vieler Alternativen)</li>
<li>Der spekulative Match muss ggf. rückgängig gemacht werden</li>
<li>Man muss bereits gematchte Strukturen erneut matchen (=&gt; Abhilfe: Packrat-Parsing)</li>
</ol>
<h2 id="verbesserung-backtracking-packrat-parser-memoizing">Verbesserung Backtracking: Packrat Parser (Memoizing)</h2>
<p><a href="#R-image-af4c00c1db659d4009b74342db18c290" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced/packrat.png?width=60%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 60%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-af4c00c1db659d4009b74342db18c290"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced/packrat.png?width=60%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Bei der Eingabe <code>wuppie();</code> wird zunächst spekulativ die erste Alternative <code>fdef</code> untersucht
und ein <code>head</code> gematcht. Da die Alternative nicht komplett passt (es kommt ein &quot;;&quot; statt
einem &quot;{&quot;), muss die Spekulation rückgängig gemacht werden und die zweite Alternative
<code>fdecl</code> untersucht werden. Dabei muss man den selben Input erneut auf <code>head</code> matchen!
(Und wenn die Spekulation (irgendwann) erfolgreich war, muss noch einmal ein <code>head</code> gematcht
werden ...)</p>
<p>Idee: Wenn <code>head</code> sich merken würde, ob damit ein bestimmter Teil des Tokenstroms bereits
behandelt wurde (erfolgreich oder nicht), könnte man das Spekulieren effizienter gestalten.
Jede Regel muss also durch eine passende Regel mit Speicherung ergänzt werden.</p>
<p>Dies wird auch als <a href="https://en.wikipedia.org/wiki/Memoization" target="_blank">&quot;Memoization&quot;</a> bezeichnet
und ist eine zentrales Technik des Packrat Parsers (vgl. <a href="#id_Packrat2006">[Packrat2006]</a>).</p>
<h2 id="skizze-idee-des-packrat-parsing">Skizze: Idee des Packrat-Parsing</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>head_memo <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">head</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> head_memo<span style="color:#f92672">.</span>get(start) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">Exception</span>()                         <span style="color:#75715e"># kein Match</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> head_memo<span style="color:#f92672">.</span>get(start) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        start <span style="color:#f92672">=</span> head_memo[start]; <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>     <span style="color:#75715e"># Vorspulen</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>; start_ <span style="color:#f92672">=</span> start
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span>: <span style="color:#f92672">...</span>     <span style="color:#75715e"># rufe die ursprüngliche head()-Regel auf</span>
</span></span><span style="display:flex;"><span>        catch(e): failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>; <span style="color:#66d9ef">raise</span> e
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">finally</span>: head_memo[start_] <span style="color:#f92672">=</span> (failed <span style="color:#960050;background-color:#1e0010">?</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> : start)</span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, pp. 65/66]</a></span></p>
<ul>
<li>Wenn bereits untersucht (Eintrag vorhanden): Vorspulen bzw. Exception werfen</li>
<li>Sonst (aktuelle Position noch nicht in der Tabelle =&gt; Regel noch nicht an
dieser Position getestet):
<ul>
<li>Original-Regel ausführen</li>
<li>Exception: Regel hatte keinen Erfolg =&gt; merken und Exception weiter reichen</li>
</ul>
</li>
<li>Ergebnis für diese Startposition und diese Regel merken:
<ul>
<li>Falls Regel erfolgreich, dann Start-Position und die aktuelle Position
(Stopp-Position) in der Tabelle für diese Regel notieren</li>
<li>Falls Regel nicht erfolgreich, zur Start-Position eine ungültige Position setzen</li>
</ul>
</li>
</ul>
<h3 id="anmerkung-consume">Anmerkung <em>consume()</em></h3>
<p>Die Funktion <code>consume()</code> muss passend ergänzt werden: Wann immer man den <code>lookahead</code>-Puffer
zurücksetzt, werden alle <code>*_memo</code> ungültig und müssen ebenfalls zurückgesetzt werden!</p>
<h2 id="semantische-prädikate">Semantische Prädikate</h2>
<p>Problem in Java: <code>enum</code> ab Java5 Schlüsselwort (vorher als Identifier-Name verwendbar)</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>prog : <span style="color:#f92672">(</span>enumDecl <span style="color:#f92672">|</span> stat<span style="color:#f92672">)+</span> ;
</span></span><span style="display:flex;"><span>stat : <span style="color:#f92672">...</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>enumDecl : <span style="color:#66d9ef">ENUM</span> id <span style="color:#e6db74">&#39;{&#39;</span> id <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;,&#39;</span> id<span style="color:#f92672">)*</span> <span style="color:#e6db74">&#39;}&#39;</span> ;</span></span></code></pre></div><p>Wie kann ich eine Grammatik bauen, die sowohl für Java5 und später als auch für die Vorgänger
von Java5 funktioniert?</p>
<p>Angenommen, man hätte eine Hilfsfunktion (&quot;Prädikat&quot;), mit denen man aus dem Kontext heraus
die Unterscheidung treffen kann, dann würde die Umsetzung der Regel ungefähr so aussehen:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">prog</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> lookahead(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> ENUM <span style="color:#f92672">and</span> java5: enumDecl()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: stat()</span></span></code></pre></div><h2 id="semantische-prädikate-in-antlr">Semantische Prädikate in ANTLR</h2>
<h3 id="semantische-prädikate-in-parser-regeln">Semantische Prädikate in Parser-Regeln</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>@parser::members {public static boolean java5;}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>prog : <span style="color:#f92672">(</span>{java5}<span style="color:#f92672">?</span> enumDecl <span style="color:#f92672">|</span> stat<span style="color:#f92672">)+</span> ;
</span></span><span style="display:flex;"><span>stat : <span style="color:#f92672">...</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>enumDecl : <span style="color:#66d9ef">ENUM</span> id <span style="color:#e6db74">&#39;{&#39;</span> id <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;,&#39;</span> id<span style="color:#f92672">)*</span> <span style="color:#e6db74">&#39;}&#39;</span> ;</span></span></code></pre></div><p>Prädikate in Parser-Regeln aktivieren bzw. deaktivieren alles, was nach der Abfrage
des Prädikats gematcht werden könnte.</p>
<h3 id="semantische-prädikate-in-lexer-regeln">Semantische Prädikate in Lexer-Regeln</h3>
<p>Alternativ für Lexer-Regeln:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>ENUM : <span style="color:#e6db74">&#39;enum&#39;</span> {java5}<span style="color:#f92672">?</span> ;
</span></span><span style="display:flex;"><span>ID   : [a-zA-Z]<span style="color:#f92672">+</span> ;</span></span></code></pre></div><p>Bei Token kommt das Prädikat erst am rechten Ende einer Lexer-Regel vor, da der Lexer keine
Vorhersage macht, sondern nach dem längsten Match sucht und die Entscheidung erst trifft,
wenn das ganze Token gesehen wurde. Bei Parser-Regeln steht das Prädikat links vor der
entsprechenden Alternative, da der Parser mit Hilfe des Lookaheads Vorhersagen trifft, welche
Regel/Alternative zutrifft.</p>
<p><em>Anmerkung</em>: Hier wurden nur Variablen eingesetzt, es können aber auch Methoden/Funktionen
genutzt werden. In Verbindung mit einer Symboltabelle (<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html/cb_symboltabellen1.html">&quot;Symboltabellen&quot;</a>)
und/oder mit Attributen und Aktionen in der Grammatik (<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html/cb_attribute.html">&quot;Attribute&quot;</a> und
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html/cb_interpreter2.html">&quot;Interpreter: Attribute+Aktionen&quot;</a>) hat man hier ein mächtiges Hilfswerkzeug!</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>LL(1) und LL(k): Erweiterungen
<ul>
<li>Dynamischer Lookahead: BT-Parser mit Packrat-Ergänzung</li>
<li>Semantische Prädikate zum Abschalten von Alternativen</li>
</ul>
</li>
</ul>


    



    



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Abschnitte 2.4 und 4.4</em></li> <li id='id_Grune2012'>[Grune2012] <strong>Modern Compiler Design</strong><br>Grune, D. und van, Reeuwijk, K. und Bal, H. E. und Jacobs, C. J. H. und Langendoen, K., Springer, 2012. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-4614-4698-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-4614-4698-9</a>.<br><em>Abschnitte 3.1 bis (einschließlich) 3.4</em></li> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 2 (insbesondere Abschnitte 2.3 bis (einschließlich) 2.19)</em></li> <li id='id_Packrat2006'>[Packrat2006] <a href='http://arxiv.org/abs/cs/0603077' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>Packrat Parsing: Simple, Powerful, Lazy, Linear Time</strong></a><br>Ford, B., 2006.</li> <li id='id_Parr2010'>[Parr2010] <strong>Language Implementation Patterns</strong><br>Parr, T., Pragmatic Bookshelf, 2010. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5645-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5645-6</a>.<br><em>Kapitel 3</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Parser mit ANTLR generieren</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>Mit ANTLR kann aus einer Grammatik ein LL(*)-Parser generiert werden. Die Parser-Regeln
in der Grammatik fangen dabei mit einem <strong>Kleinbuchstaben</strong> an (Erinnerung: Lexer-Regel
starten mit einem Großbuchstaben).</p>
<p>Regeln haben einen Namen (linke Seite) und eine Produktion (rechte Seite). Dabei
können beliebige Abfolgen von Lexer- und Parser-Regeln auf der rechten Seite
einer Parser-Regel auftauchen. Die Token müssen jeweils matchen, die Parser-Regeln
werden in einen Aufruf der jeweiligen generierten Funktion übersetzt.</p>
<p>Parser-Regeln können aus mehreren Alternativen bestehen, diese werden per <code>|</code> separiert.
Dabei hat bei Mehrdeutigkeiten die erste passende Alternative Vorrang. Wie bei Lexer-Regeln
können Teile per <code>?</code> ein- oder keinmal vorkommen, per <code>*</code> beliebig oft oder per <code>+</code> ein-
oder mehrfach.</p>
<p>ANTLR erlaubt im Gegensatz zu allgemeinen LL-Parsern direkte Links-Rekursion. (Indirekte
Links-Rekursion funktioniert allerdings nicht.)</p>
<p>Der von ANTLR generierte Parser erzeugt auf der Eingabe einen Parse-Tree, der die Strukturen
der Grammatik widerspiegelt: Die Token bilden die Blätter und jede erfolgreich durchlaufene
Parser-Regel bildet einen entsprechenden Knoten im Baum.</p>
<p>Für die Traversierung des Parse-Tree kann man die generierten Listener- oder Visitor-Klassen
nutzen. Beim Einsatz der Listener nutzt man die vorgegebene Klasse <code>ParseTreeWalker</code>, die
mit dem Parse-Tree und dem Listener den Baum per Tiefensuche traversiert und immer die
jeweiligen <code>enterRegel</code>- und <code>exitRegel</code>-Methoden aufruft. Beim Visitor muss die Traversierung
selbst erledigt werden, hier steht die aus der Klassenhierarchie geerbte Methode <code>visit</code>
als Startpunkt zur Verfügung. In dieser Methode wird basierend auf dem Knotentyp die in den
Visitor-Klassen implementierte <code>visitRegel</code>-Methode aufgerufen und man muss darauf achten,
die Kindknoten durch passende Aufrufe zu traversieren. Sowohl bei den generierten Listener-
als auch den Visitor-Klassen kann man die leeren Defaultmethoden bei Bedarf selbst überschreiben.
Für den Zugriff auf die Regel-Elemente werden die sogenannten Kontextobjekte als Parameter
übergeben.</p>
<p>Benannte Alternativen und Regel-Elemente sind nützlich, weil für die benannten Alternativen
zusätzliche Kontextklassen erzeugt werden, über die dann auf die Bestandteile der Alternativen
zugegriffen werden kann. Außerdem werden zusätzlich passende <code>enterAlternative</code>- und <code>exitAlternative</code>-
bzw. <code>visitAlternative</code>-Methoden generiert. Für benannte Regel-Elemente wird ein entsprechend
benanntes Attribut im Kontextobjekt angelegt, welches <code>public</code> sichtbar ist.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/YuUHBvPUS4k' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Parser mit ANTLR</a></li> <li><a href='https://youtu.be/FJOEPY-TMmw' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Demo ANTLR Parser</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/19925b756d6fc934bfe0b5107eb5fa58373a53af49c690ebce86e15f2b212c89c80ea7665e42c78abdc8dfe0718ea46f6a9817eeba4ad1293bdb4c84f7c8f084' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Parser mit ANTLR</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K2) Aufbau der Parser-Regeln</li> <li>(K3) Alternativen und optionale/mehrfache Regelteile in Parser-Regeln</li> <li>(K3) Vorrang von Alternativen (bei Mehrdeutigkeiten)</li> <li>(K3) Benannte Alternativen und Regel-Elemente</li> <li>(K2) Aufbau des Parse-Tree</li> <li>(K3) Umgang mit Kontext-Objekten</li> <li>(K3) Traversierung des Parse-Tree mit den generierten Listenern oder Visitors</li></ul></div>
</div>




    <h2 id="hello-world">Hello World</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span><span style="color:#66d9ef">grammar</span> <span style="color:#a6e22e">Hello</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>start : stmt<span style="color:#f92672">*</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>stmt  : <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> expr <span style="color:#e6db74">&#39;;&#39;</span> <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;;&#39;</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>expr  : term <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;+&#39;</span> term<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>term  : atom <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;*&#39;</span> atom<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>atom  : <span style="color:#66d9ef">ID</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">NUM</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ID    : [a-z][a-zA-Z]<span style="color:#f92672">*</span> ;
</span></span><span style="display:flex;"><span>NUM   : [0-9]<span style="color:#f92672">+</span> ;
</span></span><span style="display:flex;"><span>WS    : [ \t\n]<span style="color:#f92672">+</span> <span style="color:#f92672">-&gt;</span> skip ;</span></span></code></pre></div><div style="text-align: right;">
<span class="btn cstyle default">
  <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/lecture/frontend/parsing/src/Hello.g4" target="_blank">
    Konsole: Hello (grun, Parse-Tree)
  </a>
</span></div>
<h3 id="starten-des-parsers">Starten des Parsers</h3>
<ol>
<li>Grammatik übersetzen und Code generieren: <code>antlr Hello.g4</code></li>
<li>Java-Code kompilieren: <code>javac *.java</code></li>
<li>Parser ausführen:
<ul>
<li>
<p><code>grun Hello start -tree</code> oder <code>grun Hello start -gui</code> (Grammatik &quot;Hello&quot;, Startregel &quot;start&quot;)</p>
</li>
<li>
<p>Alternativ mit kleinem Java-Programm:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> org.antlr.v4.runtime.CharStreams<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.antlr.v4.runtime.CommonTokenStream<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.antlr.v4.runtime.tree.ParseTree<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        HelloLexer lexer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HelloLexer<span style="color:#f92672">(</span>CharStreams<span style="color:#f92672">.</span><span style="color:#a6e22e">fromStream</span><span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        CommonTokenStream tokens <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CommonTokenStream<span style="color:#f92672">(</span>lexer<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        HelloParser parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HelloParser<span style="color:#f92672">(</span>tokens<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ParseTree tree <span style="color:#f92672">=</span> parser<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>  <span style="color:#75715e">// Start-Regel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>tree<span style="color:#f92672">.</span><span style="color:#a6e22e">toStringTree</span><span style="color:#f92672">(</span>parser<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div></li>
</ul>
</li>
</ol>
<h3 id="startregeln">Startregeln</h3>
<ul>
<li><code>start</code> ist eine <span class='alert'>Parser-Regel</span>
=&gt; Eine Parser-Regel pro Grammatik wird benötigt, damit man den generierten
Parser am Ende auch starten kann ...</li>
<li>Alle Regeln mit kleinem Anfangsbuchstaben sind Parser-Regeln</li>
<li>Alle Regeln mit großem Anfangsbuchstaben sind Lexer-Regeln</li>
</ul>
<h3 id="formen-der-subregeln">Formen der Subregeln</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt  : <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> expr <span style="color:#e6db74">&#39;;&#39;</span> ;</span></span></code></pre></div><p>Um die Regel <code>stmt</code> anwenden zu können, müssen alle Elemente auf der rechten
Seite der Regel erfüllt werden. Dabei müssen die Token wie <code>ID</code>, <code>=</code> und <code>;</code>
matchen und die Subregel <code>expr</code> muss erfüllt werden können. Beachten Sie das
abschließende Semikolon am Ende einer ANTLR-Regel!</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt  : <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> expr <span style="color:#e6db74">&#39;;&#39;</span> <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;;&#39;</span> ;</span></span></code></pre></div><p>Alternativen werden durch ein <code>|</code> getrennt. Hier muss genau eine Alternative
erfüllt werden. Falls nötig, trennt man die Alternativen durch Einschließung
in runden Klammern vom Rest der Regel ab: <code>r : a (b | c) d ;</code>.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr  : term <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;+&#39;</span> term<span style="color:#f92672">)*</span> ;</span></span></code></pre></div><p>Der durch den <code>*</code> gekennzeichnete Teil kann beliebig oft vorkommen oder auch
fehlen. Bei einem <code>+</code> müsste der Teil mind. einmal vorkommen und bei einem
<code>?</code> entsprechend einmal oder keinmal.</p>
<p>Auch hier kann man die Operatoren durch ein zusätzliches <code>?</code> auf non-greedy
umschalten (analog zu den Lexer-Regeln).</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/parser-rules.md#subrules" target="_blank">github.com/antlr/antlr4/blob/master/doc/parser-rules.md</a>)</p>
<h3 id="reihenfolge-in-grammatik-definiert-priorität">Reihenfolge in Grammatik definiert Priorität</h3>
<p>Falls mehr als eine Parser-Regel die selbe Input-Sequenz matcht, löst ANTLR
diese Mehrdeutigkeit auf, indem es die erste Alternative nimmt, die an der
Entscheidung beteiligt ist.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>start : stmt ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>stmt  : expr <span style="color:#f92672">|</span> <span style="color:#66d9ef">ID</span>  ;
</span></span><span style="display:flex;"><span>expr  : <span style="color:#66d9ef">ID</span>   <span style="color:#f92672">|</span> <span style="color:#66d9ef">NUM</span> ;</span></span></code></pre></div><p>Bei der Eingabe &quot;foo&quot; würde die Alternative <code>ID</code> in der Regel <code>expr</code> &quot;gewinnen&quot;,
weil sie in der Grammatik vor der Alternative <code>ID</code> in der Regel <code>stmt</code> kommt und
damit Vorrang hat.</p>
<h3 id="parse-tree">Parse-Tree</h3>
<p>Betrachten wir erneut die obige Grammatik.</p>
<p>Die Eingabe von &quot;<code>a = 42;</code>&quot; führt zu folgendem Parse-Tree:</p>
<p><a href="#R-image-17460c670750a3d9f3dbfa72b9dc5905" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/hello_ex1.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-17460c670750a3d9f3dbfa72b9dc5905"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/hello_ex1.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Diese Eingabe führt zur Erkennung der Token <code>[ID, WS, =, WS, NUM, ;]</code>, wobei die
<code>WS</code>-Token verworfen werden und der Parser den Tokenstream <code>[ID, =, NUM, ;]</code>
erhält.</p>
<p>Die Startregel hat auf der rechten Seite kein oder mehrere <code>stmt</code>-Regeln. Die
<code>stmt</code>-Regel fordert auf der rechten Seite entweder die Token <code>ID</code>und <code>=</code> sowie
die Regel <code>expr</code> gefolgt vom Token <code>;</code>, oder die Regel <code>expr</code> gefolgt vom Token
<code>;</code>. In unserem Beispiel kann für das &quot;a&quot; das Token <code>ID</code> produziert werden, das
&quot;=&quot; matcht ebenfalls. Die &quot;42&quot; wird erklärt, indem für <code>expr</code> ein <code>term</code> und
dort ein <code>atom</code> aufgerufen wird. Für das <code>atom</code> muss entweder ein Token <code>ID</code>
oder <code>NUM</code> als nächstes Token kommen - hier wird die &quot;42&quot; wird als Token <code>NUM</code>
verarbeitet. Da die weiteren Regelteile in <code>term</code> und <code>expr</code> optional sind,
haben wir damit ein <code>expr</code> erfüllt und das nachfolgende <code>;</code>-Token schließt die
erste Alternative der Regel <code>stmt</code> erfolgreich ab.</p>
<p>Im entstehenden Parse-Tree sind diese Abläufe und grammatikalischen Strukturen
direkt erkennbar. Jede erfolgreich durchlaufene Parserregel wird zu einem
Knoten im Parse-Tree. Die Token werden als Terminale (Blätter) in den Baum
eingehängt.</p>
<p><em>Anmerkung</em>: Der Parse-Tree ist das Ergebnis der Parsers-Phase im Compiler und
dient damit als Input für die folgenden Compilerstufen. In der Regel benötigt
man die oft recht komplexen Strukturen aber später nicht mehr und vereinfacht
den Baum zu einem <em>Abstract Syntax Tree</em> (AST). Im Beispiel könnte man den Zweig
<code>stmt - expr - term - atom - 42</code> zu <code>stmt - 42</code> vereinfachen.</p>
<p>Betrachten wir nun die Eingabe <code>foo = 2+3*4; bar = 3*4+2;</code>. Diese führt zu
folgendem Parse-Tree:</p>
<p><a href="#R-image-5f78916b80c3433210ac1f091312c713" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/hello_ex2.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5f78916b80c3433210ac1f091312c713"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/hello_ex2.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Wie man sehen kann, sind in der Grammatik die üblichen Vorrangregeln für die
Operationen <code>+</code> und <code>*</code> berücksichtigt - die Multiplikation wird in beiden
Fällen korrekt &quot;unter&quot; der Addition im Baum eingehängt.</p>
<h3 id="to-eof-not-to-eof">To EOF not to EOF?</h3>
<p>Startregeln müssen nicht unbedingt den gesamten Input &quot;konsumieren&quot;. Sie müssen
per Default nur eine der Alternativen in der Startregel erfüllen.</p>
<p>Betrachten wir noch einmal einen leicht modifizierten Ausschnitt aus der obigen
Grammatik:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>start : stmt ;</span></span></code></pre></div><p>Die Startregel wurde so geändert, dass sie nur noch genau ein Statement
akzeptieren soll.</p>
<p>In diesem Fall würde die Startregel bei der Eingabe &quot;aa; bb;&quot; nur den ersten
Teil &quot;aa;&quot; konsumieren (als Token <code>ID</code>) und das folgende &quot;bb;&quot; ignorieren.
Das wäre in diesem Fall aber auch kein Fehler.</p>
<p>Wenn der gesamte Eingabestrom durch die Startregel erklärt werden soll,
dann muss das vordefinierte Token <code>EOF</code> am Ende der Startregel eingesetzt
werden:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>start : stmt <span style="color:#66d9ef">EOF</span>;</span></span></code></pre></div><p>Hier würde die Eingabe &quot;aa; bb;&quot; zu einem Fehler führen, da nur der Teil &quot;aa;&quot;
durch die Startregel abgedeckt ist (Token <code>ID</code>), und der Rest &quot;bb;&quot; zwar sogar
ein gültiges Token wären (ebenfalls <code>ID</code> und <code>;</code>), aber eben nicht mehr von der
Startregel akzeptiert. Durch das <code>EOF</code> soll die Startregel aber den gesamten
Input konsumieren und erklären, was hier nicht geht und entsprechend zum Fehler
führt.</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/parser-rules.md#start-rules-and-eof" target="_blank">github.com/antlr/antlr4/blob/master/doc/parser-rules.md</a>)</p>
<h2 id="expressions-und-vorrang-operatoren">Expressions und Vorrang (Operatoren)</h2>
<p>Betrachten wir noch einmal den Ausschnitt für die Ausdrücke (<em>Expressions</em>) in
der obigen Beispielgrammatik:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr  : term <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;+&#39;</span> term<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>term  : atom <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;*&#39;</span> atom<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>atom  : <span style="color:#66d9ef">ID</span> ;</span></span></code></pre></div><p>Diese typische, etwas komplex anmutende Struktur soll sicher stellen, dass die
Vorrangregeln für Addition und Multiplikation korrekt beachtet werden, d.h. dass
<code>2+3*4</code> als <code>2+(3*4)</code> geparst wird und nicht fälschlicherweise als <code>(2+3)*4</code>
erkannt wird.</p>
<p>Zusätzlich muss bei LL-Parsern Links-Rekursion vermieden werden: Die Parser-Regeln
werden in Funktionsaufrufe übersetzt, d.h. bei einer Links-Rekursion würde man die
selbe Regel immer wieder aufrufen, ohne ein Token aus dem Token-Strom zu entnehmen.</p>
<p>ANTLR (ab Version 4) kann mit beiden Aspekten automatisch umgehen:</p>
<ul>
<li>ANTLR kann direkte Linksrekursion automatisch auflösen. Die Regel <code>r : r T U | V ;</code>
kann also in ANTLR verarbeitet werden.</li>
<li>ANTLR besitzt einen Mechanismus zur Auflösung von Mehrdeutigkeiten. Wie oben
geschrieben, wird bei der Anwendbarkeit von mehreren Alternativen die erste
Alternative genutzt.</li>
</ul>
<p>Damit lässt sich die typische Struktur für Expression-Grammatiken deutlich lesbarer
gestalten:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr  : expr <span style="color:#e6db74">&#39;*&#39;</span> expr
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;+&#39;</span> expr
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#66d9ef">ID</span>
</span></span><span style="display:flex;"><span>      ;</span></span></code></pre></div><p>Die Regel <code>expr</code> ist links-rekursiv, was normalerweise bei LL-Parsern problematisch
ist. ANTLR löst diese Links-Rekursion automatisch auf (vgl.
<a href="https://github.com/antlr/antlr4/blob/master/doc/left-recursion.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/left-recursion.md</a>).</p>
<p>Da bei Mehrdeutigkeit in der Grammatik, also bei der Anwendbarkeit mehrerer Alternativen
stets die erste Alternative genommen wird, lassen sich die Vorrangregeln durch die
Reihenfolge der Alternativen in der <code>expr</code>-Regel implementieren: Die Multiplikation
hat Vorrang von der Addition, und diese hat wiederum Vorrang von einer einfachen <code>ID</code>.</p>
<h3 id="direkte-vs-indirekte-links-rekursion">Direkte vs. indirekte Links-Rekursion</h3>
<p>ANTLR kann nur <em>direkte</em> Links-Rekursion auflösen. Regeln wie <code>r : r T U | V ;</code> stellen
in ANTLR also kein Problem dar.</p>
<p><em>Indirekte</em> Links-Rekursion erkennt ANTLR dagegen nicht:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>r : s <span style="color:#66d9ef">T</span> <span style="color:#66d9ef">U</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">V</span> ;
</span></span><span style="display:flex;"><span>s : r <span style="color:#66d9ef">W</span> <span style="color:#66d9ef">X</span> ;</span></span></code></pre></div><p>Hier würden sich die Regeln <code>r</code> und <code>s</code> gegenseitig aufrufen und kein Token aus dem
Tokenstrom entfernen, so dass der generierte LL-Parser hier in einer Endlosschleife
stecken bleiben würde. Mit indirekter Links-Rekursion kann ANTLR nicht umgehen.</p>
<h3 id="konflikte-in-regeln">Konflikte in Regeln</h3>
<p>Wenn mehrere Alternativen einer Regel anwendbar sind, entscheidet sich ANTLR für die
erste Alternative.</p>
<p>Wenn sich mehrere Tokenregeln überlappen, &quot;gewinnt&quot; auch hier die zuerst definierte
Regel.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>def : <span style="color:#e6db74">&#39;func&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;(&#39;</span> <span style="color:#e6db74">&#39;)&#39;</span> block ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>FOR : <span style="color:#e6db74">&#39;for&#39;</span> ;
</span></span><span style="display:flex;"><span>ID  : [a-z][a-zA-Z]<span style="color:#f92672">*</span> ;</span></span></code></pre></div><p>Hier werden ein implizites Token <code>'func'</code> sowie die expliziten Token <code>FOR</code> und <code>ID</code>
definiert. Dabei sind die Lexeme für <code>'func'</code> und <code>FOR</code> auch in <code>ID</code> enthalten.
Dennoch werden <code>'func'</code> und <code>FOR</code> erkannt und nicht über <code>ID</code> gematcht, weil sie
<em>vor</em> der Regel <code>ID</code> definiert sind.</p>
<p>Tatsächlich sortiert ANTLR die Regeln intern um, so dass alle Parser-Regeln <em>vor</em> den
Lexer-Regeln definiert sind. Die impliziten Token werden dabei noch vor den expliziten
Token-Regeln angeordnet. Im obigen Beispiel hat also <code>'func'</code> eine höhere Priorität
als <code>FOR</code>, und <code>FOR</code> hat eine höhere Priorität als <code>ID</code>. Aus diesem Grund gibt es die
Konvention, die Parser-Regeln in der Grammatik vor den Lexer-Regeln zu definieren - dies
entspricht quasi der Anordnung, die ANTLR bei der Verarbeitung sowieso erzeugen würde.</p>
<p>Aus diesem Grund würde auch eine Umsortierung der obigen Grammatik funktionieren:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>FOR : <span style="color:#e6db74">&#39;for&#39;</span> ;
</span></span><span style="display:flex;"><span>ID  : [a-z][a-zA-Z]<span style="color:#f92672">*</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def : <span style="color:#e6db74">&#39;func&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;(&#39;</span> <span style="color:#e6db74">&#39;)&#39;</span> block ;</span></span></code></pre></div><p>Intern würde ANTLR die Parser-Regel <code>def</code> wieder vor den beiden Lexer-Regeln anordnen,
und zwischen den Parser-Regeln und den Lexer-Regeln die impliziten Token (hier <code>'func'</code>).</p>
<h2 id="kontext-objekte-für-parser-regeln">Kontext-Objekte für Parser-Regeln</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>s    : expr         {List&lt;EContext&gt; x = $expr.ctx.e();}
</span></span><span style="display:flex;"><span>     ;
</span></span><span style="display:flex;"><span>expr : e <span style="color:#e6db74">&#39;*&#39;</span> e ;</span></span></code></pre></div><p><a href="#R-image-9ab78d8370d1b91852d454d9b51156ca" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParserRuleContext.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9ab78d8370d1b91852d454d9b51156ca"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParserRuleContext.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Jede Regel liefert ein passend zu dieser Regel generiertes Kontext-Objekt
zurück. Darüber kann man das/die Kontextobjekt(e) der Sub-Regeln abfragen.</p>
<p>Die Regel <code>s</code> liefert entsprechend ein <code>SContext</code>-Objekt und die Regel
<code>expr</code> liefert ein <code>ExprContext</code>-Objekt zurück.</p>
<p>In der Aktion fragt man das Kontextobjekt über <code>ctx</code> ab, in den Listener-
und Visitor-Methoden erhält man die Kontextobjekte als Parameter.</p>
<p>Für einfache Regel-Aufrufe liefert die parameterlose Methode nur ein
einziges Kontextobjekt (statt einer Liste) zurück.</p>
<p><strong>Anmerkung</strong>: ANTLR generiert nur dann <em>Felder</em> für die Regel-Elemente im
Kontextobjekt, wenn diese in irgendeiner Form referenziert werden. Dies
kann beispielsweise durch Benennung (Definition eines Labels, siehe nächste
Folie) oder durch Nutzung in einer Aktion (siehe obiges Beispiel) geschehen.</p>
<h2 id="benannte-regel-elemente-oder-alternativen">Benannte Regel-Elemente oder Alternativen</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stat  : <span style="color:#e6db74">&#39;return&#39;</span> value<span style="color:#f92672">=</span>e <span style="color:#e6db74">&#39;;&#39;</span>    <span style="color:#f92672">#</span> <span style="color:#66d9ef">Return</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;break&#39;</span> <span style="color:#e6db74">&#39;;&#39;</span>             <span style="color:#f92672">#</span> <span style="color:#66d9ef">Break</span>
</span></span><span style="display:flex;"><span>      ;</span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StatContext</span> <span style="color:#66d9ef">extends</span> ParserRuleContext <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReturnContext</span> <span style="color:#66d9ef">extends</span> StatContext <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> EContext value<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> EContext <span style="color:#a6e22e">e</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BreakContext</span> <span style="color:#66d9ef">extends</span> StatContext <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span></span></span></code></pre></div><p>Mit <code>value=e</code> wird der Aufruf der Regel <code>e</code> mit dem Label <code>value</code> belegt,
d.h. man kann mit <code>$e.text</code> oder <code>$value.text</code> auf das <code>text</code>-Attribut von
<code>e</code> zugreifen. Falls es in einer Produktion mehrere Aufrufe einer anderen
Regel gibt, <strong>muss</strong> man für den Zugriff auf die Attribute eindeutige Label
vergeben.</p>
<p>Analog wird für die beiden Alternativen je ein eigener Kontext erzeugt.</p>
<h2 id="arbeiten-mit-antlr-listeners">Arbeiten mit ANTLR-Listeners</h2>
<p>ANTLR (generiert auf Wunsch) zur Grammatik passende Listener (Interface und
leere Basisimplementierung). Beim Traversieren mit dem Default-<code>ParseTreeWalker</code>
wird der Parse-Tree mit Tiefensuche abgelaufen und jeweils beim Eintritt in
bzw. beim Austritt aus einen/m Knoten der passende Listener mit dem passenden
Kontext-Objekt aufgerufen.</p>
<p>Damit kann man die Grammatik &quot;für sich&quot; halten, d.h. unabhängig von einer
konkreten Zielsprache und die Aktionen über die Listener (oder Visitors, s.u.)
ausführen.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;*&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">MULT</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;+&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">ADD</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">DIGIT</span>                    <span style="color:#f92672">#</span> <span style="color:#66d9ef">ZAHL</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p>ANTLR kann zu dieser Grammatik <code>calc.g4</code> einen passenden Listener (Interface
<code>calcListener</code>) generieren (Option <code>-listener</code> beim Aufruf von <code>antlr</code>).
Weiterhin generiert ANTLR eine leere Basisimplementierung (Klasse <code>calcBaseListener</code>):</p>
<p><a href="#R-image-d24621cefc1dbfeb9e6d3b7bbdd0a076" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParseTreeListener.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d24621cefc1dbfeb9e6d3b7bbdd0a076"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParseTreeListener.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>(Nur &quot;interessante&quot; Methoden gezeigt.)</p>
<p>Von dieser Basisklasse leitet man einen eigenen Listener ab und implementiert
die Methoden, die man benötigt.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyListener</span> <span style="color:#66d9ef">extends</span> calcBaseListener <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exitMULT</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">MULTContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exitADD</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">ADDContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exitZAHL</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">ZAHLContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div><p>Anschließend baut man das alles in eine Traversierung des Parse-Trees ein:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestMyListener</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyListener</span> <span style="color:#66d9ef">extends</span> calcBaseListener <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        calcLexer lexer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcLexer<span style="color:#f92672">(</span>CharStreams<span style="color:#f92672">.</span><span style="color:#a6e22e">fromStream</span><span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        CommonTokenStream tokens <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CommonTokenStream<span style="color:#f92672">(</span>lexer<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        calcParser parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcParser<span style="color:#f92672">(</span>tokens<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ParseTree tree <span style="color:#f92672">=</span> parser<span style="color:#f92672">.</span><span style="color:#a6e22e">s</span><span style="color:#f92672">();</span>    <span style="color:#75715e">// Start-Regel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        ParseTreeWalker walker <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ParseTreeWalker<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        MyListener eval <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyListener<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        walker<span style="color:#f92672">.</span><span style="color:#a6e22e">walk</span><span style="color:#f92672">(</span>eval<span style="color:#f92672">,</span> tree<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div><div style="text-align: right;">
<span class="btn cstyle default">
  <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/lecture/frontend/parsing/src/TestMyListener.java" target="_blank">
    Beispiel: TestMyListener.java und calc.g4
  </a>
</span></div>
<p>In <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/syntaxdriven.html">Syntaxgesteuerte Interpreter</a>
werden wir damit einen einfachen syntaxgesteuerten Interpreter aufbauen.</p>
<h2 id="arbeiten-mit-dem-visitor-pattern">Arbeiten mit dem Visitor-Pattern</h2>
<p>ANTLR (generiert ebenfalls auf Wunsch) zur Grammatik passende Visitoren
(Interface und leere Basisimplementierung).</p>
<p>Hier muss man im Gegensatz zu den Listeners allerdings selbst für eine geeignete
Traversierung des Parse-Trees sorgen. Dafür hat man mehr Freiheiten im Vergleich
zum Einsatz von Listeners, insbesondere im Hinblick auf Rückgabewerte.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;*&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">MULT</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;+&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">ADD</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">DIGIT</span>                    <span style="color:#f92672">#</span> <span style="color:#66d9ef">ZAHL</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p>ANTLR kann zu dieser Grammatik einen passenden Visitor (Interface <code>calcVisitor&lt;T&gt;</code>)
generieren (Option <code>-visitor</code> beim Aufruf von <code>antlr</code>). Weiterhin generiert ANTLR
eine leere Basisimplementierung (Klasse <code>calcBaseVisitor&lt;T&gt;</code>):</p>
<p><a href="#R-image-114f335f30d84c9819ebc2bf736e2cc3" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParseTreeVisitor.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-114f335f30d84c9819ebc2bf736e2cc3"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParseTreeVisitor.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>(Nur &quot;interessante&quot; Methoden gezeigt.)</p>
<p>Von dieser Basisklasse leitet man einen eigenen Visitor ab und überschreibt
die Methoden, die man benötigt. Wichtig ist, dass man selbst für das &quot;Besuchen&quot;
der Kindknoten sorgen muss (rekursiver Aufruf der geerbten Methode <code>visit()</code>).</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyVisitor</span> <span style="color:#66d9ef">extends</span> calcBaseVisitor<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">visitMULT</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">MULTContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">visitADD</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">ADDContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">visitZAHL</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">ZAHLContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div><p>Anschließend baut man das alles in eine manuelle Traversierung des Parse-Trees ein:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestMyVisitor</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyVisitor</span> <span style="color:#66d9ef">extends</span> calcBaseVisitor<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        calcLexer lexer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcLexer<span style="color:#f92672">(</span>CharStreams<span style="color:#f92672">.</span><span style="color:#a6e22e">fromStream</span><span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        CommonTokenStream tokens <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CommonTokenStream<span style="color:#f92672">(</span>lexer<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        calcParser parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcParser<span style="color:#f92672">(</span>tokens<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ParseTree tree <span style="color:#f92672">=</span> parser<span style="color:#f92672">.</span><span style="color:#a6e22e">s</span><span style="color:#f92672">();</span>    <span style="color:#75715e">// Start-Regel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        MyVisitor eval <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyVisitor<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        eval<span style="color:#f92672">.</span><span style="color:#a6e22e">visit</span><span style="color:#f92672">(</span>tree<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div><div style="text-align: right;">
<span class="btn cstyle default">
  <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/lecture/frontend/parsing/src/TestMyVisitor.java" target="_blank">
    Beispiel: TestMyVisitor.java und calc.g4
  </a>
</span></div>
<p>In <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/syntaxdriven.html">Syntaxgesteuerte Interpreter</a>
werden wir damit einen einfachen syntaxgesteuerten Interpreter aufbauen.</p>
<h2 id="eingebettete-aktionen-und-attribute">Eingebettete Aktionen und Attribute</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>s   : expr                      {System.err.println($expr.v);}
</span></span><span style="display:flex;"><span>    ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>expr <span style="color:#66d9ef">returns</span> [int v]
</span></span><span style="display:flex;"><span>    : e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;*&#39;</span> e2<span style="color:#f92672">=</span>expr       {$v = $e1.v * $e2.v;}
</span></span><span style="display:flex;"><span>    ;</span></span></code></pre></div><p>Auch die Parser-Regeln können mit eingebetteten Aktionen ergänzt werden, die
in die (für die jeweilige Regel) generierte Methode eingefügt werden und bei
erfolgreicher Anwendung der Parser-Regel ausgeführt werden.</p>
<p>Über <code>returns [int v]</code> fügt man der Regel <code>expr</code> ein Attribut <code>v</code> (Integer)
hinzu, welches man im jeweiligen Kontext abfragen bzw. setzen kann (agiert
als Rückgabewert der generierten Methode). Auf diesen Wert kann in den
Aktionen mit <code>$v</code> zugegriffen werden.</p>
<p>In <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/attribgrammars.html">Attributierte Grammatiken</a>
werfen wir einen genaueren Blick auf die attributierten Grammatiken. In
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/syntaxdriven.html">Syntaxgesteuerte Interpreter</a>
werden wir eingebettete Aktionen und Attribute nutzen, um einen einfachen
syntaxgesteuerten Interpreter aufzubauen.</p>
<p><em>Anmerkung</em>: Durch den Einsatz von eingebetteten Aktionen und Attributen wird
die Grammatik abhängig von der Zielsprache des generierten Lexers/Parsers!</p>
<h2 id="ausblick">Ausblick</h2>
<p>Damit haben wir die sprichwörtliche &quot;Spitze des Eisbergs&quot; gesehen. Mit ANTLR
sind noch viele weitere Dinge möglich. Bitte nutzen Sie aktiv die Dokumentation
auf <a href="https://github.com/antlr/antlr4" target="_blank">github.com/antlr/antlr4</a>.</p>
<p>Mit Hilfe von semantischen Prädikaten (vgl.
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html">LL-Parser: Fortgeschrittene Techniken</a>)
können Parser-Regeln aktiviert oder abgeschaltet werden, je nachdem, was vorher
gesehen wurde.</p>
<p>Dem Thema Behandlung von Fehlern ist eine eigene Sitzung gewidmet:
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery.html">Error-Recovery</a>.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<p>Parser mit ANTLR generieren: Parser-Regeln werden mit <strong>Kleinbuchstaben</strong> geschrieben</p>
<ul>
<li>Regeln können Lexer- und Parser-Regeln &quot;aufrufen&quot;</li>
<li>Regeln können Alternativen haben</li>
<li>Bei Mehrdeutigkeit: Vorrang für erste Alternative</li>
<li>ANTLR erlaubt direkte Links-Rekursion</li>
<li>ANTLR erzeugt Parse-Tree</li>
<li>Benannte Alternativen und Regel-Elemente</li>
<li>Traversierung des Parse-Tree: Listener oder Visitoren, Zugriff auf Kontextobjekte</li>
</ul>


    



    



    

    
<div class="box notices cstyle note">
  <div class="box-label"><i class="fas fa-puzzle-piece"></i> Challenges</div>
  <div class="box-content">

<p><strong>Lexer und Parser mit ANTLR: Programmiersprache Lox</strong></p>
<p>Betrachten Sie folgenden Code-Schnipsel in der Sprache <a href="https://www.craftinginterpreters.com/the-lox-language.html" target="_blank">&quot;Lox&quot;</a>:</p>
<pre><code>fun fib(x) {
    if (x == 0) {
        return 0;
    } else {
        if (x == 1) {
            return 1;
        } else {
            fib(x - 1) + fib(x - 2);
        }
    }
}

var wuppie = fib(4);
</code></pre>
<p>Erstellen Sie für diese fiktive Sprache einen Lexer+Parser mit ANTLR.</p>
<p>(Die genauere Sprachdefinition finden Sie bei Bedarf unter <a href="https://www.craftinginterpreters.com/the-lox-language.html" target="_blank">craftinginterpreters.com/the-lox-language.html</a>.)</p>
</div>
</div>



    





    




    
    
        
        

        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Grenze Lexer und Parser</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>Die Grenze zwischen Lexer und Parser ist gleitend. Das Ziel jeder Verarbeitungsstufe in der
Compilerpipeline sollte es sein, eine möglichst hohe Abstraktion auf der jeweiligen Ebene
zu erreichen.</p>
<p>Das führt zu einfachen Grundregeln:</p>
<ul>
<li>Verwerfe im Lexer alles, was ich später nicht mehr benötige</li>
<li>Fasse so viel wie möglich zusammen:
<ul>
<li>Dinge, die der Parser unterscheiden können muss, sollten vom Lexer als unterschiedliche
Token erkannt werden</li>
<li>Dinge, die der Parser nicht unterscheiden muss, könnten in einen gemeinsamen Token-Typ
geschrieben werden</li>
<li>Fasse nach Möglichkeit passende Zeichenfolgen als ein Token zusammen, d.h. präsentiere
dem Parser nicht eine Folge von Ziffern-Token, sondern <em>ein</em> Number-Token (wenn im
Zeichenstrom eine Integerzahl kommt)</li>
</ul>
</li>
</ul>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/u9fE_I764rg' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Grenze Lexer und Parser</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/cb1486383c3bc9cf2e1c88b2dd94dea71954ceb2f6ea23dea512f10b3d86c34363b8d9c0ab41ef56fc07d9e3b22726752a92ff426592f129c6d6e674795f91cb' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Grenze Lexer und Parser</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K2) Grenze zwischen Lexer und Parser: Was mache ich auf welcher Stufe?</li></ul></div>
</div>




    <h2 id="grenze-lexer-und-parser-faustregeln">Grenze Lexer und Parser (Faustregeln)</h2>
<p>Der Lexer verwendet einfache reguläre Ausdrücke, während der Parser
mit Lookaheads unterschiedlicher Größe, Backtracking und umfangreicher
Error-Recovery arbeitet. Entsprechend sollte man alle Arbeit, die
man bereits im Lexer erledigen kann, auch dort erledigen. Oder
andersherum: Man sollte dem Parser nicht unnötige Arbeit aufbürden.</p>
<p>=&gt; Erreiche in jeder Verarbeitungsstufe die maximal mögliche Abstraktionsstufe!</p>
<ol>
<li>
<p>Matche und verwerfe im Lexer alles, was der Parser nicht braucht.</p>
<p>Wenn bestimmte Dinge später nicht gebraucht werden, sollten sie bereits
im Lexer erkannt und aussortiert werden. Der Lexer arbeitet deutlich
einfacher und schneller als der Parser ... Und je weniger Token der
Parser betrachten muss, um so einfacher und schneller kann er werden.</p>
</li>
<li>
<p>Matche gebräuchliche Token (Namen, Schlüsselwörter, Strings, Zahlen) im Lexer.</p>
<p>Der Lexer hat deutlich weniger Overhead als der Parser. Es lohnt sich deshalb,
beispielsweise Ziffern bereits im Lexer zu Zahlen zusammenzusetzen und dem
Parser als entsprechendes Token zu präsentieren.</p>
</li>
<li>
<p>Quetsche alle lexikalischen Strukturen, die der Parser nicht unterscheiden muss, in einen Token-Typ.</p>
<p>Wenn der Parser bestimmte Strukturen nicht unterscheiden muss, dann macht es
wenig Sinn, dennoch unterschiedliche Token an den Parser zu senden.</p>
<p>Beispiel:
Wenn eine Anwendung nicht zwischen Integer- und Gleitkommazahlen unterscheidet,
sollte der Lexer dafür nur einen Token-Typ erzeugen und an den Parser senden
(etwa <code>NUMBER</code>).</p>
<p>Beispiel:
Wenn der Parser nicht den Inhalt eines XML-Tags &quot;verstehen&quot; muss, dann kann man
diesen in ein einzelnes Token packen.</p>
</li>
<li>
<p>Wenn der Parser Texteinheiten unterscheiden muss, erzeuge dafür eigene Token-Typen im Lexer.</p>
<p>Wenn der Parser etwa Elemente einer Telefonnummer verarbeiten muss, sollte
der Lexer passende Token für die Teile der Telefonnummer erzeugen und an den
Parser schicken.</p>
</li>
</ol>
<h2 id="diskussion-parsen-von-adressbüchern-und-telefonnummern">Diskussion: Parsen von Adressbüchern und Telefonnummern</h2>
<p>Typischer Aufbau eines Adressbuch-Eintrags:</p>
<pre><code>Vorname Name: +49.571.8385-268
</code></pre>
<ul>
<li>
<p>Zählen der Zeilen des Adressbuchs</p>
<p>Wenn es nur um das Zählen der Zeilen geht, muss der Parser nicht den
Aufbau der Zeilen oder sogar den Aufbau von Telefonnummern verstehen.
Es reichen einfache Lexer-Regeln (<code>ROW</code>), die quasi die Zeilenumbrüche
repräsentieren. Der Rest (<code>OTHER</code>) wird per <code>skip</code> (ANTLR-Syntax)
einfach entfernt ...</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>addrbk : <span style="color:#66d9ef">ROW</span><span style="color:#f92672">+</span>;
</span></span><span style="display:flex;"><span>ROW    : <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>OTHER  : <span style="color:#f92672">~</span><span style="color:#e6db74">&#39;\n&#39;</span> <span style="color:#f92672">-&gt;</span> skip ;</span></span></code></pre></div></li>
<li>
<p>Liste aller Telefonnummern</p>
<p>Wenn man nun eine Liste aller Telefonnummern erzeugen will, wäre es ausreichend,
die Struktur einer Zeile (und damit die Telefonnummern) mit Lexer-Regeln
(und -Fragmenten) zu erkennen.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>addrbk  : row<span style="color:#f92672">+</span>;
</span></span><span style="display:flex;"><span>row     : <span style="color:#66d9ef">SURNAME</span> <span style="color:#66d9ef">NAME</span> <span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#66d9ef">TELNR</span>;</span></span></code></pre></div></li>
<li>
<p>Weitere Verarbeiten der Telefonnummern im Parser (Aktionen)</p>
<p>Wenn man zusätzlich die Telefonnummern noch weiter im Parser verarbeiten will
(etwa durch eingebettete Aktionen), dann muss die Regel zum Erkennen der
Adressen entsprechend eine Parser-Regel sein:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>addrbk  : row<span style="color:#f92672">+</span>;
</span></span><span style="display:flex;"><span>row     : <span style="color:#66d9ef">SURNAME</span> <span style="color:#66d9ef">NAME</span> <span style="color:#e6db74">&#39;:&#39;</span> telnr;</span></span></code></pre></div></li>
</ul>
<p>Die weiterführenden Lexer- und Parser-Regeln (<code>telnr</code>, <code>TELNR</code>, <code>SURNAME</code>, <code>NAME</code>)
sind hier nicht dargestellt.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>Grenze zw. Lexer und Parser ist gleitend</li>
<li>Ziel: möglichst hohe Abstraktion auf jeder Ebene erreichen</li>
</ul>


    



    



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Nystrom2021'>[Nystrom2021] <a href='https://github.com/munificent/craftinginterpreters' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>Crafting Interpreters</strong></a><br>Nystrom, R., Genever Benning, 2021. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-9905829-3-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-9905829-3-9</a>.</li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Syntaxanalyse: LR-Parser (Teil 1)</h1>



    
    




    
    
        
        
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="far fa-file-powerpoint"></i> Annotierte Folien</div>
  <div class="box-content">

<ul> <li><a href='https://raw.githubusercontent.com/Compiler-CampusMinden/AnnotatedSlides/master/lr-parser1.ann.ma.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Annotierte Folien: LR-Parser1</a></li></ul></div>
</div>




    <h1 id="wiederholung">Wiederholung</h1>
<h2 id="top-down-analyse">Top-Down-Analyse</h2>
<ul>
<li>Baumaufbau von oben nach unten</li>
<li>die Grammatik muss reduziert sein</li>
<li>recursive-descent parser</li>
<li><em>First-</em> und <em>Follow</em>-Mengen bestimmen Wahl der Ableitungen</li>
<li>tabellengesteuert</li>
<li>nicht mehr rekursiv, sondern mit PDA</li>
</ul>
<h1 id="motivation">Motivation</h1>
<h2 id="ll-ist-nicht-alles"><em>LL</em> ist nicht alles</h2>
<p>Die Menge der <em>LL</em>-Sprachen ist eine echte Teilmenge der deterministisch kontextfreien Sprachen. Wir brauchen ein Verfahren, mit dem man alle deterministisch kontextfreien Sprachen parsen kann.</p>
<h1 id="bottom-up-analyse">Bottom-Up-Analyse</h1>
<h2 id="von-unten-nach-oben">Von unten nach oben</h2>
<p>Bei 
<span class="math align-center">$LL$</span>-Sprachen muss man nach den ersten 
<span class="math align-center">$k$</span> Eingabezeichen entscheiden, welche Ableitung ganz oben im Baum als erste durchgeführt wird, also eine, die im Syntaxbaum ganz weit weg ist von den Terminalen, die die Entschiedung bestimmen.Es gibt deterministisch kontextfreie Sprachen, die nicht 
<span class="math align-center">$LL(k)$</span> sind für irgendein <em>k</em>.</p>
<p>Bei der Bottom-Up-Analyse geht man den umgekehrten Weg. Der Parse Tree wird von unten nach oben aufgebaut, die Entscheidung, welche Produktion angewandt wird, erfolgt &quot;näher&quot; am Terminal. Mit Hilfe der Produktionen und der Vorschautoken werden die Ableitungen &quot;rückwärts&quot; angewandt und &quot;Reduktionen&quot; genannt.</p>
<p>Fehlermeldungen können näher am Programmtext erfolgen.</p>
<h2 id="baumaufbau-von-unten">Baumaufbau von unten</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="kann-ein-stack-helfen">Kann ein Stack helfen?</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="probleme-damit">Probleme damit?</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h1 id="konfliktfälle">Konfliktfälle</h1>
<h2 id="mehrdeutigkeiten--konflikte-beim-parsen">Mehrdeutigkeiten = Konflikte beim Parsen</h2>
<p>Es gibt Grammatiken, bei denen nicht aus dem Inhalt des Stacks und dem Eingabezeichen entschieden werden kann, wie fortgefahren wird, auch nicht, wenn man, wie auch schon im Fall 
<span class="math align-center">$LL$</span>, eine feste Zahl 
<span class="math align-center">$k$</span> von Vorschautoken berücksichtigt. Diese Grammatiken können mehrdeutig sein.</p>
<p>Folgen von falschen Entscheidungen:</p>
<ul>
<li>falscher Baum, falsche Bäume</li>
<li>kein Baum</li>
</ul>
<h2 id="mögliche-konflikte">Mögliche Konflikte</h2>
<ul>
<li>Reduce-Reduce-Konflikt: Es sind zwei oder mehr verschiedene Reduktionen möglich</li>
<li>Shift-Reduce-Konflikt: Es kann nicht entschieden werden, ob eine Reduktion oder ein Shift durchgeführt werden soll.</li>
</ul>
<p>Shiften bedeutet, das nächste Eingabesymbol miteinbeziehen.</p>
<h1 id="lr-parsing">LR-Parsing</h1>
<h2 id="da-wollen-wir-hin">Da wollen wir hin</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser1/Parser-Automat.png" alt="Parser-Automat" width="80%" height="auto">
    <figcaption><p>Parser-Automat</p></figcaption>
</figure>
<h2 id="so-geht-es">So geht es</h2>
<p>Der Stack enthält Zustände, keine Terminals oder Nonterminals.</p>
<p>Der Top-of-Stack ist immer der aktuelle Zustand, am Anfang

<span class="math align-center">$I_0$</span>. Im Stack steht 
<span class="math align-center">$I_0\ \bot$</span>.</p>
<p>Vorgehen:
Im aktuellen Zustand nachschauen, ob das Eingabezeichen auf einem Pfeil steht.</p>
<ul>
<li>
<p>ja: Shiften, d. h. dem Pfeil folgen und den Zustand am Ende des Pfeils pushen. Dort weiter.</p>
</li>
<li>
<p>nein: Reduzieren nach der Regel aus dem aktuellen Zustand mit dem Punkt hinten, d. h. so viele Zustände poppen, wie die Regel Elemente auf der rechten Seite hat. Der Zustand darunter wird aktuell, dem Pfeil mit dem zu reduzierenden Nonterminal der linken Seite der Regel folgen und pushen.</p>
</li>
</ul>
<p>Am Schluss kann nur noch mit 
<span class="math align-center">$\bot$</span> akzeptiert werden.</p>
<h2 id="beispiel">Beispiel</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="definitionen">Definitionen</h2>
<p><strong>Def.:</strong> Bei einer kontextfreien Grammatik <em>G</em> ist die <em>Rechtsableitung</em> von 
<span class="math align-center">$\alpha \in (N \cup T)^{\ast}$</span> die Ableitung, die man erhält, wenn das am weitesten rechts stehende Nichtterminal in 
<span class="math align-center">$\alpha$</span> abgeleitet wird. Man schreibt 
<span class="math align-center">$\alpha \overset{\ast}{\Rightarrow}_r \beta$</span>.</p>
<p><strong>Def.:</strong> Eine <em>Rechtssatzform</em> 
<span class="math align-center">$\alpha$</span> einer Grammatik <em>G</em> ist ein Element aus

<span class="math align-center">$(N \cup T)^{\ast}$</span> mit 
<span class="math align-center">$S \overset{\ast}{\Rightarrow}_r \alpha$</span>.</p>
<p><strong>Def.:</strong> In dem Syntaxbaum von 
<span class="math align-center">$S \overset{\ast}{\Rightarrow}_r \alpha\ A\ w \Rightarrow_r \alpha\ \beta\ w$</span> einer kontextfreien Grammatik ist 
<span class="math align-center">$\beta$</span> ein <em>Handle</em> von der Produktion 
<span class="math align-center">$A \rightarrow \beta$</span>.</p>
<h2 id="lr-parsing-1">LR-Parsing</h2>
<p>Bei der <em>LR</em>-Analyse eines Wortes <em>w</em> wird <em>w</em> von links nach rechts gelesen, dabei wird die Rechtsableitung von <em>w</em> in <em>G</em> von unten nach oben aufgebaut.
Man spricht nicht nicht mehr von Ableitungen, sondern von Reduktionen.</p>
<p>Mehrdeutige Grammatiken können nicht <em>LR</em> sein.</p>
<ul>
<li>Vor der Konstruktion des Automaten wird die Grammatik um eine neues Nonterminal 
<span class="math align-center">$S'$</span> und die neue Produktion 
<span class="math align-center">$S' \rightarrow S$</span> erweitert. 
<span class="math align-center">$S'$</span> ist dann Startsymbol.</li>
<li>Es wird ein Automat erstellt (s.o.)</li>
<li>Es wird eine Parse Table aus dem Automaten erstellt, die den Parse-Vorgang steuert, mit Aktionsteil und Sprungteil.</li>
</ul>
<h2 id="steuerung-des-parsens-mittels-der-parse-table">Steuerung des Parsens mittels der Parse Table</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser1/ParserProgram.png" alt="Parser Schema" width="80%" height="auto">
    <figcaption><p>Parser Schema</p></figcaption>
</figure>
<h2 id="arbeitsweise">Arbeitsweise</h2>
<p>Im Stack stehen nur Zustandsnummern, am Anfang die Nummer des Startzustandes (+ Bottomzeichen, oft auch 
<span class="math align-center">$\$$</span>). Es ist nicht nötig, Symbole zu stacken.</p>
<ul>
<li>Lesen des obersten Stackelements ergibt Zustand <em>q</em></li>
<li>Lesen des nächsten Eingabezeichens ergibt Zeichen <em>a</em></li>
<li>Nachschlagen der Reaktion auf 
<span class="math align-center">$(q, a)$</span> in der Parse Table</li>
<li>Durchführung der Reaktion</li>
</ul>
<h2 id="mögliche-actions-ohne-berücksichtigung-von-vorschautoken">Mögliche &quot;Actions&quot; ohne Berücksichtigung von Vorschautoken</h2>
<ul>
<li>Shift: Schiebe logisch das nächste Eingabesymbol auf den Stack (in Wirklichkeit Zustandsnummern)</li>
<li>Reduce: (Identifiziere ein Handle oben auf dem Stack und ersetze es durch das Nichtterminal der dazugehörigen Produktion.) Das ist gleichbedeutend mit: Entferne so viele Zustände vom Stack wie die rechte Seite der zu reduzierenden Regel Elemente hat, und schreibe den Zustand, der im Goto-Teil für 
<span class="math align-center">$(q, a)$</span> steht, auf den Stack.</li>
<li>Accept: Beende das Parsen erfolgreich</li>
<li>Reagiere auf einen Syntaxfehler</li>
</ul>
<h1 id="0-vorschautoken--lr0-parsing">0 Vorschautoken = LR(0)-Parsing</h1>
<h2 id="lr-parsing-ohne-vorschautoken">LR-Parsing ohne Vorschautoken</h2>
<p>Wichtig: Das Handle, d. h. die rechte Seite einer zu reduzierenden Regel, erscheint oben auf dem Stack, nie weiter unten.</p>
<p>Je nach Anwendungsfall müssen beim Reduzieren von Handles weitere Aktionen ausgeführt werden: z. B. Syntaxbäume aufgebaut, Werte in Tabellen geschrieben werden, usw. Nicht alle rechten Seiten von Produktionen, die oben auf dem Stack stehen, sind auch Handles, manchmal muss nur geshiftet werden.</p>
<p>Bsp: Steht bei der Beispielgrammatik von Folie 8 oben auf dem Stack ein 
<span class="math align-center">$T$</span> mit dem nächsten Eingabezeichen 
<span class="math align-center">$\ast$</span>, darf 
<span class="math align-center">$T$</span> nicht zu 
<span class="math align-center">$E$</span> reduziert werden.</p>
<p>Lösung: Der Parser merkt sich, wo er steht in noch nicht komplett reduzierten Regeln. Dazu benutzt er sogenannte <em>Items</em> oder <em>LR(0)-Items</em>, auch <em>dotted Items</em> oder <em>(kanonische) LR(0)-Elemente</em> genannt.</p>
<h2 id="items">Items</h2>
<p><strong>Def.:</strong> Ein <em>Item</em> einer Grammatik <em>G</em> ist eine Produktion von <em>G</em> mit einem Punkt auf der rechten Seite der Regel vor, zwischen oder nach den Elementen.</p>
<p>Bsp.:</p>
<p>Zu der Produktion 
<span class="math align-center">$A \rightarrow BC$</span> gehören die Items:</p>

<span class="math align-center">$[A\rightarrow \cdot B C]$</span>
<p>
<span class="math align-center">$[A\rightarrow B \cdot C$</span>]</p>

<span class="math align-center">$[A\rightarrow B C \cdot]$</span>
<p>Das zu 
<span class="math align-center">$A \rightarrow \epsilon$</span> gehörende Item ist 
<span class="math align-center">$[A \rightarrow \cdot]$</span></p>
<h2 id="was-bedeuten-die-items">Was bedeuten die Items?</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="berechnung-der-closure_0-von-einer-menge-i-von-items">Berechnung der <em>Closure_0</em> von einer Menge <em>I</em> von Items</h2>
<ol>
<li>
<p>füge 
<span class="math align-center">$I$</span> zu 
<span class="math align-center">$CLOSURE_0 (I)$</span> hinzu</p>
</li>
<li>
<p>gibt es ein Item 
<span class="math align-center">$[A \rightarrow \alpha \cdot B\beta]$</span> aus 
<span class="math align-center">$CLOSURE_0 (I)$</span> und eine Produktion 
<span class="math align-center">$(B \rightarrow \gamma)$</span>, füge 
<span class="math align-center">$[B \rightarrow \cdot \gamma]$</span> zu 
<span class="math align-center">$CLOSURE_0 (I)$</span> hinzu</p>
</li>
</ol>
<h2 id="berechnung-der-goto_0-sprungmarken">Berechnung der <em>GOTO_0</em>-Sprungmarken</h2>

<span class="math align-center">$GOTO_0(I, X) = CLOSURE_0(\lbrace[A \rightarrow \alpha X \cdot \beta] \mid [A \rightarrow \alpha \cdot X \beta] \in I\rbrace)$</span>
<p>für eine Itemmenge <em>I</em> und 
<span class="math align-center">$X \in N \cup T, A \in N, \alpha, \beta \in (N \cup T)^{\ast}$</span>.</p>
<h2 id="konstruktion-des-hahahugoshortcode23s44hbhb---automaten">Konstruktion des 
<span class="math align-center">$LR(0)$</span> - Automaten</h2>
<ol>
<li>
<p>Bilde die Hülle von 
<span class="math align-center">$S' \rightarrow S$</span> und mache sie zum ersten Zustand.</p>
</li>
<li>
<p>Für jedes noch nicht betrachtete 
<span class="math align-center">$\cdot X, X \in (N \cup T)$</span> in einem Zustand 
<span class="math align-center">$q$</span> des Automaten berechne 
<span class="math align-center">$GOTO_0(q, X)$</span> und mache 
<span class="math align-center">$GOTO_0(q, X)$</span> zu einem neuen Zustand 
<span class="math align-center">$r$</span>. Verbinde 
<span class="math align-center">$q$</span> mit einem Pfeil mit 
<span class="math align-center">$r$</span> und schreibe 
<span class="math align-center">$X$</span> an den Pfeil. Ist ein zu 
<span class="math align-center">$r$</span> identischer Zustand schon vorhanden, wird 
<span class="math align-center">$p$</span> mit diesem verbunden und kein neuer erzeugt.</p>
</li>
</ol>
<h2 id="konstruktion-der-parse-table">Konstruktion der Parse Table</h2>
<ol>
<li>
<p>Erstelle eine leere Tabelle mit den Zuständen als Zeilenüberschriften. Für den Aktionstabellenteil überschreibe die Spalten mit den Terminalen, für den Sprungtabellenteil mit den Nonterminals.</p>
</li>
<li>
<p>Shift: Für jeden mit einem Terminal beschrifteten Pfeil aus einem Zustand erstelle in der Aktionstabelle die Aktion shift mit der Nummer des Zustands, auf den der Pfeil zeigt. Für Pfeile mit Nonterminals schreibe in die Sprungtabelle nur die Nummer des Folgezustands.</p>
</li>
<li>
<p>Schreibe beim Zustand 
<span class="math align-center">$[S' \rightarrow S \cdot]$</span> ein 
<span class="math align-center">$accept$</span> bei dem Symbol 
<span class="math align-center">$\bot$</span>.</p>
</li>
<li>
<p>Für jedes Item mit 
<span class="math align-center">$[A \rightarrow \beta \cdot]$</span> aus allen Zuständen schreibe für alle Terminals 
<span class="math align-center">$reduce$</span> und die Nummer der entsprechenden Grammatikregel in die Tabelle.</p>
</li>
</ol>
<h2 id="und-wenn-in-einer-zelle-schon-ein-eintrag-ist">Und wenn in einer Zelle schon ein Eintrag ist?</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="die-beispielgrammatik-g1">Die Beispielgrammatik G1</h2>
<p>(0) 
<span class="math align-center">$S^{'} \rightarrow S$</span></p>
<p>(1) 
<span class="math align-center">$S \rightarrow a A b S c S$</span></p>
<p>(2) 
<span class="math align-center">$S \rightarrow a A b S$</span></p>
<p>(3) 
<span class="math align-center">$S \rightarrow d$</span></p>
<p>(4) 
<span class="math align-center">$A \rightarrow e$</span></p>
<h2 id="der-lr0-automat-zu-g1">Der LR(0)-Automat zu G1</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser1/LR_0-SLR_1-Automat.png" alt="LR(0)-Automat" width="auto" height="auto">
    <figcaption><p>LR(0)-Automat</p></figcaption>
</figure>
<h2 id="die-lr0-parsertabelle-zu-g1">Die LR(0)-Parsertabelle zu G1</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser1/LR_0-Table.png" alt="LR(0)-Parsertabelle" width="60%" height="auto">
    <figcaption><p>LR(0)-Parsertabelle</p></figcaption>
</figure>
<h1 id="wrap-up">Wrap-Up</h1>
<h2 id="wrap-up-1">Wrap-Up</h2>
<ul>
<li>
<p>LR-Analyse baut den Ableitungbaum von unten nach oben auf.</p>
</li>
<li>
<p>Es wird ein DFA benutzt zusammen mit einem Stack, der Zustände speichert.</p>
</li>
<li>
<p>Eine Parse-Tabelle steuert über Aktions- und Sprungbefehle das Verhalten des Parsers.</p>
</li>
<li>
<p>Die Tabelle wird mit Items und Closures konstruiert.</p>
</li>
</ul>


    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Kapitel 4.5 bis 4.8</em></li> <li id='id_aho2013compilers'>[aho2013compilers] <strong>Compilers: Pearson New International Edition: Principles, Techniques, and Tools</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Education Limited, 2013. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-2920-3723-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-2920-3723-3</a>.</li> <li id='id_hopcroft2003'>[hopcroft2003] <strong>Einführung in die Automatentheorie, formale Sprachen und Komplexitätstheorie</strong><br>Hopcroft, J. E. und Motwani, R. und Ullman, J. D., Pearson Education Deutschland GmbH, 2003. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7020-4' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7020-4</a>.</li> <li id='id_Kunert2018'>[Kunert2018] <a href='http://amor.cms.hu-berlin.de/\~kunert/papers/lr-analyse/lr.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>LR(k)-Analyse für Pragmatiker</strong></a><br>Kunert, A., 2018.</li> <li id='id_Wagenknecht2014'>[Wagenknecht2014] <strong>Formale Sprachen, abstrakte Automaten und Compiler</strong><br>Wagenknecht, C. und Hielscher, M., Springer Fachmedien Wiesbaden, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-658-02692-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-658-02692-9</a>. DOI <a href='https://doi.org/10.1007/978-3-658-02692-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-658-02692-9</a>.</li></ul></div>
</div>



    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) Prinzipien der Bottom-Up-Analyse</li> <li>(K1) Items</li> <li>(K1) Closure</li> <li>(K1) Parse Table</li> <li>(K2) LR(0)-Parsing</li> <li>(K3) Konstruktion der Parse Tables</li> <li>(K3) Durchführen des Parsens</li></ul></div>
</div>



    








<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Syntaxanalyse: LR-Parser (Teil 2)</h1>



    
    




    
    
        
        
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="far fa-file-powerpoint"></i> Annotierte Folien</div>
  <div class="box-content">

<ul> <li><a href='https://raw.githubusercontent.com/Compiler-CampusMinden/AnnotatedSlides/master/lr-parser2.ann.ma.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Annotierte Folien: LR-Parser2</a></li></ul></div>
</div>




    <h1 id="wiederholung">Wiederholung</h1>
<p>Ein PDA für 
<span class="math align-center">$L=\lbrace ww^{R}\mid w\in \lbrace a,b\rbrace^{\ast}\rbrace$</span>:</p>
<p><a href="#R-image-358048f532d792aab9f84bdec706dcd9" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/pda.png?width=60%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 60%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-358048f532d792aab9f84bdec706dcd9"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/pda.png?width=60%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<h2 id="top-down-analyse">Top-Down-Analyse</h2>
<ul>
<li>LL reicht nicht.</li>
<li>LR: Aufbau des Ableitungsbaums von unten nach oben.</li>
<li>LR(0): Parsen ohne Vorschautoken</li>
<li>Ein DFA mit einem Stack wird über eine Tabelle mit Aktions- und Sprungbefehlen gesteuert.</li>
<li>Im Stack stehen Zustände des DFAs.</li>
<li>Diese Zustände werden mit sog. Dotted Items und deren Closures identifiziert.</li>
</ul>
<h1 id="motivation">Motivation</h1>
<h2 id="auch-lr0-ist-nicht-alles">Auch <em>LR(0)</em> ist nicht alles</h2>
<p>Die Menge der <em>LR(0)</em>-Sprachen ist eine echte Teilmenge der deterministisch kontextfreien Sprachen. Wir brauchen ein Verfahren, mit dem man alle deterministisch kontextfreien Sprachen parsen kann.</p>
<h1 id="bottom-up-analyse-mit-vorschautoken">Bottom-Up-Analyse mit Vorschautoken</h1>
<h2 id="lr-parsen-mit-1-vorschautoken">LR-Parsen mit 1 Vorschautoken</h2>
<p>Ist eine Grammatik nicht LR(0), kann sie vielleicht mit einem Vorschautoken geparst werden. Hier gibt es drei Verfahren:</p>
<ul>
<li>SLR(1)-Parsing</li>
<li>(kanonisches) LR(1)-Parsing</li>
<li>LALR(1)-Parsing</li>
</ul>
<h1 id="slr">SLR</h1>
<h2 id="simple-lr1--slr-parsing">Simple LR(1) = (SLR)-Parsing</h2>
<p>
<span class="math align-center">$A \rightarrow \beta$</span> wird nur reduziert, wenn das Vorschautoken in der 
<span class="math align-center">$FOLLOW$</span>-Menge von 
<span class="math align-center">$A$</span> ist.</p>
<p>
<span class="math align-center">$\Rightarrow$</span> Es ändert sich nur die Parse Table:</p>
<p>Bei allen LR(0)-Items in der Tabelle, die einen Punkt am Ende der
rechten Seite stehen haben, trage in der
Aktionstabelle beim zugehörigen Zustand die Reduktion mittels der zugehörigen
Regel bei allen Terminals ein, die in der FOLLOW-Menge des Nonterminals auf der linken Seite der Regel enthalten sind.</p>
<h2 id="der-slr-automat-der-grammatik-g1">Der SLR-Automat der Grammatik G1:</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/LR_0-SLR_1-Automat.png" alt="SLR(1)-Automat" width="auto" height="auto">
    <figcaption><p>SLR(1)-Automat</p></figcaption>
</figure>
<h2 id="die-slr-parsertabelle-der-grammatik-g1">Die SLR-Parsertabelle der Grammatik G1</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/SLR_1-Table.png" alt="SLR(1)-Parsertabelle" width="60%" height="auto">
    <figcaption><p>SLR(1)-Parsertabelle</p></figcaption>
</figure>
<h2 id="zum-vergleich-die-lr0-tabelle-von-g1-letzte-vorlesung">Zum Vergleich: Die LR(0)-Tabelle von G1 (letzte Vorlesung)</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/LR_0-Table.png" alt="LR(0)-Parsertabelle" width="60%" height="auto">
    <figcaption><p>LR(0)-Parsertabelle</p></figcaption>
</figure>
<h1 id="kanonische-lr1-syntaxanalyse">Kanonische LR(1)-Syntaxanalyse</h1>
<h2 id="mehr-geht-nicht-kanonische-lr1-syntaxanalyse--lr-analyse">Mehr geht nicht: Kanonische LR(1)-Syntaxanalyse = LR-Analyse</h2>
<p>Beim SLR-Verfahren wird nach 
<span class="math align-center">$A \rightarrow \beta$</span> reduziert, wenn das Vorschautoken in 
<span class="math align-center">$Follow(A)$</span> liegt. Dabei kann es vorkommen, dass das Vorschautoken ein Element davon ist, aber genau bei dieser Regel kann es nicht dem <em>A</em> folgen. Es wird also falsch reduziert, und es entstehen zu viele Einträge in der Tabelle (Konflikte!).</p>
<p>Jetzt werden nicht Follow-Mengen von Nichtterminalen, sondern LOOKAHEAD-Mengen von Produktionen berechnet.</p>
<h2 id="die-lr1-items">Die LR(1)-Items</h2>
<p>Zu jedem LR(0)-Item (hier auch <em>Kern</em> genannt) wird eine <em>LOOKAHEAD</em> - Menge 
<span class="math align-center">$L$</span> hinzugefügt, die angibt, welche Terminals dem Symbol auf der linken Seite folgen können.</p>
<p>z.  B. 
<span class="math align-center">$[S' \rightarrow \cdot S, \lbrace \bot \rbrace ]$</span></p>
<h2 id="die-hülle-hahahugoshortcode24s12hbhb">Die Hülle 
<span class="math align-center">$CLOSURE_1$</span></h2>
<ol>
<li>
<p>füge 
<span class="math align-center">$I$</span> zu 
<span class="math align-center">$CLOSURE_1 (I)$</span> hinzu</p>
</li>
<li>
<p>gibt es ein LR(1) - Item 
<span class="math align-center">$[A \rightarrow \alpha \cdot B \beta,\ L]$</span> aus 
<span class="math align-center">$CLOSURE_1 (I)$</span> und eine Produktion 
<span class="math align-center">$(B \rightarrow \gamma)$</span>, füge 
<span class="math align-center">$[B \rightarrow \cdot \gamma, FIRST(\beta\ L)]$</span> zu 
<span class="math align-center">$CLOSURE_1 (I)$</span> hinzu (
<span class="math align-center">$\alpha, \beta$</span> dürfen 
<span class="math align-center">$\epsilon$</span> sein).</p>
</li>
</ol>
<h2 id="hahahugoshortcode24s22hbhb">
<span class="math align-center">$Goto_1$</span></h2>
<p>
<span class="math align-center">$GOTO_1(I, X) =$</span> eine Produktion</p>

<span class="math align-center">$CLOSURE_1(\lbrace[A \rightarrow \alpha X \cdot \beta, \ L] \mid [A \rightarrow \alpha \cdot X \beta,\ L] \in I\rbrace)$</span>
<p>für eine Itemmenge 
<span class="math align-center">$I$</span> und 
<span class="math align-center">$X \in N \cup T, A \in N, \alpha, \beta \in (N \cup T)^{\ast}$</span>.</p>
<h2 id="der-lr1-automat">Der LR(1)-Automat</h2>
<p>Der Automat wird analog zum LR(0)-Automaten erstellt mit dem Startzustand</p>

<span class="math align-center">$[S' \rightarrow \cdot S, \lbrace \bot \rbrace ]$</span>
<p>Die Tabelle unterscheidet sich nur bei der Reduktion von der LR(0)-Tabelle:</p>
<p>Reduktionsoperationen werden in den Spalten der
Terminals eingetragen, die in der LOOKAHEAD-Menge der entsprechenden Regel enthalten sind.</p>
<h2 id="die-beispielgrammatik-g2">Die Beispielgrammatik G2</h2>
<p>(0) 
<span class="math align-center">$S^{'} \rightarrow S$</span></p>
<p>(1) 
<span class="math align-center">$S \rightarrow NN$</span></p>
<p>(2) 
<span class="math align-center">$N \rightarrow 0N$</span></p>
<p>(3) 
<span class="math align-center">$N \rightarrow 1$</span></p>
<h2 id="der-lr1-automat-der-grammatik-g2">Der LR(1)-Automat der Grammatik G2</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/LR_1-Automat.png" alt="LR(1)-Automat" width="auto" height="auto">
    <figcaption><p>LR(1)-Automat</p></figcaption>
</figure>
<h2 id="die-lr1-parsertabelle-der-grammatik-g2">Die LR(1)-Parsertabelle der Grammatik G2</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/LR_1-Table.png" alt="LR(1)-Parsertabelle" width="45%" height="auto">
    <figcaption><p>LR(1)-Parsertabelle</p></figcaption>
</figure>
<h1 id="lookahead-lr--lalr">Lookahead-LR = LALR</h1>
<h2 id="lalr1">LALR(1)</h2>
<p>Zusammenfassung aller LR(1)-Zustände, die sich nur in den LOOKAHEAD-Mengen unterscheiden</p>
<p>Parsergeneratoren generieren oft direkt aus einem LR(0)- einen LALR(1)-Zustands-
Übergangsgraphen durch Hinzufügen der LOOKAHEAD-Mengen.</p>
<h2 id="der-lalr-automat-der-grammatik-g2">Der LALR-Automat der Grammatik G2</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/LALR-Automat.png" alt="LALR(1)-Automat" width="auto" height="auto">
    <figcaption><p>LALR(1)-Automat</p></figcaption>
</figure>
<h2 id="die-lalr-parsertabelle-der-grammatik-g2">Die LALR-Parsertabelle der Grammatik G2</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/LALR-Table.png" alt="LALR(1)-Parsertabelle" width="60%" height="auto">
    <figcaption><p>LALR(1)-Parsertabelle</p></figcaption>
</figure>
<h1 id="hahahugoshortcode24s36hbhb-vorschautoken">
<span class="math align-center">$k \geq 2$</span> Vorschautoken</h1>
<h2 id="hierarachie">Hierarachie</h2>
<p>Zu jeder LR(k)-Sprache gibt es eine LR(1)-Grammatik.</p>
<h1 id="mehrdeutige-grammatiken">Mehrdeutige Grammatiken</h1>
<h2 id="es-gibt-auch-auswege">Es gibt auch Auswege</h2>
<p>Mehrdeutige Grammatiken sind oft leichter zu lesen und kleiner als die Grammatiken, die man erhält, wenn man die Mehrdeutigkeit auflöst, sofern möglich.
Also die Grammatik mehrdeutig lassen!</p>
<p>Folgendes kann trotzdem helfen:</p>
<ul>
<li>Angabe von Vorrangregeln</li>
<li>Angabe von Assoziativität</li>
<li>Voreinstellung des Parsergenearators: z. B. Shiften bei Shift-Reduce-Konflikten</li>
<li>Voreinstellung des Parsergenearators: z. B. Reduzieren nach der Regel, die in der Grammatik zuerst kommt bei Reduce-Reduce-Konflikten</li>
</ul>
<h1 id="hierarchie-der-kontextfreien-sprachen">Hierarchie der kontextfreien Sprachen</h1>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/CFG-Hierarchy.png" alt="Sprachenhierarchie" width="80%" height="auto">
    <figcaption><p>Sprachenhierarchie</p></figcaption>
</figure>
<h1 id="wrap-up">Wrap-Up</h1>
<h2 id="wrap-up-1">Wrap-Up</h2>
<ul>
<li>
<p>mit Bottom-Up-Parsing LR(1) kann man alle deterministisch kontextfreien Sprachen parsen</p>
</li>
<li>
<p>ein Vorschautoken genügt</p>
</li>
<li>
<p>LR(0)-, SLR- und LALR- Parsing sind vereinfachte Verfahren für Teilmengen der LR-Sprachen</p>
</li>
</ul>


    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Kapitel 4.5 bis 4.8</em></li> <li id='id_aho2013compilers'>[aho2013compilers] <strong>Compilers: Pearson New International Edition: Principles, Techniques, and Tools</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Education Limited, 2013. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-2920-3723-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-2920-3723-3</a>.</li> <li id='id_hopcroft2003'>[hopcroft2003] <strong>Einführung in die Automatentheorie, formale Sprachen und Komplexitätstheorie</strong><br>Hopcroft, J. E. und Motwani, R. und Ullman, J. D., Pearson Education Deutschland GmbH, 2003. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7020-4' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7020-4</a>.</li> <li id='id_Kunert2018'>[Kunert2018] <a href='http://amor.cms.hu-berlin.de/\~kunert/papers/lr-analyse/lr.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>LR(k)-Analyse für Pragmatiker</strong></a><br>Kunert, A., 2018.</li> <li id='id_Wagenknecht2014'>[Wagenknecht2014] <strong>Formale Sprachen, abstrakte Automaten und Compiler</strong><br>Wagenknecht, C. und Hielscher, M., Springer Fachmedien Wiesbaden, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-658-02692-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-658-02692-9</a>. DOI <a href='https://doi.org/10.1007/978-3-658-02692-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-658-02692-9</a>.</li></ul></div>
</div>



    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) Prinzipien der Bottom-Up-Analyse</li> <li>(K1) Items</li> <li>(K1) Closure</li> <li>(K1) Parse Table</li> <li>(K2) LR(0)-Parsing</li> <li>(K2) SLR-Parsing</li> <li>(K2) LR(1)-Parsing</li> <li>(K2) LALR-Parsing</li> <li>(K3) Konstruktion der Parse Tables</li> <li>(K3) Durchführen des Parsens</li></ul></div>
</div>



    








<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Error-Recovery</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>Umgang mit Fehlern ist im Compiler sehr wichtig: Falscher Code darf nicht in ein ausführbares Programm
umgewandelt werden oder ausgeführt werden, gleichzeitig erwarten Nutzer zielführende Fehlermeldungen
und auch das Erkennen von möglichst mehreren Fehlern in einem Lauf.</p>
<p>Auf der Ebene des Parsers kann man Fehler in Bezug auf die Grammatik erkennen. Typische Strategien sind
das Entfernen von Token aus dem Eingabestrom, bis wieder ein Token erscheint, welches die weitere Abarbeitung
der aktuellen Regel erlaubt (&quot;Synchronisierung&quot;). Dies sind oft Zeilenenden, ein Semikolon oder eine schließende
geschweifte Klammer. Dieses recht einfache, aber grobe Vorgehen kann verfeinert werden, indem man versucht,
überschüssige Token zu entfernen oder fehlender Token zu ersetzen. In ANTLR wird beispielsweise maximal ein
fehlendes Token virtuell &quot;ersetzt&quot; bzw. max. ein überschüssiges Token entfernt, damit man den restlichen Code
weiter parsen kann. Wenn mehr als ein Token fehlt oder zu viel ist, geht ANTLR in einen &quot;Panic Mode&quot; und
entfernt so lange Token aus dem Eingabestrom, bis das aktuelle Token in einem <em>Resynchronization Set</em> enthalten
ist. Die Bildung dieser Menge erinnert an die Regeln zum Bilden der <em>FOLLOW</em>-Mengen, ist aber an den Kontext
der &quot;aufgerufenen&quot; Parser-Regeln gebunden. Zusätzlich gibt es weitere Strategien zum Behandeln von Fehlern in
Schleifen sowie zur Vermeidung von Endlos-Fehlerbehebungsschleifen (&quot;Fail-Save&quot;). In Bison wird dagegen mit
einem speziellen <em>error</em>-Token gearbeitet und man fügt an &quot;strategischen&quot; Stellen Regeln der Form Regel 
<span class="math align-center">$A \to \operatorname{error} \alpha$</span> hinzu. Dabei ist 
<span class="math align-center">$\alpha$</span> ein Token, welches zur Synchronisierung genutzt werden
soll. Im Fehlerfall werden so lange Token vom Stack entfernt, bis man eine Regel 
<span class="math align-center">$A \to \operatorname{error} \alpha$</span> anwenden kann und das <em>error</em>-Token shiften kann. Danach werden ggf. so lange Token aus dem Eingabestrom
entfernt, bis das Token 
<span class="math align-center">$\alpha$</span> auftaucht und man die Regel mit einem <em>reduce</em> abschließen kann. Diese Form
der Behandlung stellt einen Kompromiss zwischen Aufwand (auch Zeit) und Nutzen dar.</p>
<p>Zusätzlich kann man in der Grammatik bereits typische Fehler (vergessene Klammern oder Typos wie Dreher bei
Schlüsselwörtern) schon über &quot;Fehlerproduktionen&quot; vorwegnehmen. Das bedeutet, dass man eine Regel formuliert,
die diesen typischen Tippfehler akzeptiert (und korrigiert), aber zusätzlich eine Warnung generiert. Es muss
dann aber jeweils entschieden werden, ob der entsprechende Quellcode in ein ausführbares Programm übersetzt
werden darf.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/9sFdI7pYMQs' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Error-Recovery</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/eabf5e829fbcd6be866e20b169989c8fef4fd10f13704999d0c1b531d15d4255975cd4490ac127156874d8334d6cade0ece8e2d15f2f2d34cb965a0c1697eade' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Error-Recovery</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K2) Varianten der Fehler bei Parsern</li> <li>(K2) Fehlerbehandlung bei LL-Parsern: <em>single token deletion</em>, <em>single token insertion</em>, <em>sync-and-return</em></li> <li>(K2) Berechnung und Anwendung des <em>Resynchronization Sets</em></li> <li>(K3) Ändern der Fehlermeldungen bei ANTLR</li> <li>(K3) Eigene Errorhandler in ANTLR-Parser bauen und einbinden</li> <li>(K3) Nutzen von speziellen Fehler-Alternativen in Grammatiken</li></ul></div>
</div>




    <h2 id="fehler-beim-parsen">Fehler beim Parsen</h2>
<p><a href="#R-image-90d978e2402caae0e611096874d121bb" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/bc_xml-parsing-error.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-90d978e2402caae0e611096874d121bb"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/bc_xml-parsing-error.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p><span class='origin'>Quelle: Vorlesung &quot;Einführung in die Programmierung mit Skriptsprachen&quot; by <a href="mailto:bc.george@hsbi.de">BC George</a> (<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC BY-SA 4.0</a>)</span></p>
<ul>
<li>Compiler ist ein schnelles Mittel zum Finden von (syntaktischen) Fehlern</li>
<li>Wichtige Eigenschaften:
<ul>
<li>Reproduzierbare Ergebnisse</li>
<li>Aussagekräftige Fehlermeldungen</li>
<li>Nach Erkennen eines Fehlers: (vorläufige) Korrektur und Parsen des restlichen Codes
=&gt; weitere Fehler anzeigen.
Problem: Bis wohin &quot;gobbeln&quot;, d.h. was als Synchronisationspunkt nehmen? Semikolon?</li>
<li>Syntaktisch fehlerhafte Programme dürfen nicht in die Zielsprache übersetzt werden!</li>
</ul>
</li>
</ul>
<h2 id="typische-fehler-beim-parsing">Typische Fehler beim Parsing</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span><span style="color:#66d9ef">grammar</span> <span style="color:#a6e22e">VarDef</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>alt   : stmt <span style="color:#f92672">|</span> stmt2 ;
</span></span><span style="display:flex;"><span>stmt  : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span> ;
</span></span><span style="display:flex;"><span>stmt2 : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span>  ;</span></span></code></pre></div><p><em>Anmerkung</em>: Die nachfolgenden Fehler werden am Beispiel der Grammatik
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery.html/src/VarDef.g4">VarDef.g4</a> und ANTLR demonstriert.</p>
<h3 id="lexikalische-fehler">Lexikalische Fehler</h3>
<p>Eingabe: <code>int x1;</code> (Startregel <code>stmt</code>)</p>
<p>Fehlermeldung: <code>token recognition error at: '1'</code></p>
<p>Die ist ein Fehler aus dem Lexer, wenn beim Erkennen eines Tokens ein komplett
unbekanntes Zeichen auftritt.</p>
<h3 id="ein-extra-token">Ein extra Token</h3>
<p>Eingabe: <code>int x y;</code> (Startregel <code>stmt</code>)</p>
<p>Fehlermeldung: <code>extraneous input 'y' expecting ';'</code></p>
<p>Wenn nur ein Token zu viel ist, dann kann der von ANTLR generierte Parser eine
passende Fehlermeldung ausgeben.</p>
<h3 id="mehrere-extra-token">Mehrere extra Token</h3>
<p>Eingabe: <code>int x y z;</code> (Startregel <code>stmt</code>)</p>
<p>Fehlermeldung: <code>mismatched input 'y' expecting ';'</code></p>
<p>Wenn dagegen mehr als ein Token zu viel ist, dann gibt der von ANTLR generierte
Parser eine generische Fehlermeldung aus.</p>
<h3 id="fehlendes-token">Fehlendes Token</h3>
<p>Eingabe: <code>int ;</code> (Startregel <code>stmt</code>)</p>
<p>Fehlermeldung: <code>missing ID at ';'</code></p>
<p>Ein anderer typischer Fehler sind fehlende Token, die kann der Parser analog zu
überzähligen Token erkennen und ausgeben.</p>
<h3 id="fehlendes-token-am-entscheidungspunkt">Fehlendes Token am Entscheidungspunkt</h3>
<p>Eingabe: <code>int ;</code> (Startregel <code>alt</code>)</p>
<p>Fehlermeldung: <code>no viable alternative at input 'int;'</code></p>
<p>Hier fehlt ein Token, aber an einer Stelle, wo sich der Parser zwischen zwei
Alternativen (Sub-Regeln) entscheiden muss.</p>
<h2 id="überblick-recovery-bei-parser-fehlern">Überblick Recovery bei Parser-Fehlern</h2>
<p><a href="#R-image-c7112418d2031833991c09dd1b1fca67" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/recovery.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c7112418d2031833991c09dd1b1fca67"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/recovery.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<ul>
<li>Fehler im Lexer (hier nicht weiter betrachtet):
<ul>
<li>Aktuelles Zeichen passt zu keinem Token: Entfernen oder Hinzufügen
von Zeichen (plus Rückmeldung an den Parser)</li>
<li>Spezielle Token, die typische fehlerhafte Zeichenketten als Token
erkennen (mit Weiterverarbeitung im Parser)</li>
</ul>
</li>
<li>Fehler im Parser:
<ul>
<li>Token passt nicht: Token entfernen oder ein Dummy-Token erzeugen</li>
<li>Panic-Mode: Entferne Token bis zu einem Synchronisationspunkt.
Problem: Dabei nicht zu weit zu springen!</li>
<li>Spezielle Fehlerproduktionen: Spezielle Regeln in der Grammatik,
die typische Fehler matchen.</li>
</ul>
</li>
</ul>
<p>Anmerkung LR-Parser: Ein Syntaxfehler wird entdeckt, wenn die Action-Tabelle
für Top-of-Stack und akt. Token leer ist =&gt; Stack und/oder Token modifizieren,
aber deutlich schwieriger als bei LL ...</p>
<h2 id="skizze-generierte-parser-regeln-antlr">Skizze: Generierte Parser-Regeln (ANTLR)</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt  : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span> ;</span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">stmt</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>: <span style="color:#66d9ef">match</span>(<span style="color:#e6db74">&#34;int&#34;</span>); <span style="color:#66d9ef">match</span>(ID); <span style="color:#66d9ef">match</span>(<span style="color:#e6db74">&#34;;&#34;</span>)
</span></span><span style="display:flex;"><span>    catch (RecognitionException re):
</span></span><span style="display:flex;"><span>        _errHandler<span style="color:#f92672">.</span>reportError(self)               <span style="color:#75715e"># let&#39;s report it</span>
</span></span><span style="display:flex;"><span>        _errHandler<span style="color:#f92672">.</span>recover(self)                   <span style="color:#75715e"># Panic-Mode</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">match</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> lookahead <span style="color:#f92672">==</span> x: consume()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: _errHandler<span style="color:#f92672">.</span>recoverInline(self)           <span style="color:#75715e"># Inline-Mode</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Der im Parser registrierte ErrorHandler erzeugt in der Methode
<code>reportError()</code> eine geeignete Meldung und gibt sie an den Parser
über dessen Methode <code>notifyErrorListeners()</code> weiter.</p>
<p>Die eigentliche Fehlerbehandlung findet in der Methode <code>recover()</code>
bzw. <code>recoverInline()</code> des ErrorHandlers statt.</p>
<h2 id="inline-recovery-bei-token-mismatch-skizze">Inline-Recovery bei Token-Mismatch (Skizze)</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">recoverInline</span>(parser):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># SINGLE TOKEN DELETION</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> singleTokenDeletion(parser):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> getMatchedSymbol(parser)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># SINGLE TOKEN INSERTION</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> singleTokenInsertion(parser):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> getMissingSymbol(parser)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># that didn&#39;t work, throw a new exception</span>
</span></span><span style="display:flex;"><span>    throw new InputMismatchException(parser)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Die Klasse <code>InputMismatchException</code> drückt aus, dass das aktuelle Token nicht
zur Erwartung des Parsers passt. Deshalb wird diese Exception am Ende von
<code>recoverInline()</code> geworfen. Die Klasse <code>RecognitionException</code>, die in den
Parserregeln wie <code>stmt</code> gefangen wird, ist die gemeinsame Oberklasse aller
Parser-Exceptions.</p>
<p>Liste der wichtigsten Exceptions (nach
<a href="https://github.com/antlr/antlr4/blob/master/doc/parser-rules.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/parser-rules.md</a>):</p>
<table>
<thead>
<tr>
<th style="text-align:left">Exception</th>
<th style="text-align:left">Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>RecognitionException</code></td>
<td style="text-align:left">Basisklasse für alle Parser-Exceptions</td>
</tr>
<tr>
<td style="text-align:left"><code>NoViableAltException</code></td>
<td style="text-align:left">Parser konnte sich nicht für (mind.) einen Pfad entscheiden angesichts des Tokenstroms</td>
</tr>
<tr>
<td style="text-align:left"><code>LexerNoViableAltException</code></td>
<td style="text-align:left">Lexer-Pendant zu <code>NoViableAltException</code></td>
</tr>
<tr>
<td style="text-align:left"><code>InputMismatchException</code></td>
<td style="text-align:left">Das aktuelle Token ist nicht das, was der Parser erwartet</td>
</tr>
</tbody>
</table>
<h2 id="panic-mode-sync-and-return-skizze">Panic Mode: Sync-and-Return (Skizze)</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rule</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>: <span style="color:#f92672">...</span> rule<span style="color:#f92672">-</span>body <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    catch (RecognitionException re):
</span></span><span style="display:flex;"><span>        _errHandler<span style="color:#f92672">.</span>reportError(self)       <span style="color:#75715e"># let&#39;s report it</span>
</span></span><span style="display:flex;"><span>        _errHandler<span style="color:#f92672">.</span>recover(self)           <span style="color:#75715e"># Panic-Mode</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>=&gt; Entferne solange Token, bis aktuelles Token im &quot;<em>Resynchronization Set</em>&quot;</p>
<h2 id="antlr-einsatz-des-resynchronization-set">ANTLR: Einsatz des &quot;<em>Resynchronization Set</em>&quot;</h2>
<ul>
<li><strong>Following Set</strong>: Menge der Token, die direkt auf eine Regel-Referenz folgen,
ohne dass die aktuelle Regel/Alternative verlassen wird</li>
<li><strong>Resynchronization Set</strong>: Vereinigung der <em>Following Sets</em> für alle Regeln im
aktuellen Aufruf-Stack</li>
</ul>
<p><span class='origin'>Quelle: nach <a href="#id_Parr2014">[Parr2014, pp. 161-163]</a></span></p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt : <span style="color:#e6db74">&#39;if&#39;</span> expr <span style="color:#e6db74">&#39;:&#39;</span> stmt           <span style="color:#75715e">// Following Set für &#34;expr&#34;: {&#39;:&#39;}</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;while&#39;</span> <span style="color:#e6db74">&#39;(&#39;</span> expr <span style="color:#e6db74">&#39;)&#39;</span> stmt ;  <span style="color:#75715e">// Following Set für &#34;expr&#34;: {&#39;)&#39;}</span>
</span></span><span style="display:flex;"><span>expr : term <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#66d9ef">INT</span> ;               <span style="color:#75715e">// Following Set für &#34;term&#34;: {&#39;+&#39;}</span></span></span></code></pre></div><ul>
<li>Eingabe: <code>if :</code></li>
<li>Aufruf-Stack nach Bearbeitung von <code>if</code>: <code>[stmt, expr, term]</code></li>
<li><strong>Resynchronization Set</strong>: <code>{'+', ':'}</code></li>
</ul>
<h3 id="hinweis-follow-hahahugoshortcode25s0hbhb-following">Hinweis: <em>FOLLOW</em> 
<span class="math align-center">$\ne$</span> <em>Following</em></h3>
<p><strong>FOLLOW</strong> ist die Menge aller Token, die auf eine Regel folgen können</p>
<ul>
<li><code>FOLLOW(term) = {'+'}</code></li>
<li><code>FOLLOW(expr) = {':', ')'}</code></li>
</ul>
<p><strong>Following</strong> ist dagegen <strong>abhängig vom aktuellen Kontext</strong>!</p>
<ul>
<li>Stack: <code>[stmt, expr, term]</code> =&gt; <em>Resynchronization Set</em>: <code>{'+', ':'}</code></li>
</ul>
<h3 id="beispiele-resynchronisation-im-panic-mode-antlr">Beispiele Resynchronisation im Panic Mode (ANTLR)</h3>
<p><strong>Hinweis</strong>: Die Regel <code>term</code> ist in obigem Beispiel nicht weiter detailliert. Hier wird
angenommen, dass das aktuelle Token <code>':'</code> nicht passt.</p>
<ul>
<li>Eingabe: <code>if :</code>
<ul>
<li>In Regel <code>term</code>: Token <code>':'</code> passt nicht
<ul>
<li><code>consume()</code>, bis aktuelles Token in <em>Resynchronization Set</em>: <code>{'+', ':'}</code>
(d.h. hier bleibt <code>':'</code> das aktuelle Token)</li>
<li>Rückkehr zu Regel <code>expr</code></li>
</ul>
</li>
<li>In Regel <code>expr</code>: Token <code>':'</code> passt nicht
<ul>
<li><code>consume()</code>, bis aktuelles Token in <em>Resynchronization Set</em>: <code>{':'}</code>
(d.h. hier bleibt <code>':'</code> das aktuelle Token)</li>
<li>Rückkehr zu Regel <code>stmt</code></li>
</ul>
</li>
<li>In Regel <code>stmt</code>: Token <code>':'</code> passt jetzt
<ul>
<li>Abschluss des Parsing (mit Fehlermeldung)</li>
</ul>
</li>
</ul>
</li>
<li>Eingabe: <code>if x + 42 ))):</code>
<ul>
<li>In Regel <code>stmt</code>: Token <code>')'</code> passt nicht
<ul>
<li><code>consume()</code>, bis aktuelles Token in <em>Resynchronization Set</em>: <code>{':'}</code> (d.h.
hier werden alle <code>')'</code> entfernt)</li>
</ul>
</li>
<li>In Regel <code>stmt</code>: Token <code>':'</code> passt jetzt
<ul>
<li>Abschluss des Parsing (mit Fehlermeldung)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="antlr-anmerkungen-fehlerbehandlung-in-sub-regeln">ANTLR: Anmerkungen Fehlerbehandlung in Sub-Regeln</h2>
<p>Bei Sub-Regeln (d.h. eine Regel enthält Alternativen) oder Schleifenkonstrukten
(d.h. eine Regel enthält <code>(...)*</code> oder <code>(...)+</code>) geht ANTLR etwas anders vor.</p>
<ol>
<li>
<p>Start einer Sub-Regel/Alternative: Versuch einer <em>single token deletion</em></p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># am Anfang einer Alternative oder Schleife</span>
</span></span><span style="display:flex;"><span>_errHandler<span style="color:#f92672">.</span>sync(self)</span></span></code></pre></div></li>
<li>
<p>Schleifenkonstrukte: <code>(...)*</code> oder <code>(...)+</code></p>
<p>Versuche, in der Schleife zu bleiben! Im Fehlerfall <code>consume()</code> bis</p>
<ul>
<li>Weitere Iteration der Schleife erkannt</li>
<li>Token, welches der Schleife folgt, erkannt</li>
<li>Token im <em>Resynchronization Set</em> des aktuellen Aufruf-Stacks</li>
</ul>
<p>Anmerkung: Im Prinzip entspricht dies dem <em>Panic Mode</em>, der Unterschied liegt
darin, bis wohin der Parser nach der Recovery in einer Funktion/Methode (Regel)
zurückspringt. D.h. wenn es verschiedene Möglichkeiten gibt, haben diese die
obige Priorisierung.</p>
</li>
<li>
<p>Fail-Save</p>
<p>Um Endlos-Schleifen durch die Schritte (1) bzw. (2) zu vermeiden, löst der Parser
beim zweiten Versuch, die selbe Parser-Stelle und Input-Position zu bearbeiten
(also bei bereits aktivem Fehler), einen &quot;<em>Fail-Safe</em>&quot; aus. Der Parser konsumiert
dann ein Token und fährt dann mit der Recovery fort.</p>
</li>
</ol>
<p>Zu Details zur Fehlerbehandlung durch ANTLR vergleiche <a href="#id_Parr2014">[Parr2014, S. 170 ff.]</a>.</p>
<h2 id="antlr-ändern-der-fehlerbehandlungs-strategie">ANTLR: Ändern der Fehlerbehandlungs-Strategie</h2>
<h3 id="ändern-der-fehlerbehandlungs-strategie-global">Ändern der Fehlerbehandlungs-Strategie (global)</h3>
<p><a href="#R-image-97eb931b5339c2b19b91d5ed721a6537" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/handler.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-97eb931b5339c2b19b91d5ed721a6537"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/handler.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Sie überschreiben die Klasse <code>DefaultErrorStrategy</code> und müssen die oben gezeigten Methoden
<code>recover()</code> und <code>recoverInline()</code>aufrufen. Die eigene Fehlerbehandlung setzen Sie über die
Methode <code>setErrorHandler</code> des Parsers.</p>
<h3 id="ändern-der-fehlerbehandlungs-strategie-lokal">Ändern der Fehlerbehandlungs-Strategie (lokal)</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>r : <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>  ;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">catch</span>[RecognitionException e] { throw e; }</span></span></code></pre></div><p>Es lassen sich auch andere bzw. mehrere Exceptions fangen. Der <code>catch</code>-Block ersetzt den
Default-<code>catch</code>-Block der generierten Methode. Das bedeutet, dass sich der geänderte Modus
nur für die eine Regel auswirkt.</p>
<h3 id="ändern-der-fehler-meldungen">Ändern der Fehler-Meldungen</h3>
<p><a href="#R-image-56aaad48c95fea35d49326363d96d71f" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/listener.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-56aaad48c95fea35d49326363d96d71f"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/listener.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Für einen eigenen Listener leitet man sinnvollerweise von <code>BaseErrorListener</code> ab und
überschreibt die leere Implementierung von <code>syntaxError()</code>.</p>
<p>Damit die Fehlermeldungen nicht mehrfach ausgegeben werden, entfernt man zunächst alle
Listener und fügt dann den eigenen hinzu, bevor man den Parser startet.</p>
<h2 id="panic-mode-in-bison-error-recovery">Panic Mode in Bison (Error Recovery)</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span>     { printf(&#34;%s\n&#34;, <span style="color:#960050;background-color:#1e0010">$</span>2); }
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> error <span style="color:#e6db74">&#39;\n&#39;</span>       { yyerror(); yyerrok; }
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p>Bison kennt ein spezielles Fehler-Token <code>error</code>. Dieses Token wird genutzt, um
einen Synchronisationspunkt in der Grammatik zu definieren, von dem aus man
<em>höchstwahrscheinlich</em> weiter parsen kann.</p>
<h3 id="parsen-mit-error-token">Parsen mit <em>error</em>-Token</h3>
<p>Der Parser wird mit diesen Produktionen generiert wie mit normalen Token auch.
Im Fehlerfall werden so lange Symbole vom Stack entfernt, bis eine Regel der
Form 
<span class="math align-center">$A \to \operatorname{error} \alpha$</span> anwendbar ist. Dann wird das Token
<code>error</code> auf den Stack geschoben und so lange Eingabe-Token gelesen und verworfen,
bis eines gefunden wird, welches auf das <code>error</code>-Token folgen kann. Dies nennt
Bison &quot;Resynchronisation&quot;. Anschließend wird im Recovery-Modus normal fortgefahren,
bis drei weitere Token auf den Stack geschoben wurden und damit der Recovery-Modus
verlassen wird. Falls bereits vorher weitere Fehler auftreten, werden diese nicht
separat gemeldet.</p>
<h3 id="anwendung-im-obigen-beispiel">Anwendung im obigen Beispiel</h3>
<p>Im obigen Beispiel ist die Regel <code>stmt : error '\n'</code> enthalten. Im Fehlerfall
werden die Symbole vom Stack entfernt, bis ein Zustand erreicht ist, der eine
Shift-Aktion auf das Token <code>error</code> hat. Das Error-Token wird auf den Stack
geschoben und alle Eingabetoken bis zum nächsten <code>'\n'</code> gelesen und direkt
entfernt. Mit dem Erreichen des Zeilenumbruchs wird die zugeordnete Aktion
ausgeführt. Diese gibt den Fehler auf der Konsole aus und führt mit dem Makro
<code>yyerrok</code> einen Reset des Parsers aus (d.h. er verlässt den Recovery-Modus
<strong>vor</strong> dem Shiften der per Default drei gültigen Token). Anschließend ist der
Bison-Parser wieder im normalen Modus. Die fehlerhaften Symbole/Token wurden
aus dem Eingabestrom entfernt.</p>
<h3 id="wo-kommen-die-error-token-am-besten-hin">Wo kommen die <em>error</em>-Token am besten hin?</h3>
<p>Die &quot;schwarze Kunst&quot; ist, die Error-Token an geeigneten Stellen unterzubringen,
d.h. vorherzusehen, wo der Parser am sinnvollsten wieder aufsetzen kann. Häufig
sind dies beispielsweise das ein Statement beendende Semikolon oder die einen
Block beendende schließende geschweifte Klammer. Beispielsweise könnte man für
die Sprache C bei der Definition von Statements mehrere Synchronisationspunkte
einbauen:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt : <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> error <span style="color:#e6db74">&#39;;&#39;</span>    <span style="color:#75715e">/* Synchronisation für &#39;return&#39; */</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> error <span style="color:#e6db74">&#39;}&#39;</span>    <span style="color:#75715e">/* Synchronisation nach Block */</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> error <span style="color:#e6db74">&#39;\n&#39;</span>   <span style="color:#75715e">/* Synchronisation nach Zeilenumbruch */</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><h3 id="bison-und-c-und-speichermanagement-im-fehlerfall">Bison und C und Speichermanagement im Fehlerfall</h3>
<p>Wenn Bison im Recovery-Modus ist, werden Symbole und ihre Werte vom Stack entfernt.
Falls diese Werte (vgl. <code>%union</code>) Pointer mit dynamisch alloziertem Speicher sind,
muss Bison diesen Speicher freigeben.</p>
<p>Dazu kann man sich über die Direktive <code>%destructor { code } symbols</code> oder
<code>%destructor { code } &lt;types&gt;</code> Code definieren, der dann für die jeweiligen Symbole
oder Typen ausgeführt wird.</p>
<p>Die Typangabe <code>&lt;*&gt;</code> dient dabei als Catch-All für Symbole, für die ein Typ definiert
wurde, aber kein Destruktor.</p>
<p>Beispiel:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">%</span>union {
</span></span><span style="display:flex;"><span>    char* str;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">%token</span> <span style="color:#960050;background-color:#1e0010">&lt;str&gt;</span> <span style="color:#960050;background-color:#1e0010">ID</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">%destructor</span> { free(<span style="color:#960050;background-color:#1e0010">$$</span>); } <span style="color:#960050;background-color:#1e0010">&lt;str&gt;</span></span></span></code></pre></div><p>Für weitere Details vergleiche <a href="#id_Levine2009">[Levine2009, Kap. 8]</a>.</p>
<h2 id="fehlerproduktionen">Fehlerproduktionen</h2>
<p>Häufig vorkommende Fehler kann man bereits in der Grammatik berücksichtigen.
Dadurch kommt es nicht zu einem Parser-Error mit Recovery-Mechanismus, sondern
der Fehler wird über eine entsprechende Alternative in der Grammatik korrigiert.</p>
<p>Es bietet sich an, in diesem Fall eine entsprechende Ausgabe zu tätigen. Dies
wird in der folgenden Grammatik über eingebettete Aktionen erledigt.</p>
<h3 id="antlr">ANTLR</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span>
</span></span><span style="display:flex;"><span>     : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span>             {notifyErrorListeners(&#34;Missing &#39;;&#39;&#34;);}
</span></span><span style="display:flex;"><span>     : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span> <span style="color:#e6db74">&#39;;&#39;</span>     {notifyErrorListeners(&#34;Too many &#39;;&#39;&#34;);}
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p>Der aus der Grammatik generierte Parser leitet von der Basisklasse <code>Parser</code>
ab. Dort wird eine Methode <code>notifyErrorListeners()</code> implementiert, die man
mit Hilfe von in die Grammatik eingebetteten Aktionen aufrufen kann (Vorgriff
auf <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/syntaxdriven.html">Syntaxgesteuerte Interpreter</a>).
Letztlich steht im generierten Parser in der generierten Methode <code>stmt()</code> an
der passenden Stelle ein Aufruf <code>notifyErrorListeners(Too many ';'&quot;);</code> ...</p>
<h3 id="flex-und-bison">Flex und Bison</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span>     { <span style="color:#960050;background-color:#1e0010">$$</span> = <span style="color:#960050;background-color:#1e0010">$</span>2; }
</span></span><span style="display:flex;"><span>     : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span>         { yyerror(&#34;unterminated id&#34;);
</span></span><span style="display:flex;"><span>                          <span style="color:#960050;background-color:#1e0010">$$</span> = <span style="color:#960050;background-color:#1e0010">$</span>2; }
</span></span><span style="display:flex;"><span>     ;
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">%%</span>
</span></span><span style="display:flex;"><span>void <span style="color:#960050;background-color:#1e0010">yyerror(char</span> <span style="color:#960050;background-color:#1e0010">*s,</span> <span style="color:#960050;background-color:#1e0010">...)</span> {
</span></span><span style="display:flex;"><span>    va_list ap; va_start(ap, s);
</span></span><span style="display:flex;"><span>    fprintf(stderr, &#34;%d: error: &#34;, yylineno);
</span></span><span style="display:flex;"><span>    vfprintf(stderr, s, ap); fprintf(stderr, &#34;\n&#34;);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Analog zu ANTLR ist es auch in Flex/Bison üblich, für typische Szenarien
&quot;nicht ganz korrekte&quot; Eingaben zu akzeptieren. Dazu definiert man zusätzliche
Lexer- oder Parser-Regeln, die diese Eingaben als das, was gemeint war akzeptieren
und eine zusätzliche Warnung ausgeben.</p>
<p>Dabei definiert man sich typischerweise die Funktion <code>yyerror()</code>. Über
<code>yytext</code> hat man Zugriff auf den Eingabetext des aktuellen Tokens, und
mit <code>yylineno</code> hat man Zugriff auf die aktuelle Eingabezeile (<code>yylineno</code>
wird automatisch bei jedem <code>\n</code> inkrementiert). Wenn man weitere Informationen
benötigt, muss man mit dem Bison-Feature &quot;Locations&quot; arbeiten. Dies ist ein
spezieller Datentyp <code>YYLTYPE</code>.</p>
<p>Für weitere Details vergleiche <a href="#id_Levine2009">[Levine2009, Kap. 8]</a>.</p>
<h2 id="anmerkung-nicht-eindeutige-grammatiken">Anmerkung: Nicht eindeutige Grammatiken</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stat: expr <span style="color:#e6db74">&#39;;&#39;</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span> ;
</span></span><span style="display:flex;"><span>expr: <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">INT</span> ;</span></span></code></pre></div><p>=&gt; Was passiert bei der Eingabe: <code>a+b</code> ??! Welche Regel/Alternative soll
jetzt matchen, d.h. welcher AST soll am Ende erzeugt werden?!</p>
<h3 id="antlr-1">ANTLR</h3>
<p>Nicht eindeutige Grammatiken führen <strong>nicht</strong> zu einer Fehlermeldung,
da nicht der Nutzer mit seiner Eingabe Schuld ist, sondern das Problem
in der Grammatik selbst steckt.</p>
<p>Während des Debuggings von Grammatiken lohnt es sich aber, diese
Warnungen zu aktivieren. Dies kann entweder mit der Option &quot;<code>-diagnostics</code>&quot;
beim Aufruf des <code>grun</code>-Tools geschehen oder über das Setzen des
<code>DiagnosticErrorListener</code> aus der ANTLR-Runtime als ErrorListener.</p>
<h3 id="bison">Bison</h3>
<p>Bison meldet nicht eindeutige Grammatiken beim Erzeugen des Parsers
(vgl. Shift/Reduce- und Reduce/Reduce-Konflikte) und entscheidet sich
jeweils für eine Operation (wobei Shift bevorzugt wird). Dies kann
man im über die Option <code>-v</code> erzeugten <code>&lt;name&gt;.output</code>-File überprüfen.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Fehler bei <code>match()</code>: <em>single token deletion</em> oder <em>single token insertion</em></p>
</li>
<li>
<p>Panic Mode: <em>sync-and-return</em> bis Token in <em>Resynchronization Set</em> (ANTLR)
oder <code>error</code>-Token shiftbar (Bison)</p>
<ul>
<li>ANTLR: Sonderbehandlung bei Start von Sub-Regeln und in Schleifen</li>
<li>ANTLR: Fail-Save zur Vermeidung von Endlosschleifen</li>
</ul>
</li>
<li>
<p>Fehler-Alternativen in Grammatik einbauen</p>
</li>
</ul>


    



    



    

    
<div class="box notices cstyle note">
  <div class="box-label"><i class="fas fa-puzzle-piece"></i> Challenges</div>
  <div class="box-content">

<ul>
<li>Erklären Sie, welche Fehler typischerweise beim Parsen auftreten können.</li>
<li>Wie reagiert der von ANTLR generierte LL-Parser auf typische Fehler?</li>
<li>Was sind &quot;Fehlerproduktionen&quot;, wozu sind sie gut?</li>
</ul>
</div>
</div>



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Levine2009'>[Levine2009] <strong>flex & bison</strong><br>Levine, J., O'Reilly, 2009. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-5961-5597-1' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-5961-5597-1</a>.<br><em>Kapitel 7 und 8</em></li> <li id='id_Parr2010'>[Parr2010] <strong>Language Implementation Patterns</strong><br>Parr, T., Pragmatic Bookshelf, 2010. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5645-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5645-6</a>.<br><em>Kapitel 2 und 3</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

          </section>
        </div>
      </main>
    </div>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/clipboard.min.js?1697015446" defer></script>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/perfect-scrollbar.min.js?1697015446" defer></script>
    <script>
      function useMathJax( config ){
        if( !Object.assign ){
          
          return;
        }
        window.MathJax = Object.assign( window.MathJax || {}, {
          loader: {
            load: ['[tex]/mhchem']
          },
          startup: {
            elements: [
              '.math'
            ]
          },
          tex: {
            inlineMath: [
              ['$', '$'], 
              ['\\(', '\\)']
            ]
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/mathjax/tex-mml-chtml.js?1697015446"></script>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/theme.js?1697015446" defer></script>
  </body>
</html>
