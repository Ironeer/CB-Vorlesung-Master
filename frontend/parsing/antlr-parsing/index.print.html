<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.119.0">
    <meta name="generator" content="Relearn 5.22.1">
    <meta name="description" content="">
    <meta name="author" content="cagix">
    <title>Parser mit ANTLR generieren</title>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing.html" rel="canonical" type="text/html" title="Parser mit ANTLR generieren">

    
    

    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/images/logo.png?1697015446" rel="icon" type="image/png">

    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fontawesome-all.min.css?1697015446" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fontawesome-all.min.css?1697015446" rel="stylesheet"></noscript>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/nucleus.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/auto-complete.css?1697015446" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/auto-complete.css?1697015446" rel="stylesheet"></noscript>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/perfect-scrollbar.min.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fonts.css?1697015446" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fonts.css?1697015446" rel="stylesheet"></noscript>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/theme.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/theme-auto.css?1697015446" rel="stylesheet" id="R-variant-style">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/variant.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/print.css?1697015446" rel="stylesheet" media="print">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/format-print.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/ie.css?1697015446" rel="stylesheet">
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/url.js?1697015446"></script>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/variant.js?1697015446"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/index.search.js";
      var root_url="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_Reset_view = 'Reset view';
      window.T_View_reset = 'View reset!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/www.hsbi.de\/elearning\/data\/FH-Bielefeld\/lm_data\/lm_1371719/';
      window.variants && variants.init( [ 'auto', 'zen-light', 'zen-dark', 'relearn-bright', 'relearn-light', 'relearn-dark' ] );
    </script><style type="text/css">

 
.center {
    align-content: center;
    text-align: center;
    margin: auto;
}
.alert {
    color: #ff3333;
}
.bsp {
    padding: 0.05cm;
    border-width: 0.05cm;
    border-style: solid;
    border-color: #ddd;
    background-color: #ddd;
    border-radius: 25px;
    float: right;
}
.cbox {
    padding: 0.2cm;
    border-width: 0.1cm;
    border-style: solid;
    border-color: #4070a0;
    background-color: #f2f2f2;
    margin: auto;
    width: 60%;
    text-align: center;
    overflow: auto;
}
.blueArrow {
    color: #4070a0;
    font-family: "Courier New", "Courier", monospace;
    font-weight: bold;
}
.origin {
    background-color: #ededed;
    font-size: 0.8em;
}
.showme {
    background-color: #ededed;
    font-size: 0.8em;
}


 
.tldr {
    background: #dbe4ed;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.recap {
    
    
   margin: 4px 0px 26px 0px;
}
.bib {
    background: #dbe4ed;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.outcomes {
    background: #d9e9d5;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.quizzes {
    background: #d9e9d5;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.challenges {
    background: #ebe4d6;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.assignments {
    background: #ebe4d6;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
h1.tldr, h1.recap, h1.bib, h1.outcomes, h1.quizzes, h1.challenges, h1.assignments {
    padding: 0px;
}


 
.noJsAlert {
    padding: 20px;
    background-color: #f44336;  
    color: white;
    margin-bottom: 15px;
}


 
.embed-video-player {
    position: relative;
    padding-bottom: 56%;
    height: 0;
    overflow: hidden;
}
.youtube-player {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border:0;
}


 
#header-wrapper {
    padding:0.6rem;
}


 
#shortcuts {
    padding-top: 2.0rem;
}


 
#chapter p {
    text-align: left;
}


 
figcaption h4 {
    margin-top:-2.5rem;
}
.border1 {
    border:1px solid black;
}

 
td ul, td ol {
    margin: 0 0 1rem 0.5rem;
    padding: 0 0 0 0.5rem;
}

 
h1 { font-size:2.8rem !important;}
h2 { font-size:2.2rem; margin:1.2rem 0}
h3 { font-size:1.9rem; text-align:left !important; font-weight:400 !important;}
h4 { font-size:1.6rem}
h5 { font-size:1.3rem}
h6 { font-size:1rem}

h2 {
    width:100% !important;
    border-bottom:1px solid #5e5e5e !important;
    padding-bottom: 2px;
}
.tldr h2, .recap h2, .bib h2, .outcomes h2, .quizzes h2, .challenges h2, .assignments h2 {
    margin:0.5rem 0
}

.btn-crossreference, .btn-crossreference:hover {
    cursor: initial;
}

</style>

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <span class="topbar-breadcrumbs highlightable">
            Parser mit ANTLR generieren
          </span>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable " tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
<h1>Parser mit ANTLR generieren</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>Mit ANTLR kann aus einer Grammatik ein LL(*)-Parser generiert werden. Die Parser-Regeln
in der Grammatik fangen dabei mit einem <strong>Kleinbuchstaben</strong> an (Erinnerung: Lexer-Regel
starten mit einem Großbuchstaben).</p>
<p>Regeln haben einen Namen (linke Seite) und eine Produktion (rechte Seite). Dabei
können beliebige Abfolgen von Lexer- und Parser-Regeln auf der rechten Seite
einer Parser-Regel auftauchen. Die Token müssen jeweils matchen, die Parser-Regeln
werden in einen Aufruf der jeweiligen generierten Funktion übersetzt.</p>
<p>Parser-Regeln können aus mehreren Alternativen bestehen, diese werden per <code>|</code> separiert.
Dabei hat bei Mehrdeutigkeiten die erste passende Alternative Vorrang. Wie bei Lexer-Regeln
können Teile per <code>?</code> ein- oder keinmal vorkommen, per <code>*</code> beliebig oft oder per <code>+</code> ein-
oder mehrfach.</p>
<p>ANTLR erlaubt im Gegensatz zu allgemeinen LL-Parsern direkte Links-Rekursion. (Indirekte
Links-Rekursion funktioniert allerdings nicht.)</p>
<p>Der von ANTLR generierte Parser erzeugt auf der Eingabe einen Parse-Tree, der die Strukturen
der Grammatik widerspiegelt: Die Token bilden die Blätter und jede erfolgreich durchlaufene
Parser-Regel bildet einen entsprechenden Knoten im Baum.</p>
<p>Für die Traversierung des Parse-Tree kann man die generierten Listener- oder Visitor-Klassen
nutzen. Beim Einsatz der Listener nutzt man die vorgegebene Klasse <code>ParseTreeWalker</code>, die
mit dem Parse-Tree und dem Listener den Baum per Tiefensuche traversiert und immer die
jeweiligen <code>enterRegel</code>- und <code>exitRegel</code>-Methoden aufruft. Beim Visitor muss die Traversierung
selbst erledigt werden, hier steht die aus der Klassenhierarchie geerbte Methode <code>visit</code>
als Startpunkt zur Verfügung. In dieser Methode wird basierend auf dem Knotentyp die in den
Visitor-Klassen implementierte <code>visitRegel</code>-Methode aufgerufen und man muss darauf achten,
die Kindknoten durch passende Aufrufe zu traversieren. Sowohl bei den generierten Listener-
als auch den Visitor-Klassen kann man die leeren Defaultmethoden bei Bedarf selbst überschreiben.
Für den Zugriff auf die Regel-Elemente werden die sogenannten Kontextobjekte als Parameter
übergeben.</p>
<p>Benannte Alternativen und Regel-Elemente sind nützlich, weil für die benannten Alternativen
zusätzliche Kontextklassen erzeugt werden, über die dann auf die Bestandteile der Alternativen
zugegriffen werden kann. Außerdem werden zusätzlich passende <code>enterAlternative</code>- und <code>exitAlternative</code>-
bzw. <code>visitAlternative</code>-Methoden generiert. Für benannte Regel-Elemente wird ein entsprechend
benanntes Attribut im Kontextobjekt angelegt, welches <code>public</code> sichtbar ist.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/YuUHBvPUS4k' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Parser mit ANTLR</a></li> <li><a href='https://youtu.be/FJOEPY-TMmw' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Demo ANTLR Parser</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/19925b756d6fc934bfe0b5107eb5fa58373a53af49c690ebce86e15f2b212c89c80ea7665e42c78abdc8dfe0718ea46f6a9817eeba4ad1293bdb4c84f7c8f084' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Parser mit ANTLR</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K2) Aufbau der Parser-Regeln</li> <li>(K3) Alternativen und optionale/mehrfache Regelteile in Parser-Regeln</li> <li>(K3) Vorrang von Alternativen (bei Mehrdeutigkeiten)</li> <li>(K3) Benannte Alternativen und Regel-Elemente</li> <li>(K2) Aufbau des Parse-Tree</li> <li>(K3) Umgang mit Kontext-Objekten</li> <li>(K3) Traversierung des Parse-Tree mit den generierten Listenern oder Visitors</li></ul></div>
</div>




    <h2 id="hello-world">Hello World</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span><span style="color:#66d9ef">grammar</span> <span style="color:#a6e22e">Hello</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>start : stmt<span style="color:#f92672">*</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>stmt  : <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> expr <span style="color:#e6db74">&#39;;&#39;</span> <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;;&#39;</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>expr  : term <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;+&#39;</span> term<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>term  : atom <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;*&#39;</span> atom<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>atom  : <span style="color:#66d9ef">ID</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">NUM</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ID    : [a-z][a-zA-Z]<span style="color:#f92672">*</span> ;
</span></span><span style="display:flex;"><span>NUM   : [0-9]<span style="color:#f92672">+</span> ;
</span></span><span style="display:flex;"><span>WS    : [ \t\n]<span style="color:#f92672">+</span> <span style="color:#f92672">-&gt;</span> skip ;</span></span></code></pre></div><div style="text-align: right;">
<span class="btn cstyle default">
  <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/lecture/frontend/parsing/src/Hello.g4" target="_blank">
    Konsole: Hello (grun, Parse-Tree)
  </a>
</span></div>
<h3 id="starten-des-parsers">Starten des Parsers</h3>
<ol>
<li>Grammatik übersetzen und Code generieren: <code>antlr Hello.g4</code></li>
<li>Java-Code kompilieren: <code>javac *.java</code></li>
<li>Parser ausführen:
<ul>
<li>
<p><code>grun Hello start -tree</code> oder <code>grun Hello start -gui</code> (Grammatik &quot;Hello&quot;, Startregel &quot;start&quot;)</p>
</li>
<li>
<p>Alternativ mit kleinem Java-Programm:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> org.antlr.v4.runtime.CharStreams<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.antlr.v4.runtime.CommonTokenStream<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.antlr.v4.runtime.tree.ParseTree<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        HelloLexer lexer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HelloLexer<span style="color:#f92672">(</span>CharStreams<span style="color:#f92672">.</span><span style="color:#a6e22e">fromStream</span><span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        CommonTokenStream tokens <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CommonTokenStream<span style="color:#f92672">(</span>lexer<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        HelloParser parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HelloParser<span style="color:#f92672">(</span>tokens<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ParseTree tree <span style="color:#f92672">=</span> parser<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>  <span style="color:#75715e">// Start-Regel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>tree<span style="color:#f92672">.</span><span style="color:#a6e22e">toStringTree</span><span style="color:#f92672">(</span>parser<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div></li>
</ul>
</li>
</ol>
<h3 id="startregeln">Startregeln</h3>
<ul>
<li><code>start</code> ist eine <span class='alert'>Parser-Regel</span>
=&gt; Eine Parser-Regel pro Grammatik wird benötigt, damit man den generierten
Parser am Ende auch starten kann ...</li>
<li>Alle Regeln mit kleinem Anfangsbuchstaben sind Parser-Regeln</li>
<li>Alle Regeln mit großem Anfangsbuchstaben sind Lexer-Regeln</li>
</ul>
<h3 id="formen-der-subregeln">Formen der Subregeln</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt  : <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> expr <span style="color:#e6db74">&#39;;&#39;</span> ;</span></span></code></pre></div><p>Um die Regel <code>stmt</code> anwenden zu können, müssen alle Elemente auf der rechten
Seite der Regel erfüllt werden. Dabei müssen die Token wie <code>ID</code>, <code>=</code> und <code>;</code>
matchen und die Subregel <code>expr</code> muss erfüllt werden können. Beachten Sie das
abschließende Semikolon am Ende einer ANTLR-Regel!</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt  : <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> expr <span style="color:#e6db74">&#39;;&#39;</span> <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;;&#39;</span> ;</span></span></code></pre></div><p>Alternativen werden durch ein <code>|</code> getrennt. Hier muss genau eine Alternative
erfüllt werden. Falls nötig, trennt man die Alternativen durch Einschließung
in runden Klammern vom Rest der Regel ab: <code>r : a (b | c) d ;</code>.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr  : term <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;+&#39;</span> term<span style="color:#f92672">)*</span> ;</span></span></code></pre></div><p>Der durch den <code>*</code> gekennzeichnete Teil kann beliebig oft vorkommen oder auch
fehlen. Bei einem <code>+</code> müsste der Teil mind. einmal vorkommen und bei einem
<code>?</code> entsprechend einmal oder keinmal.</p>
<p>Auch hier kann man die Operatoren durch ein zusätzliches <code>?</code> auf non-greedy
umschalten (analog zu den Lexer-Regeln).</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/parser-rules.md#subrules" target="_blank">github.com/antlr/antlr4/blob/master/doc/parser-rules.md</a>)</p>
<h3 id="reihenfolge-in-grammatik-definiert-priorität">Reihenfolge in Grammatik definiert Priorität</h3>
<p>Falls mehr als eine Parser-Regel die selbe Input-Sequenz matcht, löst ANTLR
diese Mehrdeutigkeit auf, indem es die erste Alternative nimmt, die an der
Entscheidung beteiligt ist.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>start : stmt ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>stmt  : expr <span style="color:#f92672">|</span> <span style="color:#66d9ef">ID</span>  ;
</span></span><span style="display:flex;"><span>expr  : <span style="color:#66d9ef">ID</span>   <span style="color:#f92672">|</span> <span style="color:#66d9ef">NUM</span> ;</span></span></code></pre></div><p>Bei der Eingabe &quot;foo&quot; würde die Alternative <code>ID</code> in der Regel <code>expr</code> &quot;gewinnen&quot;,
weil sie in der Grammatik vor der Alternative <code>ID</code> in der Regel <code>stmt</code> kommt und
damit Vorrang hat.</p>
<h3 id="parse-tree">Parse-Tree</h3>
<p>Betrachten wir erneut die obige Grammatik.</p>
<p>Die Eingabe von &quot;<code>a = 42;</code>&quot; führt zu folgendem Parse-Tree:</p>
<p><a href="#R-image-17460c670750a3d9f3dbfa72b9dc5905" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/hello_ex1.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-17460c670750a3d9f3dbfa72b9dc5905"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/hello_ex1.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Diese Eingabe führt zur Erkennung der Token <code>[ID, WS, =, WS, NUM, ;]</code>, wobei die
<code>WS</code>-Token verworfen werden und der Parser den Tokenstream <code>[ID, =, NUM, ;]</code>
erhält.</p>
<p>Die Startregel hat auf der rechten Seite kein oder mehrere <code>stmt</code>-Regeln. Die
<code>stmt</code>-Regel fordert auf der rechten Seite entweder die Token <code>ID</code>und <code>=</code> sowie
die Regel <code>expr</code> gefolgt vom Token <code>;</code>, oder die Regel <code>expr</code> gefolgt vom Token
<code>;</code>. In unserem Beispiel kann für das &quot;a&quot; das Token <code>ID</code> produziert werden, das
&quot;=&quot; matcht ebenfalls. Die &quot;42&quot; wird erklärt, indem für <code>expr</code> ein <code>term</code> und
dort ein <code>atom</code> aufgerufen wird. Für das <code>atom</code> muss entweder ein Token <code>ID</code>
oder <code>NUM</code> als nächstes Token kommen - hier wird die &quot;42&quot; wird als Token <code>NUM</code>
verarbeitet. Da die weiteren Regelteile in <code>term</code> und <code>expr</code> optional sind,
haben wir damit ein <code>expr</code> erfüllt und das nachfolgende <code>;</code>-Token schließt die
erste Alternative der Regel <code>stmt</code> erfolgreich ab.</p>
<p>Im entstehenden Parse-Tree sind diese Abläufe und grammatikalischen Strukturen
direkt erkennbar. Jede erfolgreich durchlaufene Parserregel wird zu einem
Knoten im Parse-Tree. Die Token werden als Terminale (Blätter) in den Baum
eingehängt.</p>
<p><em>Anmerkung</em>: Der Parse-Tree ist das Ergebnis der Parsers-Phase im Compiler und
dient damit als Input für die folgenden Compilerstufen. In der Regel benötigt
man die oft recht komplexen Strukturen aber später nicht mehr und vereinfacht
den Baum zu einem <em>Abstract Syntax Tree</em> (AST). Im Beispiel könnte man den Zweig
<code>stmt - expr - term - atom - 42</code> zu <code>stmt - 42</code> vereinfachen.</p>
<p>Betrachten wir nun die Eingabe <code>foo = 2+3*4; bar = 3*4+2;</code>. Diese führt zu
folgendem Parse-Tree:</p>
<p><a href="#R-image-5f78916b80c3433210ac1f091312c713" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/hello_ex2.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5f78916b80c3433210ac1f091312c713"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/hello_ex2.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Wie man sehen kann, sind in der Grammatik die üblichen Vorrangregeln für die
Operationen <code>+</code> und <code>*</code> berücksichtigt - die Multiplikation wird in beiden
Fällen korrekt &quot;unter&quot; der Addition im Baum eingehängt.</p>
<h3 id="to-eof-not-to-eof">To EOF not to EOF?</h3>
<p>Startregeln müssen nicht unbedingt den gesamten Input &quot;konsumieren&quot;. Sie müssen
per Default nur eine der Alternativen in der Startregel erfüllen.</p>
<p>Betrachten wir noch einmal einen leicht modifizierten Ausschnitt aus der obigen
Grammatik:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>start : stmt ;</span></span></code></pre></div><p>Die Startregel wurde so geändert, dass sie nur noch genau ein Statement
akzeptieren soll.</p>
<p>In diesem Fall würde die Startregel bei der Eingabe &quot;aa; bb;&quot; nur den ersten
Teil &quot;aa;&quot; konsumieren (als Token <code>ID</code>) und das folgende &quot;bb;&quot; ignorieren.
Das wäre in diesem Fall aber auch kein Fehler.</p>
<p>Wenn der gesamte Eingabestrom durch die Startregel erklärt werden soll,
dann muss das vordefinierte Token <code>EOF</code> am Ende der Startregel eingesetzt
werden:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>start : stmt <span style="color:#66d9ef">EOF</span>;</span></span></code></pre></div><p>Hier würde die Eingabe &quot;aa; bb;&quot; zu einem Fehler führen, da nur der Teil &quot;aa;&quot;
durch die Startregel abgedeckt ist (Token <code>ID</code>), und der Rest &quot;bb;&quot; zwar sogar
ein gültiges Token wären (ebenfalls <code>ID</code> und <code>;</code>), aber eben nicht mehr von der
Startregel akzeptiert. Durch das <code>EOF</code> soll die Startregel aber den gesamten
Input konsumieren und erklären, was hier nicht geht und entsprechend zum Fehler
führt.</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/parser-rules.md#start-rules-and-eof" target="_blank">github.com/antlr/antlr4/blob/master/doc/parser-rules.md</a>)</p>
<h2 id="expressions-und-vorrang-operatoren">Expressions und Vorrang (Operatoren)</h2>
<p>Betrachten wir noch einmal den Ausschnitt für die Ausdrücke (<em>Expressions</em>) in
der obigen Beispielgrammatik:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr  : term <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;+&#39;</span> term<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>term  : atom <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;*&#39;</span> atom<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>atom  : <span style="color:#66d9ef">ID</span> ;</span></span></code></pre></div><p>Diese typische, etwas komplex anmutende Struktur soll sicher stellen, dass die
Vorrangregeln für Addition und Multiplikation korrekt beachtet werden, d.h. dass
<code>2+3*4</code> als <code>2+(3*4)</code> geparst wird und nicht fälschlicherweise als <code>(2+3)*4</code>
erkannt wird.</p>
<p>Zusätzlich muss bei LL-Parsern Links-Rekursion vermieden werden: Die Parser-Regeln
werden in Funktionsaufrufe übersetzt, d.h. bei einer Links-Rekursion würde man die
selbe Regel immer wieder aufrufen, ohne ein Token aus dem Token-Strom zu entnehmen.</p>
<p>ANTLR (ab Version 4) kann mit beiden Aspekten automatisch umgehen:</p>
<ul>
<li>ANTLR kann direkte Linksrekursion automatisch auflösen. Die Regel <code>r : r T U | V ;</code>
kann also in ANTLR verarbeitet werden.</li>
<li>ANTLR besitzt einen Mechanismus zur Auflösung von Mehrdeutigkeiten. Wie oben
geschrieben, wird bei der Anwendbarkeit von mehreren Alternativen die erste
Alternative genutzt.</li>
</ul>
<p>Damit lässt sich die typische Struktur für Expression-Grammatiken deutlich lesbarer
gestalten:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr  : expr <span style="color:#e6db74">&#39;*&#39;</span> expr
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;+&#39;</span> expr
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#66d9ef">ID</span>
</span></span><span style="display:flex;"><span>      ;</span></span></code></pre></div><p>Die Regel <code>expr</code> ist links-rekursiv, was normalerweise bei LL-Parsern problematisch
ist. ANTLR löst diese Links-Rekursion automatisch auf (vgl.
<a href="https://github.com/antlr/antlr4/blob/master/doc/left-recursion.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/left-recursion.md</a>).</p>
<p>Da bei Mehrdeutigkeit in der Grammatik, also bei der Anwendbarkeit mehrerer Alternativen
stets die erste Alternative genommen wird, lassen sich die Vorrangregeln durch die
Reihenfolge der Alternativen in der <code>expr</code>-Regel implementieren: Die Multiplikation
hat Vorrang von der Addition, und diese hat wiederum Vorrang von einer einfachen <code>ID</code>.</p>
<h3 id="direkte-vs-indirekte-links-rekursion">Direkte vs. indirekte Links-Rekursion</h3>
<p>ANTLR kann nur <em>direkte</em> Links-Rekursion auflösen. Regeln wie <code>r : r T U | V ;</code> stellen
in ANTLR also kein Problem dar.</p>
<p><em>Indirekte</em> Links-Rekursion erkennt ANTLR dagegen nicht:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>r : s <span style="color:#66d9ef">T</span> <span style="color:#66d9ef">U</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">V</span> ;
</span></span><span style="display:flex;"><span>s : r <span style="color:#66d9ef">W</span> <span style="color:#66d9ef">X</span> ;</span></span></code></pre></div><p>Hier würden sich die Regeln <code>r</code> und <code>s</code> gegenseitig aufrufen und kein Token aus dem
Tokenstrom entfernen, so dass der generierte LL-Parser hier in einer Endlosschleife
stecken bleiben würde. Mit indirekter Links-Rekursion kann ANTLR nicht umgehen.</p>
<h3 id="konflikte-in-regeln">Konflikte in Regeln</h3>
<p>Wenn mehrere Alternativen einer Regel anwendbar sind, entscheidet sich ANTLR für die
erste Alternative.</p>
<p>Wenn sich mehrere Tokenregeln überlappen, &quot;gewinnt&quot; auch hier die zuerst definierte
Regel.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>def : <span style="color:#e6db74">&#39;func&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;(&#39;</span> <span style="color:#e6db74">&#39;)&#39;</span> block ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>FOR : <span style="color:#e6db74">&#39;for&#39;</span> ;
</span></span><span style="display:flex;"><span>ID  : [a-z][a-zA-Z]<span style="color:#f92672">*</span> ;</span></span></code></pre></div><p>Hier werden ein implizites Token <code>'func'</code> sowie die expliziten Token <code>FOR</code> und <code>ID</code>
definiert. Dabei sind die Lexeme für <code>'func'</code> und <code>FOR</code> auch in <code>ID</code> enthalten.
Dennoch werden <code>'func'</code> und <code>FOR</code> erkannt und nicht über <code>ID</code> gematcht, weil sie
<em>vor</em> der Regel <code>ID</code> definiert sind.</p>
<p>Tatsächlich sortiert ANTLR die Regeln intern um, so dass alle Parser-Regeln <em>vor</em> den
Lexer-Regeln definiert sind. Die impliziten Token werden dabei noch vor den expliziten
Token-Regeln angeordnet. Im obigen Beispiel hat also <code>'func'</code> eine höhere Priorität
als <code>FOR</code>, und <code>FOR</code> hat eine höhere Priorität als <code>ID</code>. Aus diesem Grund gibt es die
Konvention, die Parser-Regeln in der Grammatik vor den Lexer-Regeln zu definieren - dies
entspricht quasi der Anordnung, die ANTLR bei der Verarbeitung sowieso erzeugen würde.</p>
<p>Aus diesem Grund würde auch eine Umsortierung der obigen Grammatik funktionieren:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>FOR : <span style="color:#e6db74">&#39;for&#39;</span> ;
</span></span><span style="display:flex;"><span>ID  : [a-z][a-zA-Z]<span style="color:#f92672">*</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def : <span style="color:#e6db74">&#39;func&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;(&#39;</span> <span style="color:#e6db74">&#39;)&#39;</span> block ;</span></span></code></pre></div><p>Intern würde ANTLR die Parser-Regel <code>def</code> wieder vor den beiden Lexer-Regeln anordnen,
und zwischen den Parser-Regeln und den Lexer-Regeln die impliziten Token (hier <code>'func'</code>).</p>
<h2 id="kontext-objekte-für-parser-regeln">Kontext-Objekte für Parser-Regeln</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>s    : expr         {List&lt;EContext&gt; x = $expr.ctx.e();}
</span></span><span style="display:flex;"><span>     ;
</span></span><span style="display:flex;"><span>expr : e <span style="color:#e6db74">&#39;*&#39;</span> e ;</span></span></code></pre></div><p><a href="#R-image-9ab78d8370d1b91852d454d9b51156ca" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParserRuleContext.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9ab78d8370d1b91852d454d9b51156ca"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParserRuleContext.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Jede Regel liefert ein passend zu dieser Regel generiertes Kontext-Objekt
zurück. Darüber kann man das/die Kontextobjekt(e) der Sub-Regeln abfragen.</p>
<p>Die Regel <code>s</code> liefert entsprechend ein <code>SContext</code>-Objekt und die Regel
<code>expr</code> liefert ein <code>ExprContext</code>-Objekt zurück.</p>
<p>In der Aktion fragt man das Kontextobjekt über <code>ctx</code> ab, in den Listener-
und Visitor-Methoden erhält man die Kontextobjekte als Parameter.</p>
<p>Für einfache Regel-Aufrufe liefert die parameterlose Methode nur ein
einziges Kontextobjekt (statt einer Liste) zurück.</p>
<p><strong>Anmerkung</strong>: ANTLR generiert nur dann <em>Felder</em> für die Regel-Elemente im
Kontextobjekt, wenn diese in irgendeiner Form referenziert werden. Dies
kann beispielsweise durch Benennung (Definition eines Labels, siehe nächste
Folie) oder durch Nutzung in einer Aktion (siehe obiges Beispiel) geschehen.</p>
<h2 id="benannte-regel-elemente-oder-alternativen">Benannte Regel-Elemente oder Alternativen</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stat  : <span style="color:#e6db74">&#39;return&#39;</span> value<span style="color:#f92672">=</span>e <span style="color:#e6db74">&#39;;&#39;</span>    <span style="color:#f92672">#</span> <span style="color:#66d9ef">Return</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;break&#39;</span> <span style="color:#e6db74">&#39;;&#39;</span>             <span style="color:#f92672">#</span> <span style="color:#66d9ef">Break</span>
</span></span><span style="display:flex;"><span>      ;</span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StatContext</span> <span style="color:#66d9ef">extends</span> ParserRuleContext <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReturnContext</span> <span style="color:#66d9ef">extends</span> StatContext <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> EContext value<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> EContext <span style="color:#a6e22e">e</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BreakContext</span> <span style="color:#66d9ef">extends</span> StatContext <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span></span></span></code></pre></div><p>Mit <code>value=e</code> wird der Aufruf der Regel <code>e</code> mit dem Label <code>value</code> belegt,
d.h. man kann mit <code>$e.text</code> oder <code>$value.text</code> auf das <code>text</code>-Attribut von
<code>e</code> zugreifen. Falls es in einer Produktion mehrere Aufrufe einer anderen
Regel gibt, <strong>muss</strong> man für den Zugriff auf die Attribute eindeutige Label
vergeben.</p>
<p>Analog wird für die beiden Alternativen je ein eigener Kontext erzeugt.</p>
<h2 id="arbeiten-mit-antlr-listeners">Arbeiten mit ANTLR-Listeners</h2>
<p>ANTLR (generiert auf Wunsch) zur Grammatik passende Listener (Interface und
leere Basisimplementierung). Beim Traversieren mit dem Default-<code>ParseTreeWalker</code>
wird der Parse-Tree mit Tiefensuche abgelaufen und jeweils beim Eintritt in
bzw. beim Austritt aus einen/m Knoten der passende Listener mit dem passenden
Kontext-Objekt aufgerufen.</p>
<p>Damit kann man die Grammatik &quot;für sich&quot; halten, d.h. unabhängig von einer
konkreten Zielsprache und die Aktionen über die Listener (oder Visitors, s.u.)
ausführen.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;*&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">MULT</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;+&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">ADD</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">DIGIT</span>                    <span style="color:#f92672">#</span> <span style="color:#66d9ef">ZAHL</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p>ANTLR kann zu dieser Grammatik <code>calc.g4</code> einen passenden Listener (Interface
<code>calcListener</code>) generieren (Option <code>-listener</code> beim Aufruf von <code>antlr</code>).
Weiterhin generiert ANTLR eine leere Basisimplementierung (Klasse <code>calcBaseListener</code>):</p>
<p><a href="#R-image-d24621cefc1dbfeb9e6d3b7bbdd0a076" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParseTreeListener.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d24621cefc1dbfeb9e6d3b7bbdd0a076"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParseTreeListener.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>(Nur &quot;interessante&quot; Methoden gezeigt.)</p>
<p>Von dieser Basisklasse leitet man einen eigenen Listener ab und implementiert
die Methoden, die man benötigt.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyListener</span> <span style="color:#66d9ef">extends</span> calcBaseListener <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exitMULT</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">MULTContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exitADD</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">ADDContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exitZAHL</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">ZAHLContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div><p>Anschließend baut man das alles in eine Traversierung des Parse-Trees ein:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestMyListener</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyListener</span> <span style="color:#66d9ef">extends</span> calcBaseListener <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        calcLexer lexer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcLexer<span style="color:#f92672">(</span>CharStreams<span style="color:#f92672">.</span><span style="color:#a6e22e">fromStream</span><span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        CommonTokenStream tokens <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CommonTokenStream<span style="color:#f92672">(</span>lexer<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        calcParser parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcParser<span style="color:#f92672">(</span>tokens<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ParseTree tree <span style="color:#f92672">=</span> parser<span style="color:#f92672">.</span><span style="color:#a6e22e">s</span><span style="color:#f92672">();</span>    <span style="color:#75715e">// Start-Regel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        ParseTreeWalker walker <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ParseTreeWalker<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        MyListener eval <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyListener<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        walker<span style="color:#f92672">.</span><span style="color:#a6e22e">walk</span><span style="color:#f92672">(</span>eval<span style="color:#f92672">,</span> tree<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div><div style="text-align: right;">
<span class="btn cstyle default">
  <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/lecture/frontend/parsing/src/TestMyListener.java" target="_blank">
    Beispiel: TestMyListener.java und calc.g4
  </a>
</span></div>
<p>In <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/syntaxdriven.html">Syntaxgesteuerte Interpreter</a>
werden wir damit einen einfachen syntaxgesteuerten Interpreter aufbauen.</p>
<h2 id="arbeiten-mit-dem-visitor-pattern">Arbeiten mit dem Visitor-Pattern</h2>
<p>ANTLR (generiert ebenfalls auf Wunsch) zur Grammatik passende Visitoren
(Interface und leere Basisimplementierung).</p>
<p>Hier muss man im Gegensatz zu den Listeners allerdings selbst für eine geeignete
Traversierung des Parse-Trees sorgen. Dafür hat man mehr Freiheiten im Vergleich
zum Einsatz von Listeners, insbesondere im Hinblick auf Rückgabewerte.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;*&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">MULT</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;+&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">ADD</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">DIGIT</span>                    <span style="color:#f92672">#</span> <span style="color:#66d9ef">ZAHL</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p>ANTLR kann zu dieser Grammatik einen passenden Visitor (Interface <code>calcVisitor&lt;T&gt;</code>)
generieren (Option <code>-visitor</code> beim Aufruf von <code>antlr</code>). Weiterhin generiert ANTLR
eine leere Basisimplementierung (Klasse <code>calcBaseVisitor&lt;T&gt;</code>):</p>
<p><a href="#R-image-114f335f30d84c9819ebc2bf736e2cc3" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParseTreeVisitor.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-114f335f30d84c9819ebc2bf736e2cc3"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParseTreeVisitor.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>(Nur &quot;interessante&quot; Methoden gezeigt.)</p>
<p>Von dieser Basisklasse leitet man einen eigenen Visitor ab und überschreibt
die Methoden, die man benötigt. Wichtig ist, dass man selbst für das &quot;Besuchen&quot;
der Kindknoten sorgen muss (rekursiver Aufruf der geerbten Methode <code>visit()</code>).</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyVisitor</span> <span style="color:#66d9ef">extends</span> calcBaseVisitor<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">visitMULT</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">MULTContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">visitADD</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">ADDContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">visitZAHL</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">ZAHLContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div><p>Anschließend baut man das alles in eine manuelle Traversierung des Parse-Trees ein:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestMyVisitor</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyVisitor</span> <span style="color:#66d9ef">extends</span> calcBaseVisitor<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        calcLexer lexer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcLexer<span style="color:#f92672">(</span>CharStreams<span style="color:#f92672">.</span><span style="color:#a6e22e">fromStream</span><span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        CommonTokenStream tokens <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CommonTokenStream<span style="color:#f92672">(</span>lexer<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        calcParser parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcParser<span style="color:#f92672">(</span>tokens<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ParseTree tree <span style="color:#f92672">=</span> parser<span style="color:#f92672">.</span><span style="color:#a6e22e">s</span><span style="color:#f92672">();</span>    <span style="color:#75715e">// Start-Regel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        MyVisitor eval <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyVisitor<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        eval<span style="color:#f92672">.</span><span style="color:#a6e22e">visit</span><span style="color:#f92672">(</span>tree<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div><div style="text-align: right;">
<span class="btn cstyle default">
  <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/lecture/frontend/parsing/src/TestMyVisitor.java" target="_blank">
    Beispiel: TestMyVisitor.java und calc.g4
  </a>
</span></div>
<p>In <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/syntaxdriven.html">Syntaxgesteuerte Interpreter</a>
werden wir damit einen einfachen syntaxgesteuerten Interpreter aufbauen.</p>
<h2 id="eingebettete-aktionen-und-attribute">Eingebettete Aktionen und Attribute</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>s   : expr                      {System.err.println($expr.v);}
</span></span><span style="display:flex;"><span>    ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>expr <span style="color:#66d9ef">returns</span> [int v]
</span></span><span style="display:flex;"><span>    : e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;*&#39;</span> e2<span style="color:#f92672">=</span>expr       {$v = $e1.v * $e2.v;}
</span></span><span style="display:flex;"><span>    ;</span></span></code></pre></div><p>Auch die Parser-Regeln können mit eingebetteten Aktionen ergänzt werden, die
in die (für die jeweilige Regel) generierte Methode eingefügt werden und bei
erfolgreicher Anwendung der Parser-Regel ausgeführt werden.</p>
<p>Über <code>returns [int v]</code> fügt man der Regel <code>expr</code> ein Attribut <code>v</code> (Integer)
hinzu, welches man im jeweiligen Kontext abfragen bzw. setzen kann (agiert
als Rückgabewert der generierten Methode). Auf diesen Wert kann in den
Aktionen mit <code>$v</code> zugegriffen werden.</p>
<p>In <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/attribgrammars.html">Attributierte Grammatiken</a>
werfen wir einen genaueren Blick auf die attributierten Grammatiken. In
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/syntaxdriven.html">Syntaxgesteuerte Interpreter</a>
werden wir eingebettete Aktionen und Attribute nutzen, um einen einfachen
syntaxgesteuerten Interpreter aufzubauen.</p>
<p><em>Anmerkung</em>: Durch den Einsatz von eingebetteten Aktionen und Attributen wird
die Grammatik abhängig von der Zielsprache des generierten Lexers/Parsers!</p>
<h2 id="ausblick">Ausblick</h2>
<p>Damit haben wir die sprichwörtliche &quot;Spitze des Eisbergs&quot; gesehen. Mit ANTLR
sind noch viele weitere Dinge möglich. Bitte nutzen Sie aktiv die Dokumentation
auf <a href="https://github.com/antlr/antlr4" target="_blank">github.com/antlr/antlr4</a>.</p>
<p>Mit Hilfe von semantischen Prädikaten (vgl.
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html">LL-Parser: Fortgeschrittene Techniken</a>)
können Parser-Regeln aktiviert oder abgeschaltet werden, je nachdem, was vorher
gesehen wurde.</p>
<p>Dem Thema Behandlung von Fehlern ist eine eigene Sitzung gewidmet:
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery.html">Error-Recovery</a>.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<p>Parser mit ANTLR generieren: Parser-Regeln werden mit <strong>Kleinbuchstaben</strong> geschrieben</p>
<ul>
<li>Regeln können Lexer- und Parser-Regeln &quot;aufrufen&quot;</li>
<li>Regeln können Alternativen haben</li>
<li>Bei Mehrdeutigkeit: Vorrang für erste Alternative</li>
<li>ANTLR erlaubt direkte Links-Rekursion</li>
<li>ANTLR erzeugt Parse-Tree</li>
<li>Benannte Alternativen und Regel-Elemente</li>
<li>Traversierung des Parse-Tree: Listener oder Visitoren, Zugriff auf Kontextobjekte</li>
</ul>


    



    



    

    
<div class="box notices cstyle note">
  <div class="box-label"><i class="fas fa-puzzle-piece"></i> Challenges</div>
  <div class="box-content">

<p><strong>Lexer und Parser mit ANTLR: Programmiersprache Lox</strong></p>
<p>Betrachten Sie folgenden Code-Schnipsel in der Sprache <a href="https://www.craftinginterpreters.com/the-lox-language.html" target="_blank">&quot;Lox&quot;</a>:</p>
<pre><code>fun fib(x) {
    if (x == 0) {
        return 0;
    } else {
        if (x == 1) {
            return 1;
        } else {
            fib(x - 1) + fib(x - 2);
        }
    }
}

var wuppie = fib(4);
</code></pre>
<p>Erstellen Sie für diese fiktive Sprache einen Lexer+Parser mit ANTLR.</p>
<p>(Die genauere Sprachdefinition finden Sie bei Bedarf unter <a href="https://www.craftinginterpreters.com/the-lox-language.html" target="_blank">craftinginterpreters.com/the-lox-language.html</a>.)</p>
</div>
</div>



    





    




    
    
        
        

        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

        </div>
      </main>
    </div>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/clipboard.min.js?1697015446" defer></script>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/perfect-scrollbar.min.js?1697015446" defer></script>
    <script>
      function useMathJax( config ){
        if( !Object.assign ){
          
          return;
        }
        window.MathJax = Object.assign( window.MathJax || {}, {
          loader: {
            load: ['[tex]/mhchem']
          },
          startup: {
            elements: [
              '.math'
            ]
          },
          tex: {
            inlineMath: [
              ['$', '$'], 
              ['\\(', '\\)']
            ]
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/mathjax/tex-mml-chtml.js?1697015446"></script>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/theme.js?1697015446" defer></script>
  </body>
</html>
