<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.119.0">
    <meta name="generator" content="Relearn 5.22.1">
    <meta name="description" content="">
    <meta name="author" content="cagix">
    <title>Frontend</title>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend.html" rel="canonical" type="text/html" title="Frontend">

    
    

    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/images/logo.png?1697015446" rel="icon" type="image/png">

    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fontawesome-all.min.css?1697015446" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fontawesome-all.min.css?1697015446" rel="stylesheet"></noscript>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/nucleus.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/auto-complete.css?1697015446" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/auto-complete.css?1697015446" rel="stylesheet"></noscript>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/perfect-scrollbar.min.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fonts.css?1697015446" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fonts.css?1697015446" rel="stylesheet"></noscript>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/theme.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/theme-auto.css?1697015446" rel="stylesheet" id="R-variant-style">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/variant.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/print.css?1697015446" rel="stylesheet" media="print">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/format-print.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/ie.css?1697015446" rel="stylesheet">
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/url.js?1697015446"></script>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/variant.js?1697015446"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/index.search.js";
      var root_url="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_Reset_view = 'Reset view';
      window.T_View_reset = 'View reset!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/www.hsbi.de\/elearning\/data\/FH-Bielefeld\/lm_data\/lm_1371719/';
      window.variants && variants.init( [ 'auto', 'zen-light', 'zen-dark', 'relearn-bright', 'relearn-light', 'relearn-dark' ] );
    </script><style type="text/css">

 
.center {
    align-content: center;
    text-align: center;
    margin: auto;
}
.alert {
    color: #ff3333;
}
.bsp {
    padding: 0.05cm;
    border-width: 0.05cm;
    border-style: solid;
    border-color: #ddd;
    background-color: #ddd;
    border-radius: 25px;
    float: right;
}
.cbox {
    padding: 0.2cm;
    border-width: 0.1cm;
    border-style: solid;
    border-color: #4070a0;
    background-color: #f2f2f2;
    margin: auto;
    width: 60%;
    text-align: center;
    overflow: auto;
}
.blueArrow {
    color: #4070a0;
    font-family: "Courier New", "Courier", monospace;
    font-weight: bold;
}
.origin {
    background-color: #ededed;
    font-size: 0.8em;
}
.showme {
    background-color: #ededed;
    font-size: 0.8em;
}


 
.tldr {
    background: #dbe4ed;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.recap {
    
    
   margin: 4px 0px 26px 0px;
}
.bib {
    background: #dbe4ed;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.outcomes {
    background: #d9e9d5;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.quizzes {
    background: #d9e9d5;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.challenges {
    background: #ebe4d6;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.assignments {
    background: #ebe4d6;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
h1.tldr, h1.recap, h1.bib, h1.outcomes, h1.quizzes, h1.challenges, h1.assignments {
    padding: 0px;
}


 
.noJsAlert {
    padding: 20px;
    background-color: #f44336;  
    color: white;
    margin-bottom: 15px;
}


 
.embed-video-player {
    position: relative;
    padding-bottom: 56%;
    height: 0;
    overflow: hidden;
}
.youtube-player {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border:0;
}


 
#header-wrapper {
    padding:0.6rem;
}


 
#shortcuts {
    padding-top: 2.0rem;
}


 
#chapter p {
    text-align: left;
}


 
figcaption h4 {
    margin-top:-2.5rem;
}
.border1 {
    border:1px solid black;
}

 
td ul, td ol {
    margin: 0 0 1rem 0.5rem;
    padding: 0 0 0 0.5rem;
}

 
h1 { font-size:2.8rem !important;}
h2 { font-size:2.2rem; margin:1.2rem 0}
h3 { font-size:1.9rem; text-align:left !important; font-weight:400 !important;}
h4 { font-size:1.6rem}
h5 { font-size:1.3rem}
h6 { font-size:1rem}

h2 {
    width:100% !important;
    border-bottom:1px solid #5e5e5e !important;
    padding-bottom: 2px;
}
.tldr h2, .recap h2, .bib h2, .outcomes h2, .quizzes h2, .challenges h2, .assignments h2 {
    margin:0.5rem 0
}

.btn-crossreference, .btn-crossreference:hover {
    cursor: initial;
}

</style>

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <span class="topbar-breadcrumbs highlightable">
            Frontend
          </span>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="frontend">Frontend</h1>

<p>Unter dem &quot;Frontend&quot; versteht man die ersten Stufen eines Compilers,
die mit der <strong>Analyse</strong> des Inputs besch√§ftigt sind. Dies sind in der
Regel der Scanner, der Parser und die semantische Analyse.</p>

<ul class="children children-li children-sort-">
	
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing.html">Lexer</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing.html">Parser</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics.html">Semantische Analyse</a></li>
</ul>

            <footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Frontend</h1>
          <article class="default">
            <header class="headline">
            </header>
<h1 id="lexer">Lexer</h1>

<p>Der Lexer (auch &quot;Scanner&quot;) soll den Zeichenstrom in eine Folge von Token
zerlegen. Zur Spezifikation der Token werden in der Regel regul√§re Ausdr√ºcke
verwendet.</p>

<ul class="children children-li children-sort-">
	
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/regular.html">Regul√§re Sprachen, Ausdrucksst√§rke</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table.html">Lexer: Tabellenbasierte Implementierung</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/recursive.html">Lexer: Handcodierte Implementierung</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/antlr-lexing.html">Lexer mit ANTLR generieren</a></li>
</ul>

            <footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Lexer</h1>
<article class="default">
<h1>Regul√§re Sprachen, Ausdrucksst√§rke</h1>



    
    




    
    
        
        
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="far fa-file-powerpoint"></i> Annotierte Folien</div>
  <div class="box-content">

<ul> <li><a href='https://raw.githubusercontent.com/Compiler-CampusMinden/AnnotatedSlides/master/lexing_regular.ann.ma.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Annotierte Folien: Regul√§re Sprachen, Ausdrucksst√§rke</a></li></ul></div>
</div>




    <h1 id="motivation">Motivation</h1>
<h2 id="was-muss-ein-compiler-wohl-als-erstes-tun">Was muss ein Compiler wohl als erstes tun?</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="themen-f√ºr-heute">Themen f√ºr heute</h2>
<ul>
<li>Endliche Automaten</li>
<li>Regul√§re Ausdr√ºcke</li>
</ul>
<h1 id="endliche-automaten">Endliche Automaten</h1>
<h2 id="alphabete">Alphabete</h2>
<p><strong>Def.:</strong> Ein <em>Alphabet</em> 
<span class="math align-center">$\Sigma$</span> ist eine endliche, nicht-leere Menge von Symbolen. Die Symbole eines Alphabets hei√üen <em>Buchstaben</em>.</p>
<p><strong>Def.:</strong> Ein <em>Wort</em> 
<span class="math align-center">$w$</span> <em>√ºber einem Alphabet</em> 
<span class="math align-center">$\Sigma$</span> ist eine endliche Folge von Symbolen aus 
<span class="math align-center">$\Sigma$</span>.

<span class="math align-center">$\epsilon$</span> ist das leere Wort.
Die <em>L√§nge</em> 
<span class="math align-center">$\vert w \vert$</span> eines Wortes 
<span class="math align-center">$w$</span> ist die Anzahl von Buchstaben, die es enth√§lt (Kardinalit√§t).</p>
<p><strong>Def.:</strong>

<span class="math align-center">$\Sigma^k = \lbrace w\ \text{√ºber}\ \Sigma\ \vert\ \vert w \vert = k \rbrace$</span></p>
<p>
<span class="math align-center">$\Sigma^{\ast} = \bigcup\limits_{i \in \mathbb{N}_0} \Sigma^i$</span> (die Kleene-H√ºlle von 
<span class="math align-center">$\Sigma$</span>)</p>

<span class="math align-center">$\Sigma^+ = \bigcup\limits_{i \in \mathbb{N}} \Sigma^i$</span>
<h2 id="sprachen-√ºber-alphabete">Sprachen √ºber Alphabete</h2>
<p><strong>Def.:</strong> Seien 
<span class="math align-center">$x = a_1 a_2 \ \ldots \ a_n$</span> und 
<span class="math align-center">$y = b_1b_2 \  \ldots \  b_m$</span> W√∂rter. Wir nennen 
<span class="math align-center">$xy = x \circ y = a_1 \  \ldots \  a_nb_1 \ \ldots \ b_m$</span> die <em>Konkatenation</em> von 
<span class="math align-center">$x$</span> und 
<span class="math align-center">$y$</span>.</p>
<p><strong>Def.:</strong> <em>Eine Sprache</em> 
<span class="math align-center">$L$</span> <em>√ºber einem Alphabet</em> 
<span class="math align-center">$\Sigma$</span> ist eine Teilmenge von 
<span class="math align-center">$\Sigma^{\ast} :\ L \subseteq\Sigma^{\ast}$</span></p>
<h2 id="deterministische-endliche-automaten">Deterministische endliche Automaten</h2>
<p><strong>Def.:</strong> Ein <em>deterministischer endlicher Automat</em> (DFA) ist ein 5-Tupel

<span class="math align-center">$A = (Q, \Sigma, \delta, q_0, F)$</span> mit</p>
<ul>
<li>
<span class="math align-center">$Q$</span> : eine endliche Menge von Zust√§nden</li>
<li>
<span class="math align-center">$\Sigma$</span> : ein Alphabet von Eingabesymbolen</li>
<li>
<span class="math align-center">$\delta$</span> : die √úbergangsfunktion 
<span class="math align-center">$(Q \times \Sigma) \rightarrow Q, \delta$</span> kann partiell sein</li>
<li>
<span class="math align-center">$q_0 \in Q$</span> : der Startzustand</li>
<li>
<span class="math align-center">$F \subseteq Q$</span> : die Menge der Endzust√§nde</li>
</ul>
<h2 id="die-√ºbergangsfunktion">Die √úbergangsfunktion</h2>
<p><strong>Def.:</strong> Wir definieren 
<span class="math align-center">$\delta^{\ast}: (Q \times \Sigma^{\ast}) \rightarrow Q$</span>: induktiv wie folgt:</p>
<ul>
<li>Basis: 
<span class="math align-center">$\delta^{\ast}(q, \epsilon) = q\ \forall q \in Q$</span></li>
<li>Induktion: 
<span class="math align-center">$\delta^{\ast}(q, a_1, \ldots, a_n) = \delta(\delta^{\ast}(q, a_1, \ldots , a_{n-1}), a_n)$</span></li>
</ul>
<p><strong>Def.:</strong> Ein DFA akzeptiert ein Wort 
<span class="math align-center">$w \in \Sigma^{\ast}$</span> genau dann, wenn 
<span class="math align-center">$\delta^{\ast}(q_0, w) \in F.$</span></p>
<p><strong>Def.:</strong> Die Sprache eines DFA 
<span class="math align-center">$A\ L(A)$</span> ist definiert durch:</p>

<span class="math align-center">$L(A) =\lbrace w\ \vert \delta^{\ast}(q_0, w) \in F \rbrace$</span>
<h2 id="beispiel">Beispiel</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="nichtdeterministische-endliche-automaten">Nichtdeterministische endliche Automaten</h2>
<p><strong>Def.:</strong> Ein <em>nichtdeterministischer endlicher Automat</em> (NFA) ist ein 5-Tupel

<span class="math align-center">$A = (Q, \Sigma, \delta, q_0, F)$</span> mit</p>
<ul>
<li>
<span class="math align-center">$Q$</span>: eine endliche Menge von Zust√§nden</li>
<li>
<span class="math align-center">$\Sigma$</span>: ein Alphabet von Eingabesymbolen</li>
<li>
<span class="math align-center">$\delta$</span>: die √úbergangsfunktion 
<span class="math align-center">$(Q \times \Sigma) \rightarrow \mathcal{P}(Q)$</span></li>
<li>
<span class="math align-center">$q_0 \in Q$</span>: der Startzustand</li>
<li>
<span class="math align-center">$F \subseteq Q$</span>: die Menge der Endzust√§nde</li>
</ul>
<h2 id="die-√ºbergangsfunktion-eines-nfas">Die √úbergangsfunktion eines NFAs</h2>
<p><strong>Def.:</strong> Wir definieren 
<span class="math align-center">$\delta^{\ast}: (Q \times \Sigma) \rightarrow \mathcal{P}(Q):$</span>
induktiv wie folgt:</p>
<ul>
<li>
<p>Basis: 
<span class="math align-center">$\delta^{\ast}(q, \epsilon) = q\ \forall q \in Q$</span></p>
</li>
<li>
<p>Induktion: Sei 
<span class="math align-center">$w \in \Sigma^{\ast}, w = xa, x \in \Sigma^{\ast}, a \in \Sigma$</span> mit</p>
<p>
<span class="math align-center">$\delta^{\ast}(q, x) = \lbrace p_1,\ \ldots,\  p_k \rbrace, p_i \in Q$</span>, sei</p>
<p>
<span class="math align-center">$A = \bigcup\limits_{i = 1}^k \delta(p_i, a) = \lbrace r_1, \ldots r_m \rbrace, r_j \in Q$</span>.</p>
<p>Dann ist 
<span class="math align-center">$\delta^{\ast}(q, w) = \lbrace r_1,\  \ldots\ , r_m\rbrace$</span>.</p>
</li>
</ul>
<h2 id="wozu-nfas-im-compilerbau">Wozu NFAs im Compilerbau?</h2>
<p>Pattern Matching geht mit NFAs.</p>
<p>NFAs sind so nicht zu programmieren, aber:</p>
<p><strong>Satz:</strong> Eine Sprache 
<span class="math align-center">$L$</span> wird von einem NFA akzeptiert 
<span class="math align-center">$\Leftrightarrow L$</span> wird von einem DFA akzeptiert.</p>
<h2 id="konvertierung-eines-nfas-in-einen-dfa">Konvertierung eines NFAs in einen DFA</h2>
<p>Gegeben: Ein NFA 
<span class="math align-center">$A = (Q, \Sigma, \delta, q_0, F)$</span></p>
<p>Wir konstruieren einen DFA 
<span class="math align-center">$A' = (Q', \Sigma, \delta ', q_0, F')$</span> wie folgt:</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/regular/nfa2dfa.png" alt="Konvertierung NFA in DFA" width="45%" height="auto">
    <figcaption><p>Konvertierung NFA in DFA</p></figcaption>
</figure>
<h2 id="beispiel-1">Beispiel</h2>
<table>
<thead>
<tr>
<th style="text-align:right">
<span class="math align-center">$\delta$</span></th>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">
<span class="math align-center">$\rightarrow q_0$</span></td>
<td style="text-align:center">
<span class="math align-center">$\lbrace q_0\rbrace$</span></td>
<td style="text-align:center">
<span class="math align-center">$\lbrace q_1, q_2\rbrace$</span></td>
</tr>
<tr>
<td style="text-align:right">
<span class="math align-center">$q_1$</span></td>
<td style="text-align:center">
<span class="math align-center">$\lbrace q_2\rbrace$</span></td>
<td style="text-align:center">
<span class="math align-center">$\lbrace q_1\rbrace$</span></td>
</tr>
<tr>
<td style="text-align:right">*
<span class="math align-center">$q_2$</span></td>
<td style="text-align:center">-</td>
<td style="text-align:center">
<span class="math align-center">$\lbrace q_0, q_2\rbrace$</span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">
<span class="math align-center">$\delta$</span>'</th>
<th style="text-align:left">a</th>
<th style="text-align:left">b</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">
<span class="math align-center">$\rightarrow$</span> 
<span class="math align-center">$\lbrace q_0\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_1,q_2\rbrace$</span></td>
</tr>
<tr>
<td style="text-align:left">*
<span class="math align-center">$\lbrace q_1 q_2\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_2\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0, q_1, q_2\rbrace$</span></td>
</tr>
<tr>
<td style="text-align:left">*
<span class="math align-center">$\lbrace q_2\rbrace$</span></td>
<td style="text-align:left">-</td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0,q_2\rbrace$</span></td>
</tr>
<tr>
<td style="text-align:left">*
<span class="math align-center">$\lbrace q_0, q_2\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0, q_1, q_2\rbrace$</span></td>
</tr>
<tr>
<td style="text-align:left">*
<span class="math align-center">$\lbrace q_0, q_1, q_2\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0, q_2\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0, q_1, q_2\rbrace$</span></td>
</tr>
</tbody>
</table>
<h2 id="minimierung-eines-dfas">Minimierung eines DFAs</h2>
<p>Ist ist der DFA 
<span class="math align-center">$A$</span> nicht vollst√§ndig, wird ein Fehlerzustand 
<span class="math align-center">$q_e$</span>, der kein Endzustand ist, hinzugef√ºgt und in alle leeren Tabellenfelder eingetragen.</p>
<p>Dann wird eine Matrix generiert, die f√ºr alle Zustandspaare sagt, ob die beiden Zust√§nde zu einem verschmelzen k√∂nnen.</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/regular/minimize_dfa.png" alt="DFA Minimierung" width="50%" height="auto">
    <figcaption><p>DFA Minimierung</p></figcaption>
</figure>
<h1 id="regul√§re-ausdr√ºcke">Regul√§re Ausdr√ºcke</h1>
<h2 id="operatoren-auf-sprachen">Operatoren auf Sprachen</h2>
<p><strong>Def.:</strong> Seien <em>L</em> und <em>M</em> Sprachen.</p>
<ul>
<li>
<span class="math align-center">$L \cup M = \lbrace w \mid w \in L \vee w \in M \rbrace$</span></li>
<li>
<span class="math align-center">$LM = L \cdot M = L \circ M = \lbrace vw \mid v \in L \land w \in M\rbrace$</span></li>
<li>Die Kleene-H√ºlle einer Sprache:
<ul>
<li>Basis: 
<span class="math align-center">$L^0 = \lbrace \epsilon\rbrace$</span></li>
<li>Induktion: 
<span class="math align-center">$L^i = \lbrace xw\mid x \in L^{i-1}, w \in L, i > 0\rbrace$</span>, 
<span class="math align-center">$L^{\ast} = \bigcup\limits_{i \ge 0}L^i$</span>, 
<span class="math align-center">$L^+ = \bigcup\limits_{i > 0}L^i$</span></li>
</ul>
</li>
</ul>
<h2 id="regul√§re-ausdr√ºcke-1">Regul√§re Ausdr√ºcke</h2>
<p><strong>Def.:</strong> Induktive Definition von regul√§ren Ausdr√ºcken (<em>regex</em>) und der von ihnen repr√§sentierten Sprache:</p>
<ul>
<li>Basis:
<ul>
<li>
<span class="math align-center">$\epsilon$</span> und 
<span class="math align-center">$\emptyset$</span> sind regul√§re Ausdr√ºcke mit 
<span class="math align-center">$L(\epsilon) =  \lbrace \epsilon\rbrace$</span>, 
<span class="math align-center">$L(\emptyset)=\emptyset$</span></li>
<li>Sei 
<span class="math align-center">$a$</span> ein Symbol 
<span class="math align-center">$\Rightarrow$</span> 
<span class="math align-center">$a$</span> ist ein regex mit 
<span class="math align-center">$L(a) = \lbrace a\rbrace$</span></li>
</ul>
</li>
<li>Induktion: Seien 
<span class="math align-center">$E,\ F$</span> regul√§re Ausdr√ºcke. Dann gilt:
<ul>
<li>
<span class="math align-center">$E+F$</span> ist ein regex und bezeichnet die Vereinigung 
<span class="math align-center">$L(E + F) = L(E)\cup L(F)$</span></li>
<li>
<span class="math align-center">$EF$</span> ist ein regex und bezeichnet die Konkatenation 
<span class="math align-center">$L(EF) = L(E)L(F)$</span></li>
<li>
<span class="math align-center">$E^{\ast}$</span> ist ein regex und bezeichnet die Kleene-H√ºlle 
<span class="math align-center">$L(E^{\ast})=(L(E))^{\ast}$</span></li>
<li>
<span class="math align-center">$(E)$</span> ist ein regex mit 
<span class="math align-center">$L((E)) = L(E)$</span></li>
</ul>
</li>
</ul>
<p>Vorrangregeln der Operatoren f√ºr regul√§re Ausdr√ºcke: *, Konkatenation, +</p>
<h2 id="wichtige-identit√§ten">Wichtige Identit√§ten</h2>
<p><strong>Satz:</strong> Sei 
<span class="math align-center">$A$</span> ein DFA 
<span class="math align-center">$\Rightarrow \exists$</span> regex 
<span class="math align-center">$R$</span> mit 
<span class="math align-center">$L(A) = L(R)$</span>.</p>
<p><strong>Satz:</strong> Sei 
<span class="math align-center">$E$</span> ein regex 
<span class="math align-center">$\Rightarrow \exists$</span> DFA 
<span class="math align-center">$A$</span> mit 
<span class="math align-center">$L(E) = L(A)$</span>.</p>
<h2 id="beispiel-umwandlung-eines-regex-in-einen-nfa">Beispiel: Umwandlung eines regex in einen NFA</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="formale-grammatiken">Formale Grammatiken</h2>
<p><strong>Def.:</strong> Eine <em>formale Grammatik</em> ist ein 4-Tupel 
<span class="math align-center">$G=(N,T,P,S)$</span> aus</p>
<ul>
<li>
<span class="math align-center">$N$</span>: einer endlichen Menge von 
<span class="math align-center">$Nichtterminalen$</span></li>
<li><em>T</em>: einer endlichen Menge von <em>Terminalen</em>, 
<span class="math align-center">$N \cap T = \emptyset$</span></li>
<li>
<span class="math align-center">$S \in N$</span>: dem <em>Startsymbol</em></li>
<li><em>P</em>: einer endlichen Menge von <em>Produktionen</em> der Form: 
<span class="math align-center">$X \rightarrow Y$</span> mit 
<span class="math align-center">$X \in (N \cup T)^{\ast} N (N \cup T)^{\ast}, Y \in (N \cup T)^{\ast}$</span></li>
</ul>
<h2 id="ableitungen">Ableitungen</h2>
<p><strong>Def.:</strong> Sei 
<span class="math align-center">$G = (N, T, P, S)$</span> eine Grammatik, sei 
<span class="math align-center">$\alpha A \beta$</span> eine Zeichenkette √ºber

<span class="math align-center">$(N \cup T)^{\ast}$</span> und sei 
<span class="math align-center">$A$</span> 
<span class="math align-center">$\rightarrow \gamma$</span> eine Produktion von 
<span class="math align-center">$G$</span>.</p>
<p>Wir sagen:

<span class="math align-center">$\alpha A \beta \Rightarrow \alpha \gamma \beta$</span> (
<span class="math align-center">$\alpha A \beta$</span> leitet 
<span class="math align-center">$\alpha \gamma \beta$</span> ab).</p>
<p><strong>Def.:</strong> Wir definieren die Relation 
<span class="math align-center">$\overset{\ast}{\Rightarrow}$</span> induktiv wie folgt:</p>
<ul>
<li>Basis: 
<span class="math align-center">$\forall \alpha \in (N \cup T)^{\ast} \alpha \overset{\ast}{\Rightarrow} \alpha$</span> (Jede Zeichenkette leitet sich selbst ab.)</li>
<li>Induktion: Wenn 
<span class="math align-center">$\alpha \overset{\ast}{\Rightarrow} \beta$</span> und

<span class="math align-center">$\beta\Rightarrow \gamma$</span> dann 
<span class="math align-center">$\alpha \overset{\ast}{\Rightarrow} \gamma$</span></li>
</ul>
<p><strong>Def.:</strong> Sei 
<span class="math align-center">$G = (N, T ,P, S)$</span> eine formale Grammatik.
Dann ist 
<span class="math align-center">$L(G) = \lbrace w \in T^{\ast} \mid S \overset{\ast}{\Rightarrow} w\rbrace$</span> die von 
<span class="math align-center">$G$</span> erzeugte Sprache.</p>
<h2 id="regul√§re-grammatiken">Regul√§re Grammatiken</h2>
<p><strong>Def.:</strong> Eine <em>regul√§re (oder type-3-) Grammatik</em> ist eine formale Grammatik mit den folgenden Einschr√§nkungen:</p>
<ul>
<li>
<p>Alle Produktionen sind entweder von der Form</p>
<ul>
<li>
<span class="math align-center">$X \to aY$</span> mit 
<span class="math align-center">$X \in N, a \in T, Y \in N$</span> (<em>rechtsregul√§re</em> Grammatik) oder</li>
<li>
<span class="math align-center">$X \to Ya$</span> mit 
<span class="math align-center">$X \in N, a \in T, Y \in N$</span> (<em>linksregul√§re</em> Grammatik)</li>
</ul>
</li>
<li>
<p>
<span class="math align-center">$X\rightarrow\epsilon$</span> ist in beiden F√§llen erlaubt.</p>
</li>
</ul>
<h2 id="regul√§re-sprachen">Regul√§re Sprachen</h2>
<p><strong>Satz:</strong> Die von rechtsregul√§ren Grammatiken erzeugten Sprachen sind genau die von linksregul√§ren Grammatiken erzeugten Sprachen. Beide werden <em>regul√§re</em> Sprachen genannt.</p>
<p><strong>Satz:</strong> Die von regul√§ren Ausdr√ºcken beschriebenen Sprachen sind die regul√§ren Sprachen.</p>
<h2 id="das-pumping-lemma-f√ºr-regul√§re-sprachen">Das Pumping Lemma f√ºr regul√§re Sprachen</h2>
<p><strong>Satz:</strong> Das <em>Pumping Lemma f√ºr regul√§re Sprachen</em>:</p>
<p>Sei 
<span class="math align-center">$L$</span> eine regul√§re Sprache.</p>
<p>
<span class="math align-center">$\Rightarrow \exists$</span> Konstante 
<span class="math align-center">$n \in \mathbb{N}$</span>:</p>
<p>
<span class="math align-center">$\underset{\underset{|w| \geq n} {w \in L}}\forall \exists x, y, z \in \Sigma^{*}$</span> mit 
<span class="math align-center">$w = xyz, y \neq \epsilon, |xy| \leq n:$</span></p>

<span class="math align-center">$\underset{k \geq 0} \forall xy^{k}z \in L$</span>
<h2 id="abschlusseigenschaften-regul√§rer-sprachen">Abschlusseigenschaften regul√§rer Sprachen</h2>
<p>Die Klasse der regul√§ren Sprachen ist abgeschlossen unter</p>
<ul>
<li>Vereinigung</li>
<li>Konkatenation</li>
<li>Kleene-Stern</li>
<li>Komplementbildung</li>
<li>Durchschnitt</li>
</ul>
<h2 id="entscheidbarkeit-f√ºr-regul√§re-sprachen">Entscheidbarkeit f√ºr regul√§re Sprachen</h2>
<p><strong>Satz:</strong> Es ist entscheidbar,</p>
<ul>
<li>ob eine gegebene regul√§re Sprache leer ist</li>
<li>ob 
<span class="math align-center">$w \in \Sigma^{\ast}$</span> in einer gegebenen regul√§ren Sprache enthalten ist (Das &quot;Wort-Problem&quot;)</li>
<li>ob zwei regul√§re Sprachen √§quivalent sind</li>
</ul>
<h2 id="grenzen-der-regul√§ren-sprachen">Grenzen der regul√§ren Sprachen</h2>
<p>Regul√§re Sprachen sind von ihrer Struktur her einfach. Schon Sprachen, in denen etwas &quot;gematcht&quot; werden muss, lassen sich nicht mehr regul√§r beschreiben, weil z. B. die fixe Anzahl von Zust√§nden eines DFAs die Erkennung solcher Sprachen verhindert.</p>
<h2 id="wozu-das-ganze">Wozu das Ganze?</h2>
<p>Im Compilerbau werden regul√§re Ausdr√ºcke benutzt, um die Schl√ºsselw√∂rter und weitere Symbole der zu erkennenden Sprache anzugeben. Daraus wird mit Hilfe eines Generators, der aus den regul√§ren Ausdr√ºcken DFAs (oder einen gro√üen DFA) macht, der sog. Scanner oder Lexer genannt, generiert. Seine Aufgabe ist es, die Folge von Zeichen in der Quelldatei in eine Folge von sog. Token umzuwandeln. Z. B. wird so aus den Zeichen des Schl√ºsselwortes <em>while</em> im Programmtext das Token f√ºr <em>while</em> gemacht, das in der Syntaxanalyse weiterverarbeitet wird. Die Tokenfolge eines Programms ist ein Wort einer Sprache, die der Parser erkennt. Jedes vom Lexer erkannte Token ist dort also ein terminales Symbol.</p>
<h2 id="ein-lexer-ist-mehr-als-ein-dfa">Ein Lexer ist mehr als ein DFA</h2>
<p>Was ist zu beachten:</p>
<ul>
<li>Man braucht mindestens eine Liste von Paaren aus regul√§ren Ausdr√ºcken und Tokennamen.</li>
<li>Neben den Schl√ºsselw√∂rtern und Symbolen wie (,), *, 
<span class="math align-center">$\ldots$</span> m√ºssen auch Namen f√ºr Variablen, Funktionen, Klassen, Methoden, 
<span class="math align-center">$\ldots$</span> (sog. Identifier) erkannt werden</li>
<li>Namen haben meist eine gewisse Struktur, die sich mit regul√§ren Ausdr√ºcken beschreiben lassen.</li>
<li>Erlaubte Token sind in der Grammatik des Parsers beschrieben, d. h. f√ºr literale Namen, Strings, Zahlen liefert der Scanner zwei Werte:
<ul>
<li>z.  B. <code>&lt;ID, &quot;radius&quot;&gt;</code>, <code>&lt;Integerzahl, 558&gt;</code></li>
</ul>
</li>
<li>Kommentare und Strings m√ºssen richtig erkannt werden. (Schachtelungen)</li>
</ul>
<p>Man kann nat√ºrlich auch einen Lexer selbst programmieren, d. h. die DFAs f√ºr die regul√§ren Ausdr√ºcke implementieren.</p>
<h2 id="automatisch-oder-h√§ndisch">Automatisch oder h√§ndisch</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h1 id="wrap-up">Wrap-Up</h1>
<h2 id="wrap-up-1">Wrap-Up</h2>
<ul>
<li>Definition und Aufgaben von Lexern</li>
<li>DFAs und NFAs</li>
<li>Regul√§re Ausdr√ºcke</li>
<li>Regul√§re Grammatiken</li>
<li>Zusammenh√§nge zwischen diesen Mechanismen und Lexern, bzw. Lexergeneratoren</li>
</ul>


    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_aho2013compilers'>[aho2013compilers] <strong>Compilers: Pearson New International Edition: Principles, Techniques, and Tools</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Education Limited, 2013. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-2920-3723-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-2920-3723-3</a>.<br><em>Abschnitt 2.6 und Kapitel 3</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li> <li id='id_Torczon2012'>[Torczon2012] <strong>Engineering a Compiler</strong><br>Torczon, L. und Cooper, K., Elsevier MK, 2012. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-1208-8478-0' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-1208-8478-0</a>.<br><em>Kapitel 2</em></li></ul></div>
</div>



    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) DFAs</li> <li>(K1) NFAs</li> <li>(K1) Regul√§re Ausdr√ºcke</li> <li>(K1) Regul√§re Grammatiken</li> <li>(K2) Zusammenh√§nge und Gesetzm√§√üigkeiten bzgl. der oben genannten Konstrukte</li> <li>(K3) DFAs, NFAs, regul√§re Ausdr√ºcke, regul√§re Grammatiken entwickeln</li> <li>(K3) Herausfinden, ob eine Sprache regul√§r ist</li> <li>(K3) Einen DFA entwickeln, der alle Schl√ºsselw√∂rter, Namen und weitere Symbole einer Programmiersprache akzeptiert</li></ul></div>
</div>



    








<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Lexer: Tabellenbasierte Implementierung</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p><a href="#R-image-e2a9b91052dcc8e8aae5a97d143716b9" class="lightbox-link"><img src="images/architektur_cb_lexer.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e2a9b91052dcc8e8aae5a97d143716b9"><img src="images/architektur_cb_lexer.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Der Lexer (auch &quot;Scanner&quot;) soll den Zeichenstrom in eine Folge von Token
zerlegen. Zur Spezifikation der Token werden regul√§re Ausdr√ºcke verwendet.
Diese k√∂nnen √ºber verschiedene Schritte in einen zugeh√∂rigen DFA transformiert
werden, der wiederum √ºber Tabellen dargestellt werden kann (vgl. auch
<a href="regular.md">Regul√§re Sprachen, Ausdrucksst√§rke</a>).</p>
<p>Mit Hilfe der (√ºblicherweise von Scanner-Generatoren generierten) Tabellen kann
ein Lexer implementiert werden (&quot;tabellenbasierte Implementierung&quot;). Zur Steigerung
der Effizienz kann die Tabelle in den Code integriert werden (etwa mit Sprungbefehlen,
&quot;direkt codierte Implementierung&quot;). Diese Lexer sind nur schwer nachvollziehbar und
werden √ºblicherweise generiert (vgl. <a href="flex.md">Flex</a>
und <a href="antlr.md">ANTLR</a>).</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/2GeEaU3qB6c' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Tabellenbasierte Scanner</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/36f62768351b19aa6453c819afa64cf2cc9ac698d3cf29137f3c7a5aeb5229de7c1102b8cf87981c27cbc1b250f03f1572e690dc96fb69e89a982f8200d54eb2' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Tabellenbasierte Scanner</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) Aufgaben eines Lexers</li> <li>(K2) Erkennen von Lexemen mit RE und DFA</li> <li>(K2) DFA-nahe Implementierung: Tabellenbasiert und direkt codiert</li></ul></div>
</div>




    <h2 id="lexer-erzeugen-eines-token-stroms-aus-einem-zeichenstrom">Lexer: Erzeugen eines Token-Stroms aus einem Zeichenstrom</h2>
<p>Aus dem Eingabe(-quell-)text</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* demo */</span>
</span></span><span style="display:flex;"><span>a<span style="color:#f92672">=</span> [<span style="color:#ae81ff">5</span>  , <span style="color:#ae81ff">6</span>]     ;</span></span></code></pre></div><p>erstellt der Lexer (oder auch Scanner genannt) eine Sequenz von Token:</p>
<pre><code>&lt;ID, &quot;a&quot;&gt; &lt;ASSIGN&gt; &lt;LBRACK&gt; &lt;NUM, 5&gt; &lt;COMMA&gt; &lt;NUM, 6&gt; &lt;RBRACK&gt; &lt;SEMICOL&gt;
</code></pre>
<ul>
<li>Input: Zeichenstrom (Eingabedatei o.√§.)</li>
<li>Verarbeitung: Finden sinnvoller Sequenzen im Zeichenstrom (&quot;Lexeme&quot;),
Einteilung in Kategorien und Erzeugen von Token (Paare: Typ/Name, Wert)</li>
<li>Ausgabe: Tokenstrom</li>
</ul>
<p>Normalerweise werden f√ºr sp√§tere Phasen unwichtige Elemente wie White-Space
oder Kommentare entfernt.</p>
<p>Durch diese Vorverarbeitung wird eine h√∂here Abstraktionsstufe erreicht und es
k√∂nnen erste grobe Fehler gefunden werden. Dadurch kann der Parser auf einer
abstrakteren Stufe arbeiten und muss nicht mehr den gesamten urspr√ºnglichen
Zeichenstrom verarbeiten.</p>
<p><em>Anmerkung</em>: In dieser Phase steht die Geschwindigkeit stark im Vordergrund:
Der Lexer &quot;sieht&quot; <em>alle</em> Zeichen im Input. Deshalb findet man h√§ufig von
Hand kodierte Lexer, obwohl die Erstellung der Lexer auch durch Generatoren
erledigt werden k√∂nnte ...</p>
<p><em>Anmerkung</em>: Die Token sind die Terminalsymbole in den Parserregeln (Grammatik).</p>
<h2 id="definition-wichtiger-begriffe">Definition wichtiger Begriffe</h2>
<ul>
<li>
<p><strong>Token</strong>: Tupel (Tokenname, optional: Wert)</p>
<p>Der Tokenname ist ein abstraktes Symbol, welches eine lexikalische
Einheit repr√§sentiert (Kategorie). Die Tokennamen sind die Eingabesymbole
f√ºr den Parser.</p>
<p>Token werden i.d.R. einfach √ºber ihren Namen referenziert. Token werden
h√§ufig zur Unterscheidung von anderen Symbolen in der Grammatik in
Fettschrift oder mit gro√üen Anfangsbuchstaben geschrieben.</p>
<p>Ein Token kann einen Wert haben, etwa eine Zahl oder einen Bezeichner, der
auf das zum Token geh√∂rende Pattern gematcht hatte (also das Lexem). Wenn
der Wert des Tokens eindeutig √ºber den Namen bestimmt ist (im Beispiel oben
beim Komma oder den Klammern), dann wird h√§ufig auf den Wert verzichtet.</p>
</li>
<li>
<p><strong>Lexeme</strong>: Sequenz von Zeichen im Eingabestrom, die auf ein Tokenpattern
matcht und vom Lexer als Instanz dieses Tokens identifiziert wird.</p>
</li>
<li>
<p><strong>Pattern</strong>: Beschreibung der Form eines Lexems</p>
<p>Bei Schl√ºsselw√∂rtern oder Klammern etc. sind dies die Schl√ºsselw√∂rter oder
Klammern selbst. Bei Zahlen oder Bezeichnern (Namen) werden i.d.R.
regul√§re Ausdr√ºcke zur Beschreibung der Form des Lexems formuliert.</p>
</li>
</ul>
<h2 id="erkennung-mit-re-und-dfa">Erkennung mit RE und DFA</h2>
<p><a href="#R-image-1db52d4f058a4ce1ca850c1b226f554a" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table/lexer.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1db52d4f058a4ce1ca850c1b226f554a"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table/lexer.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Die obige Skizze ist eine Kurzzusammenfassung der Theorie-Vorlesung in der
letzten Woche und stellt die Verbindung zur heutigen Vorlesung her:</p>
<p>Die Lexeme werden mit Hilfe von <em>DFA</em> bestimmt. Die Formulierung der DFA ist
eher komplex (zumindest sehr umst√§ndlich), weshalb man die Pattern f√ºr die
Lexeme ersatzweise mit Hilfe von <em>Regul√§ren Ausdr√ºcken</em> (&quot;<em>RE</em>&quot;) formuliert.</p>
<p>Mit Hilfe der <em>Thompson's Construction</em> kann man diese in √§quivalente <em>NFA</em>
umformen. √úber die <em>Subset Construction</em> kann man daraus <em>DFA</em> erzeugen, die
wiederum mit Hilfe des <em>Hopcroft's Algorithm</em> minimiert werden.</p>
<p>Diese DFA erkennen die selbe Sprache wie die urspr√ºnglichen REs. Man k√∂nnte
also durch Simulation der DFA die Lexeme erkennen und die Token bilden. Dabei
w√ºrde pro Eingabezeichen ein √úbergang im DFA stattfinden und bei Erreichen
eines akzeptierenden Zustandes h√§tte man das durch diesen DFA (bzw. dessen
urspr√ºnglichen RE) beschriebene Lexem identifiziert.</p>
<p>Falls mehrere REs matchen, muss man in geeigneter Weise entscheiden. I.d.R.
nimmt man den l√§ngsten Match. Zus√§tzlich wird eine Reihenfolge unter den REs
festgelegt, um bei mehreren gleich langen Matches ein Token bestimmen zu
k√∂nnen.</p>
<p>In der Praxis werden die DFA als Ausgangspunkt f√ºr die Implementierung des
Lexers genutzt (ob nun bei einer &quot;handgekl√∂ppelten&quot; Implementierung oder beim
Einsatz eines Lexer-Generators). Als typische Implementierungsans√§tze sollen
nachfolgend die <em>tabellenbasierte Implementierung</em> sowie als etwas schnellere
Variante die <em>direkt codierte Implementierung</em> betrachtet werden. W√§hrend diese
beiden Varianten noch sehr nah an der Simulation eines DFA sind, ist die
<em>manuelle Implementierung</em>
(vgl. <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/recursive.html">Handcodierte Implementierung</a>)
noch einfacher in bestehenden Code zu integrieren (zum Preis einer erschwerten
√Ñnderbarkeit).</p>
<p>√úber die <em>Kleene's Construction</em> k√∂nnte man aus den DFA wieder <em>RE</em> erzeugen
und damit den Kreis schlie√üen :-)</p>
<h2 id="erkennen-von-zeichenketten-f√ºr-strickmuster-10lrl">Erkennen von Zeichenketten f√ºr Strickmuster: &quot;10LRL&quot;</h2>
<p><a href="#R-image-be7471b035ffd747f99f5544e0027856" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table/dfa.png?width=45%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 45%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-be7471b035ffd747f99f5544e0027856"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table/dfa.png?width=45%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>DFA zur Erkennung von Strickanweisungen: Das erste Zeichen muss ein
Digit im Bereich 1..9 sein, gefolgt von weiteren Digits, gefolgt von
einer Anweisung f√ºr linke Maschen (&quot;L&quot;) oder rechte Maschen (&quot;R&quot;).</p>
<p>Ein passender regul√§rer Ausdruck daf√ºr w√§re &quot;<code>[1-9][0-9]*[LR]+</code>&quot;.</p>
<p>Die Eingabezeichen werden in relevante Kategorien sortiert. Dabei
werden nur die f√ºr die Aufgabe interessanten Zeichen (&quot;R&quot; bzw. &quot;L&quot;
und die Ziffern) einer konkreten Kategorie zugewiesen, der Rest wird
als &quot;<code>*</code>&quot; zusammengefasst.</p>
<p><a href="#R-image-15ea178d11834126f705c0d03f47faac" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table/delta.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-15ea178d11834126f705c0d03f47faac"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table/delta.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>F√ºr jeden Zustand wird in der Tabelle vermerkt, in welchen Folgezustand beim
Auftreten eines Zeichens einer bestimmten Kategorie gewechselt werden soll.
Dies ist eine alternative Darstellung des DFA in der obigen Darstellung.</p>
<p>Die Zust√§nde des DFA werden den Tokentypen zugeordnet. Alle Zust√§nde au√üer
&quot;<code>s2</code>&quot; entsprechen keinem g√ºltigen Token, dies k√∂nnte man etwa als Token-Typ
&quot;<code>invalid</code>&quot; realisieren.</p>
<p><em>Anmerkung</em>: &quot;<code>se</code>&quot; ist ein Fehlerzustand, der im Automaten oben nicht
dargestellt ist und der dazu dient, falsche Zeichen zu erkennen und
entsprechend zu antworten.</p>
<h2 id="tabellenbasierte-implementierung">Tabellenbasierte Implementierung</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">nextToken</span>():
</span></span><span style="display:flex;"><span>    state <span style="color:#f92672">=</span> s0; lexeme <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>; stack <span style="color:#f92672">=</span> Stack()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (state <span style="color:#f92672">!=</span> se):
</span></span><span style="display:flex;"><span>        consume()       <span style="color:#75715e"># hole n√§chstes Zeichen (peek)</span>
</span></span><span style="display:flex;"><span>        lexeme <span style="color:#f92672">+=</span> peek
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">.</span>push(state)
</span></span><span style="display:flex;"><span>        state <span style="color:#f92672">=</span> TransitionTable[state, peek]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (state <span style="color:#f92672">!=</span> s2 <span style="color:#f92672">and</span> stack<span style="color:#f92672">.</span>notEmpty()):
</span></span><span style="display:flex;"><span>        state <span style="color:#f92672">=</span> stack<span style="color:#f92672">.</span>pop(); putBack(lexeme<span style="color:#f92672">.</span>truncate())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> state <span style="color:#f92672">==</span> s2: <span style="color:#66d9ef">return</span> s2(lexeme)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: <span style="color:#66d9ef">return</span> invalid()</span></span></code></pre></div><p>Der dargestellte Code implementiert direkt den DFA zur Erkennung von
Register-Namen unter Nutzung der Tabellen aus dem letzten Abschnitt.</p>
<p>Die Funktion <code>consume()</code> &quot;verbraucht&quot; das aktuelle Zeichen &quot;<code>peek</code>&quot; und
holt das n√§chste Zeichen aus dem Eingabestrom:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">consume</span>():
</span></span><span style="display:flex;"><span>    peek <span style="color:#f92672">=</span> nextChar()</span></span></code></pre></div><p>Nach einer Initialisierung wird in der Hauptschleife nach dem n√§chsten
Zeichen im Eingabestrom gefragt und das Lexem erweitert. Anschlie√üend
wird der aktuelle Zustand auf dem Stack gesichert und mit Hilfe der
Transitionstabelle und des aktuellen Zustands sowie des aktuellen Zeichens
<code>peek</code> der Folgezustand bestimmt. Sobald der Fehlerzustand &quot;<code>se</code>&quot; erreicht
wird, bricht die Schleife ab.</p>
<p><em>Anmerkung</em>: Wenn wir in &quot;<code>s2</code>&quot; sind, wird so lange nach weiteren Buchstaben
&quot;L&quot; oder &quot;R&quot; gesucht, bis im Strom irgendetwas anderes auftaucht und wir
entsprechend in &quot;<code>se</code>&quot; landen.</p>
<p>In der zweiten Schleife wird der Stack aufgerollt, um zu schauen, ob wir
fr√ºher bereits in &quot;<code>s2</code>&quot; waren oder nicht. Das erste Element wird vom Stack
genommen, das Lexem wird um das letzte Zeichen gek√ºrzt und dieses letzte
Zeichen wird mit <code>putBack()</code> in den Eingabestrom zur√ºckgelegt. Falls wir
fr√ºher bereits in &quot;<code>s2</code>&quot; waren, wird dieser Zustand irgendwann vom Stack
genommen. Anderenfalls ist der Stack irgendwann leer.</p>
<p>Falls &quot;<code>s2</code>&quot; erreicht wurde, wird ein neues &quot;<code>s2</code>&quot;-Token generiert und das
Lexem wird als Attribut direkt gesetzt. Anderenfalls lag ein Fehler vor.</p>
<p><em>Anmerkung</em>: Diese Implementierung ist generisch: Wenn man im Code die
direkte Nennung des akzeptierenden Zustands &quot;<code>s2</code>&quot; durch einen Vergleich
mit einer Menge aller akzeptierender Zust√§nde ersetzt (&quot;<code>state == s2</code>&quot;
=&gt; &quot;<code>state in acceptedStates</code>&quot;), bestimmen nur die Tabellen die
konkrete Funktionsweise.</p>
<p>Die Tabellen k√∂nnen allerdings schnell sehr gro√ü werden, insbesondere
die Zustands√ºbergangstabelle!</p>
<h2 id="direkt-codierte-implementierung">Direkt codierte Implementierung</h2>
<p>Die Implementierung √ºber die Tabellen ist sowohl generisch als auch effizient.
Allerdings kostet jeder Zugriff auf die Tabelle konstanten Aufwand (Erinnerung:
Zugriff auf Arrays, Pointerarithmetik), der sich in der Praxis deutlich
summieren kann. Au√üerdem m√ºssen der Stack gepflegt (erweitert und sp√§ter wieder
reduziert) werden und Objekte f√ºr die Zust√§nde angelegt werden.</p>
<p>Die L√∂sung: Aufrollen der <code>while</code>-Schleife und direkt Umsetzung der Tabelle im
Code mit Sprungbefehlen (&quot;<code>goto</code>&quot;):</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">nextToken</span>():
</span></span><span style="display:flex;"><span>    lexeme <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>; stack <span style="color:#f92672">=</span> Stack()
</span></span><span style="display:flex;"><span>    goto s0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>s0:
</span></span><span style="display:flex;"><span>    consume()       <span style="color:#75715e"># hole n√§chstes Zeichen (peek)</span>
</span></span><span style="display:flex;"><span>    lexeme <span style="color:#f92672">+=</span> peek
</span></span><span style="display:flex;"><span>    stack<span style="color:#f92672">.</span>push(s0)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> peek <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span> <span style="color:#f92672">||</span> <span style="color:#f92672">...</span> <span style="color:#f92672">||</span>¬†peek <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;9&#34;</span>:
</span></span><span style="display:flex;"><span>        goto s1
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        goto se
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span></span></span></code></pre></div><p>Durch die direkte Kodierung der Tabellen in Form von Sprungzielen f√ºr
<code>goto</code>-Befehle spart man sich die Formulierung der Tabellen und den Zugriff
auf die Inhalte. Allerdings ist der Code deutlich schwerer lesbar und auch
deutlich schwerer an eine andere Sprache anpassbar. Dies stellt aber keinen
echten Nachteil dar, wenn er durch einen Generator aus einer Grammatik o.√§.
erzeugt wird.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Zusammenhang DFA, RE und Lexer</p>
</li>
<li>
<p>Implementierungsansatz: Tabellenbasiert (DFA-Tabellen)</p>
</li>
</ul>


    



    



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Abschnitt 2.6 und Kapitel 3</em></li> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 1 (insbesondere Abschnitt 1.8)</em></li> <li id='id_Torczon2012'>[Torczon2012] <strong>Engineering a Compiler</strong><br>Torczon, L. und Cooper, K., Elsevier MK, 2012. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-1208-8478-0' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-1208-8478-0</a>.<br><em>Kapitel 2</em></li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Lexer: Handcodierte Implementierung</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p><a href="#R-image-20ce9c51402d8e5152a21b9a12d2b154" class="lightbox-link"><img src="images/architektur_cb_lexer.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-20ce9c51402d8e5152a21b9a12d2b154"><img src="images/architektur_cb_lexer.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Der Lexer (auch &quot;Scanner&quot;) soll den Zeichenstrom in eine Folge von Token zerlegen. Zur
Spezifikation der Token werden regul√§re Ausdr√ºcke verwendet.</p>
<p>Von Hand implementierte Lexer arbeiten √ºblicherweise rekursiv und verarbeiten immer
das n√§chste Zeichen im Eingabestrom. Die Arbeitsweise erinnert an LL-Parser (vgl.
<a href="../parsing/ll-parser-impl.md">LL-Parser</a>).</p>
<p>Lexer m√ºssen sehr effizient sein, da sie noch direkt auf der niedrigsten Abstraktionsstufe
arbeiten und u.U. oft durchlaufen werden. Deshalb setzt man hier gern spezielle Techniken
wie Puffern von Zeichen √ºber einen Doppel-Puffer ein.</p>
<p>Die Palette an Fehlerbehandlungsstrategien im Lexer reichen von &quot;aufgeben&quot; √ºber den &quot;Panic
Mode&quot; (&quot;gobbeln&quot; von Zeichen, bis wieder eines passt) und Ein-Schritt-Transformationen bis
hin zu speziellen Lexer-Regeln, die beispielsweise besonders h√§ufige Typos abfangen.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/N0WJQ4UkXkM' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Handcodierte Lexer</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/17a4958b1d4c0cf3488a7df02743806a33951d49f1cc22bccbdab7ad873738f0a24d0ad83f13c6d00ad48a669758659fde7a7e2ce19e793fe6f412e35ea0ee6d' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Handcodierte Lexer</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) Aufgaben eines Lexers</li> <li>(K2) Manuelle Implementierung: Rekursiver Abstieg</li> <li>(K2) Umgang mit dem Doppel-Puffer</li> <li>(K2) Varianten bei der Erkennung von Schl√ºsselw√∂rtern</li> <li>(K2) Fehler und L√∂sungsans√§tze in der lexikalischen Analyse</li> <li>(K3) Typische Einteilung von Token</li> <li>(K3) Implementierung eines Top-Down-Lexers mit Read-Ahead und intelligenter Pufferung</li></ul></div>
</div>




    <h2 id="lexer-erzeugen-eines-token-stroms-aus-einem-zeichenstrom">Lexer: Erzeugen eines Token-Stroms aus einem Zeichenstrom</h2>
<p>Aus dem Eingabe(-quell-)text</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* demo */</span>
</span></span><span style="display:flex;"><span>a<span style="color:#f92672">=</span> [<span style="color:#ae81ff">5</span>  , <span style="color:#ae81ff">6</span>]     ;</span></span></code></pre></div><p>erstellt der Lexer (oder auch Scanner genannt) eine Sequenz von Token:</p>
<pre><code>&lt;ID, &quot;a&quot;&gt; &lt;ASSIGN&gt; &lt;LBRACK&gt; &lt;NUM, 5&gt; &lt;COMMA&gt; &lt;NUM, 6&gt; &lt;RBRACK&gt; &lt;SEMICOL&gt;
</code></pre>
<h2 id="manuelle-implementierung-rekursiver-abstieg">Manuelle Implementierung: Rekursiver Abstieg</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">nextToken</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (peek <span style="color:#f92672">!=</span> EOF):  <span style="color:#75715e"># globale Variable, √ºber consume()</span>
</span></span><span style="display:flex;"><span>        switch (peek):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39; &#39;</span>: <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#39;</span>: <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>: WS(); <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;[&#39;</span>: consume(); <span style="color:#66d9ef">return</span> Token(LBRACK, <span style="color:#e6db74">&#39;[&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>            default:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> isLetter(peek): <span style="color:#66d9ef">return</span> NAME()
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">raise</span> Error(<span style="color:#e6db74">&#34;invalid character: &#34;</span><span style="color:#f92672">+</span>peek)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Token(EOF_Type, <span style="color:#e6db74">&#34;&lt;EOF&gt;&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">WS</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (peek <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">||</span> peek <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">||</span> <span style="color:#f92672">...</span>): consume()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">NAME</span>():
</span></span><span style="display:flex;"><span>    buf <span style="color:#f92672">=</span> StringBuilder()
</span></span><span style="display:flex;"><span>    do { buf<span style="color:#f92672">.</span>append(peek); consume(); } <span style="color:#66d9ef">while</span> (isLetter(peek))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Token(NAME, buf<span style="color:#f92672">.</span>toString())</span></span></code></pre></div><p>Die manuelle Implementierung &quot;denkt&quot; nicht in den Zust√§nden des DFA, sondern
orientiert sich immer am aktuellen Zeichen &quot;<code>peek</code>&quot;. Abh√§ngig von dessen
Auspr√§gung wird entweder direkt ein Token erzeugt und das Zeichen aus dem
Eingabestrom entfernt sowie das n√§chste Zeichen eingelesen (mittels der
Funktion <code>consume()</code>, nicht dargestellt im Beispiel), oder man ruft weitere
Funktionen auf, die das Gew√ºnschte erledigen, beispielsweise um White-Spaces
zu entfernen oder um einen Namen einzulesen: Nach einem Buchstaben werden
alle folgenden Buchstaben dem Namen (Bezeichner) hinzugef√ºgt. Sobald ein
anderes Zeichen im Eingabestrom erscheint, wird das Namen-Token erzeugt.</p>
<p>Die Funktion <code>consume()</code> &quot;verbraucht&quot; das aktuelle Zeichen &quot;<code>peek</code>&quot; und holt
das n√§chste Zeichen aus dem Eingabestrom.</p>
<p><em>Anmerkung</em>: H√§ufig findet man im Lexer keinen &quot;sch√∂nen&quot; objektorientierten
Ansatz. Dies ist i.d.R. Geschwindigkeitsgr√ºnden geschuldet ...</p>
<h2 id="read-ahead-unterscheiden-von--und-">Read-Ahead: Unterscheiden von &quot;<em>&lt;</em>&quot; und &quot;<em>&lt;=</em>&quot;</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">nextToken</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (peek <span style="color:#f92672">!=</span> EOF):  <span style="color:#75715e"># globale Variable</span>
</span></span><span style="display:flex;"><span>        switch (peek):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;&lt;&#39;</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">match</span>(<span style="color:#e6db74">&#39;=&#39;</span>): consume(); <span style="color:#66d9ef">return</span> Token(LE, <span style="color:#e6db74">&#34;&lt;=&#34;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>: consume(); <span style="color:#66d9ef">return</span> Token(LESS, <span style="color:#e6db74">&#39;&lt;&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Token(EOF_Type, <span style="color:#e6db74">&#34;&lt;EOF&gt;&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">match</span>(c):   <span style="color:#75715e"># Lookahead: Ein Zeichen</span>
</span></span><span style="display:flex;"><span>    consume()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (peek <span style="color:#f92672">==</span> c): <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: rollBack(); <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span></span></span></code></pre></div><p>Um die Token &quot;<code>&lt;</code>&quot; und &quot;<code>&lt;=</code>&quot; unterscheiden zu k√∂nnen, m√ºssen wir ein Zeichen
vorausschauen: Wenn nach dem &quot;<code>&lt;</code>&quot; noch ein &quot;<code>=</code>&quot; kommt, ist es &quot;<code>&lt;=</code>&quot;, sonst
&quot;<code>&lt;</code>&quot;.</p>
<p>Erinnerung: Die Funktion <code>consume()</code> liest das n√§chste Zeichen aus dem
Eingabestrom und speichert den Wert in der globalen Variable <code>peek</code>.</p>
<p>F√ºr das Read-Ahead wird die Funktion <code>match()</code> definiert, die zun√§chst das
bereits bekannte Zeichen, in diesem Fall das &quot;<code>&lt;</code>&quot; durch das n√§chste Zeichen
im Eingabestrom ersetzt (Aufruf von <code>consume()</code>). Falls der Vergleich des
Lookahead-Zeichens mit dem gesuchten Zeichen erfolgreich ist, liegt das
&quot;gr√∂√üere&quot; Token vor, also &quot;<code>&lt;=</code>&quot;. Dann wird noch das &quot;<code>=</code>&quot; durch das n√§chste
Zeichen ersetzt und das Token <code>LE</code> gebildet. Anderenfalls muss das zuviel
gelesene Zeichen wieder in den Eingabestrom zur√ºckgelegt werden (<code>rollBack()</code>).</p>
<h2 id="puffern-des-input-stroms-double-buffering">Puffern des Input-Stroms: Double Buffering</h2>
<p>Das Einlesen einzelner Zeichen f√ºhrt zwar zu eleganten algorithmischen
L√∂sungen, ist aber zur Laufzeit deutlich &quot;teurer&quot; als das Einlesen mit
gepufferten I/O-Operationen, die eine ganze Folge von Zeichen einlesen
(typischerweise einen ganzen Disk-Block, beispielsweise 4096 Zeichen).</p>
<p>Dazu kann man einen Ringpuffer nutzen, den man mit Hilfe von zwei gleich
gro√üen <code>char</code>-Puffern mit jeweils der L√§nge 
<span class="math align-center">$N$</span> simulieren kann. (
<span class="math align-center">$N$</span>
sollte dann der L√§nge eines Disk-Blocks entsprechen.)</p>
<p>Vergleiche auch <a href="https://en.wikipedia.org/wiki/Circular_buffer" target="_blank">Wikipedia: &quot;Circular Buffer&quot;</a>.</p>
<p><a href="#R-image-c3a965fe57bd118c17a6cac8b403c507" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/recursive/doublebuffer.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c3a965fe57bd118c17a6cac8b403c507"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/recursive/doublebuffer.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; end <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; fill(buffer[<span style="color:#ae81ff">0</span>:n])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">consume</span>():
</span></span><span style="display:flex;"><span>    peek <span style="color:#f92672">=</span> buffer[start]
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> (start<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) mod <span style="color:#ae81ff">2</span>n
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (start mod n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>        fill(buffer[start:start<span style="color:#f92672">+</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>        end <span style="color:#f92672">=</span> (start<span style="color:#f92672">+</span>n) mod <span style="color:#ae81ff">2</span>n
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rollBack</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (start <span style="color:#f92672">==</span> end): <span style="color:#66d9ef">raise</span> Error(<span style="color:#e6db74">&#34;roll back error&#34;</span>)
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> (start<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) mod <span style="color:#ae81ff">2</span>n</span></span></code></pre></div><p>Zun√§chst wird nur der vordere Pufferteil durch einen passenden Systemaufruf
gef√ºllt.</p>
<p>Beim Weiterschalten im simulierten DFA oder im manuell kodierten Lexer
(Funktionsaufruf von <code>consume()</code>) wird das n√§chste Zeichen aus dem vorderen
Pufferteil zur√ºckgeliefert. √úber die Modulo-Operation bleibt der Pointer
<code>start</code> immer im Speicherbereich der beiden Puffer.</p>
<p>Wenn man das Ende des vorderen Puffers erreicht, wird der hintere Puffer mit
einem Systemaufruf gef√ºllt. Gleichzeitig wird ein Hilfspointer <code>end</code> auf
den Anfang des vorderen Puffers gesetzt, um Fehler beim Roll-Back zu erkennen.</p>
<p>Wenn man das Ende des hinteren Puffers erreicht, wird der vordere Puffer
nachgeladen und der Hilfspointer auf den Anfang des hinteren Puffers gesetzt.</p>
<p>Im Grunde ist also immer ein Puffer der &quot;Arbeitspuffer&quot; und der andere enth√§lt
die bereits gelesene (verarbeitete) Zeichenkette. Wenn beim Nachladen weniger
als 
<span class="math align-center">$N$</span> Zeichen gelesen werden, liefert der Systemaufruf als letztes &quot;Zeichen&quot;
ein <code>EOF</code>. Beim Verarbeiten wird <code>peek</code> entsprechend diesen Wert bekommen und
der Lexer muss diesen Wert abfragen und ber√ºcksichtigen.</p>
<p>F√ºr das Roll-Back wird der <code>start</code>-Pointer einfach dekrementiert (und mit einer
Modulo-Operation auf den Speicherbereich der beiden Puffer begrenzt). Falls
dabei der <code>end</code>-Pointer &quot;eingeholt&quot; wird, ist der <code>start</code>-Pointer durch beide
Puffer zur√ºckgelaufen und es gibt keinen fr√ºheren Input mehr. In diesem Fall
wird entsprechend ein Fehler gemeldet.</p>
<p><em>Anmerkung</em>: In der Regel sind die Lexeme kurz und man muss man nur ein bis
zwei Zeichen im Voraus lesen. Dann ist eine Puffergr√∂√üe von 4096 Zeichen mehr
als ausreichend gro√ü und man sollte nicht in Probleme laufen. Wenn der n√∂tige
Look-Ahead aber beliebig gro√ü werden kann, etwa bei Sprachen ohne reservierte
Schl√ºsselw√∂rtern oder bei Kontext-sensitiven Lexer-Grammatiken (denken Sie etwa
an die Einr√ºcktiefe bei Python), muss man andere Strategien verwenden. ANTLR
beispielsweise vergr√∂√üert in diesem Fall den Puffer dynamisch, alternativ k√∂nnte
man die Aufl√∂sung zwischen Schl√ºsselw√∂rtern und Bezeichnern dem Parser √ºberlassen.</p>
<h2 id="typische-muster-f√ºr-erstellung-von-token">Typische Muster f√ºr Erstellung von Token</h2>
<ol>
<li>
<p>Schl√ºsselw√∂rter</p>
<ul>
<li>Ein eigenes Token (RE/DFA) f√ºr jedes Schl√ºsselwort, oder</li>
<li>Erkennung als Name und Vergleich mit W√∂rterbuch
und nachtr√§gliche Korrektur des Tokentyps</li>
</ul>
<p>Wenn Schl√ºsselw√∂rter √ºber je ein eigenes Token abgebildet werden, ben√∂tigt
man f√ºr jedes Schl√ºsselwort einen eigenen RE bzw. DFA. Die Erkennung als
Bezeichner und das Nachschlagen in einem W√∂rterbuch (geeignete Hashtabelle)
sowie die entsprechende nachtr√§gliche Korrektur des Tokentyps kann die
Anzahl der Zust√§nde im Lexer signifikant reduzieren!</p>
</li>
<li>
<p>Operatoren</p>
<ul>
<li>Ein eigenes Token f√ºr jeden Operator, oder</li>
<li>Gemeinsames Token f√ºr jede Operatoren-Klasse</li>
</ul>
</li>
<li>
<p>Bezeichner: Ein gemeinsames Token f√ºr alle Namen</p>
</li>
<li>
<p>Zahlen: Ein gemeinsames Token f√ºr alle numerischen Konstante
(ggf. Integer und Float unterscheiden)</p>
<p>F√ºr Zahlen f√ºhrt man oft ein Token &quot;<code>NUM</code>&quot; ein. Als Attribut speichert man
das Lexem i.d.R. als String. Alternativ kann man (zus√§tzlich) das Lexem in
eine Zahl konvertieren und als (zus√§tzliches) Attribut speichern. Dies kann
in sp√§teren Stufen viel Arbeit sparen.</p>
</li>
<li>
<p>String-Literale: Ein gemeinsames Token</p>
</li>
<li>
<p>Komma, Semikolon, Klammern, ...: Je ein eigenes Token</p>
</li>
<li>
<p>Regeln f√ºr White-Space und Kommentare etc. ...</p>
<p>Normalerweise ben√∂tigt man Kommentare und White-Spaces in den folgenden
Stufen nicht und entfernt diese deshalb aus dem Eingabestrom. Dabei k√∂nnte
man etwa White-Spaces in den Pattern der restlichen Token ber√ºcksichtigen,
was die Pattern aber sehr komplex macht. Die Alternative sind zus√§tzliche
Pattern, die auf die White-Space und anderen nicht ben√∂tigten Inhalt
matchen und diesen &quot;ger√§uschlos&quot; entfernen. Mit diesen Pattern werden
keine Token erzeugt, d.h. der Parser und die anderen Stufen bemerken nichts
von diesem Inhalt.</p>
<p>Gelegentlich ben√∂tigt man aber auch Informationen √ºber White-Spaces,
beispielsweise in Python. Dann m√ºssen diese Token wie normale Token
an den Parser weitergereicht werden.</p>
</li>
</ol>
<p>Jedes Token hat i.d.R. ein Attribut, in dem das Lexem gespeichert wird. Bei
eindeutigen Token (etwa bei eigenen Token je Schl√ºsselwort oder bei den
Interpunktions-Token) kann man sich das Attribut auch sparen, da das Lexem
durch den Tokennamen eindeutig rekonstruierbar ist.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Token</th>
<th style="text-align:left">Beschreibung</th>
<th style="text-align:left">Beispiel-Lexeme</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>if</code></td>
<td style="text-align:left">Zeichen <code>i</code> und <code>f</code></td>
<td style="text-align:left"><code>if</code></td>
</tr>
<tr>
<td style="text-align:left"><code>relop</code></td>
<td style="text-align:left"><code>&lt;</code> oder <code>&gt;</code> oder <code>&lt;=</code> oder <code>&gt;=</code> oder <code>==</code> oder <code>!=</code></td>
<td style="text-align:left"><code>&lt;</code>, <code>&lt;=</code></td>
</tr>
<tr>
<td style="text-align:left"><code>id</code></td>
<td style="text-align:left">Buchstabe, gefolgt von Buchstaben oder Ziffern</td>
<td style="text-align:left"><code>pi</code>, <code>count</code>, <code>x3</code></td>
</tr>
<tr>
<td style="text-align:left"><code>num</code></td>
<td style="text-align:left">Numerische Konstante</td>
<td style="text-align:left"><code>42</code>, <code>3.14159</code>, <code>0</code></td>
</tr>
<tr>
<td style="text-align:left"><code>literal</code></td>
<td style="text-align:left">Alle Zeichen au√üer <code>&quot;</code>, in <code>&quot;</code> eingeschlossen</td>
<td style="text-align:left"><code>&quot;core dumped&quot;</code></td>
</tr>
</tbody>
</table>
<p><em>Anmerkung</em>: Wenn es mehrere matchende REs gibt, wird in der Regel das l√§ngste
Lexem bevorzugt. Wenn es mehrere gleich lange Alternativen gibt, muss man mit
Vorrangregeln bzgl. der Token arbeiten.</p>
<h2 id="fehler-bei-der-lexikalischen-analyse">Fehler bei der Lexikalischen Analyse</h2>
<p>Problem: Eingabestrom sieht so aus: <code>fi (a==42) { ... }</code></p>
<p>Der Lexer kann nicht erkennen, ob es sich bei <code>fi</code> um ein vertipptes
Schl√ºsselwort handelt oder um einen Bezeichner: Es k√∂nnte sich um einen
Funktionsaufruf der Funktion <code>fi()</code> handeln ...
Dieses Problem kann erst in der n√§chsten Stufe sinnvoll erkannt und behoben
werden.</p>
<p>=&gt; Was tun, wenn keines der Pattern auf den Anfang des Eingabestroms passt?</p>
<p>Optionen:</p>
<ul>
<li>
<p>Aufgeben ...</p>
<p>Eventuell vielleicht sogar die beste und einfachste Variante :-)</p>
</li>
<li>
<p>&quot;Panic Mode&quot;: Entferne so lange Zeichen, bis ein Pattern passt.</p>
<p>Das verwirrt u.U. den Parser, kann aber insbesondere in interaktiven
Umgebungen hilfreich sein. Ggf. kann man dem Parser auch signalisieren,
dass hier ein Problem vorlag.</p>
</li>
<li>
<p>Ein-Schritt-Transformationen:</p>
<ul>
<li>F√ºge fehlendes Zeichen in Eingabestrom ein.</li>
<li>Entferne ein Zeichen aus Eingabestrom.</li>
<li>Vertausche ein Zeichen:
<ul>
<li>Ersetze ein Zeichen durch ein anderes.</li>
<li>Vertausche zwei benachbarte Zeichen.</li>
</ul>
</li>
</ul>
<p>Diese Transformationen versuchen, den Input in einem Schritt zu reparieren.
Das ist durchaus sinnvoll, da in der Praxis die meisten Fehler in dieser
Stufe durch ein einzelnes Zeichen hervorgerufen werden: Es fehlt ein
Zeichen oder es ist eines zuviel im Input. Es liegt ein falsches Zeichen
vor (Tippfehler) oder zwei benachbarte Zeichen wurden verdreht ...</p>
<p>Im Prinzip k√∂nnte man auch eine allgemeinere Strategie versuchen, indem man
diejenige Transformation mit der <em>kleinsten Anzahl von Schritten</em> zur
Fehlerbehebung bestimmt. Beispiele daf√ºr finden sich im Bereich Natural
Language Processing (<em>NLP</em>), etwa die Levenshtein-Distanz oder der
SoundEx-Algorithmus oder sogar Hidden-Markov-Modelle. Allerdings muss
man sich in Erinnerung rufen, dass gerade in dieser ersten Phase eines
Compilers die Geschwindigkeit stark im Fokus steht und eine ausgefeilte
Fehlerkorrekturstrategie die vielen kleinen Optimierungen schnell wieder
zunichte machen kann.</p>
</li>
<li>
<p>Fehler-Regeln: Matche typische Typos</p>
<p>Gelegentlich findet man in den Grammatiken f√ºr den Lexer extra Regeln, die
h√§ufige bzw. typische Typos matchen und dann passend darauf reagieren.</p>
</li>
</ul>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Zusammenhang DFA, RE und Lexer</p>
</li>
<li>
<p>Implementierungsansatz: Manuell codiert (rekursiver Abstieg)</p>
</li>
<li>
<p>Read-Ahead</p>
</li>
<li>
<p>Puffern mit Doppel-Puffer-Strategie</p>
</li>
<li>
<p>Typische Fehler beim Scannen</p>
</li>
</ul>


    



    



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Abschnitt 2.6 und Kapitel 3</em></li> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 1 (insbesondere Abschnitt 1.8)</em></li> <li id='id_Torczon2012'>[Torczon2012] <strong>Engineering a Compiler</strong><br>Torczon, L. und Cooper, K., Elsevier MK, 2012. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-1208-8478-0' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-1208-8478-0</a>.<br><em>Kapitel 2</em></li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Lexer mit ANTLR generieren</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>ANTLR ist ein Parser-Generator, der aus einer Grammatik einen Parser in verschiedenen
Zielsprachen (Java, Python, C++, ...) generieren kann.</p>
<p>In der ANTLR-Grammatik werden die Parser-Regeln klein geschrieben, die Lexer-Regeln werden
mit <strong>Gro√übuchstaben</strong> geschrieben. Jede Lexer-Regel liefert ein Token zur√ºck, dabei
ist der Tokenname die linke Seite der Regel. Wie bei Flex gewinnt der l√§ngste Match,
und bei Gleichstand (mehrere l√§ngste Regeln matchen) gewinnt die zuerst definierte Regel.</p>
<p>Die Lexer-Regeln k√∂nnen mit Aktionen annotiert werden, die beim Matchen der jeweiligen Regel
abgearbeitet werden. Diese Aktionen m√ºssen in der Zielprogrammiersprache formuliert werden,
da sie in die generierte Lexerklasse in die jeweiligen Methoden eingebettet werden.</p>
<p>ANTLR kennt Lexer-Kommandos wie <code>skip</code> (entferne das aktuelle Zeichen), <code>more</code> (lese mehr
Input, um ein Token zu generieren) und andere. Mit &quot;Fragmenten&quot; kann man Hilfsregeln definieren,
die keine Token darstellen.</p>
<p>ANTLR kennt &quot;Modes&quot;, mit denen man zustandsbehaftete Lexer erzeugen kann. Dies ist n√ºtzlich
f√ºr &quot;Insel-Grammatiken&quot;, etwa f√ºr das Bearbeiten von XML oder HTML. Zus√§tzlich gibt es &quot;Channels&quot;
zum Vorsortieren von Tokens in verschiedene parallele Tokenstreams.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
        
        
            
        
    
        
        
            
        
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/I119N04WIYA' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Lexer mit ANTLR</a></li> <li><a href='https://youtu.be/pbjGThqVLkU' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Demo ANTLR Basics</a></li> <li><a href='https://youtu.be/vnJIm6S-898' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Demo Verhalten Lexer-Regeln</a></li> <li><a href='https://youtu.be/bNpgqctiQM8' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Demo Lexer-Regeln mit Aktionen</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/10e0ed907bb767e8304c0cf197293588f9497a217e0dee792c458887ec73299a415da96fd2ea12e0f054ba478772239ec2581db5cedadb3aba14203c590493d1' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Lexer mit ANTLR</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K3) Lexer-Regeln in ANTLR formulieren und einsetzen</li> <li>(K2) Verhalten des Lexers: l√§ngste Matches, Reihenfolge</li> <li>(K3) Nutzung von Lexer-Aktionen</li> <li>(K3) Einsatz von Fragmenten</li> <li>(K3) Nutzung von Lexer-Kommandos</li> <li>(K3) Zustandsbehaftete Lexer (Modes)</li> <li>(K3) Nutzung von Channels</li> <li>(K2) Importieren von Grammatiken</li></ul></div>
</div>




    <h2 id="hello-world">Hello World</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span><span style="color:#66d9ef">grammar</span> <span style="color:#a6e22e">Hello</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>start       : <span style="color:#e6db74">&#39;hello&#39;</span> <span style="color:#66d9ef">GREETING</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>GREETING    : [a-zA-Z]<span style="color:#f92672">+</span> ;
</span></span><span style="display:flex;"><span>WHITESPACE  : [ \t\n]<span style="color:#f92672">+</span> <span style="color:#f92672">-&gt;</span> skip ;</span></span></code></pre></div><div style="text-align: right;">
<span class="btn cstyle default">
  <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/lecture/frontend/lexing/src/Hello.g4" target="_blank">
    Konsole: Hello (Classpath, Aliase, grun, Main, Dateien, Ausgabe)
  </a>
</span></div>
<h3 id="hinweis-zur-grammatik-regeln">Hinweis zur Grammatik (Regeln)</h3>
<ul>
<li><code>start</code> ist eine <span class='alert'>Parser-Regel</span>
=&gt; Eine Parser-Regel pro Grammatik wird ben√∂tigt, damit man den generierten
Parser am Ende auch starten kann ...</li>
<li>Die anderen beiden Regeln (mit gro√üem Anfangsbuchstaben) aus der obigen Grammatik
z√§hlen zum Lexer</li>
</ul>
<h3 id="antlr-einrichten">ANTLR einrichten</h3>
<ul>
<li>Aktuelle Version herunterladen: <a href="https://www.antlr.org/download.html" target="_blank">antlr.org</a>,
f√ºr Java als Zielsprache: <a href="https://www.antlr.org/download/antlr-4.11.1-complete.jar" target="_blank">&quot;Complete ANTLR 4.x Java binaries jar&quot;</a></li>
<li>CLASSPATH setzen: <code>export CLASSPATH=&quot;.:/&lt;pathToJar&gt;/antlr-4.11.1-complete.jar:$CLASSPATH&quot;</code></li>
<li>Aliase einrichten (<code>.bashrc</code>):
<ul>
<li><code>alias antlr='java org.antlr.v4.Tool'</code></li>
<li><code>alias grun='java org.antlr.v4.gui.TestRig'</code></li>
</ul>
</li>
<li>Alternativ √ºber den Python-Installer: <code>pip install antlr4-tools</code></li>
<li>Im Web ohne lokale Installation: <a href="http://lab.antlr.org/" target="_blank">ANTLR Lab</a></li>
</ul>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/getting-started.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/getting-started.md</a>)</p>
<h3 id="hello-world-√ºbersetzen-und-ausf√ºhren">&quot;Hello World&quot; √ºbersetzen und ausf√ºhren</h3>
<ol>
<li>Grammatik √ºbersetzen und Code generieren: <code>antlr Hello.g4</code></li>
<li>Java-Code kompilieren: <code>javac *.java</code></li>
<li>Lexer ausf√ºhren:
<ul>
<li>
<p><code>grun Hello start -tokens</code> (Grammatik &quot;Hello&quot;, Startregel &quot;start&quot;)</p>
</li>
<li>
<p>Alternativ mit kleinem Java-Programm:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> org.antlr.v4.runtime.*<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        Lexer l <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HelloLexer<span style="color:#f92672">(</span>CharStreams<span style="color:#f92672">.</span><span style="color:#a6e22e">fromStream</span><span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        Token t <span style="color:#f92672">=</span> l<span style="color:#f92672">.</span><span style="color:#a6e22e">nextToken</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>t<span style="color:#f92672">.</span><span style="color:#a6e22e">getType</span><span style="color:#f92672">()</span> <span style="color:#f92672">!=</span> Token<span style="color:#f92672">.</span><span style="color:#a6e22e">EOF</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>t<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            t <span style="color:#f92672">=</span> l<span style="color:#f92672">.</span><span style="color:#a6e22e">nextToken</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div></li>
</ul>
</li>
</ol>
<h3 id="generierte-dateien-und-klassen">Generierte Dateien und Klassen</h3>
<p>Nach dem √úbersetzen finden sich folgende Dateien und Klassen vor:</p>
<pre><code>.
‚îú‚îÄ‚îÄ bin
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ HelloBaseListener.class
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ HelloBaseVisitor.class
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ HelloLexer.class
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ HelloListener.class
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ HelloParser.class
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ HelloParser$RContext.class
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ HelloVisitor.class
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Main.class
‚îú‚îÄ‚îÄ Hello.g4
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ HelloBaseListener.java
    ‚îú‚îÄ‚îÄ HelloBaseVisitor.java
    ‚îú‚îÄ‚îÄ HelloLexer.java
    ‚îú‚îÄ‚îÄ HelloLexer.tokens
    ‚îú‚îÄ‚îÄ HelloListener.java
    ‚îú‚îÄ‚îÄ HelloParser.java
    ‚îú‚îÄ‚îÄ Hello.tokens
    ‚îú‚îÄ‚îÄ HelloVisitor.java
    ‚îî‚îÄ‚îÄ Main.java
</code></pre>
<p><em>Anmerkung</em>: Die Ordnerstruktur wurde durch ein ANTLR-Plugin f√ºr Eclipse
erzeugt. Bei Ausf√ºhrung in der Konsole liegen alle Dateien in einem Ordner.</p>
<p><em>Anmerkung</em>: Per Default werden nur die Listener angelegt, f√ºr die Visitoren
muss eine extra Option mitgegeben werden.</p>
<p>Die Dateien <code>Hello.tokens</code> und <code>HelloLexer.tokens</code> enthalten die Token samt
einer internen Nummer. (Der Inhalt beider Dateien ist identisch.)</p>
<p>Die Datei <code>HelloLexer.java</code> enth√§lt den generierten Lexer, der eine
Spezialisierung der abstrakten Basisklasse <code>Lexer</code> darstellt. √úber den
Konstruktor wird der zu scannende <code>CharStream</code> gesetzt. √úber die Methode
<code>Lexer#nextToken()</code> kann man sich die erkannten Token der Reihe nach
zur√ºckgeben lassen. (Diese Methode wird letztlich vom Parser benutzt.)</p>
<p>Die restlichen Dateien werden f√ºr den Parser und verschiedene Arten der
Traversierung des AST generiert (vgl.
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/astdriven-part1.html">AST-basierte Interpreter</a>).</p>
<h3 id="bedeutung-der-ausgabe">Bedeutung der Ausgabe</h3>
<p>Wenn man dem Hello-Lexer die Eingabe</p>
<pre><code>hello world
&lt;EOF&gt;
</code></pre>
<p>(das <code>&lt;EOF&gt;</code> wird durch die Tastenkombination <code>STRG-D</code> erreicht) gibt, dann
lautet die Ausgabe</p>
<pre><code>$ grun Hello start -tokens
hello world
&lt;EOF&gt;
[@0,0:4='hello',&lt;'hello'&gt;,1:0]
[@1,6:10='world',&lt;GREETING&gt;,1:6]
[@2,12:11='&lt;EOF&gt;',&lt;EOF&gt;,2:0]
</code></pre>
<p>Die erkannten Token werden jeweils auf einer eigenen Zeile ausgegeben.</p>
<ul>
<li><code>@0</code>: Das erste Token (fortlaufend nummeriert, beginnend mit 0)</li>
<li><code>0:4</code>: Das Token umfasst die Zeichen 0 bis 4 im Eingabestrom</li>
<li><code>='hello'</code>: Das gefundene Lexem (Wert des Tokens)</li>
<li><code>&lt;'hello'&gt;</code>: Das Token (Name/Typ des Tokens)</li>
<li><code>1:0</code>: Das Token wurde in Zeile 1 gefunden (Start der Nummerierung mit
Zeile 1), und startet in dieser Zeile an Position 0</li>
</ul>
<p>Entsprechend bekommt man mit</p>
<pre><code>$ grun Hello start -tokens
hello
  world

&lt;EOF&gt;
[@0,0:4='hello',&lt;'hello'&gt;,1:0]
[@1,8:12='world',&lt;GREETING&gt;,2:2]
[@2,15:14='&lt;EOF&gt;',&lt;EOF&gt;,4:0]
</code></pre>
<h3 id="antlr-grammatik-f√ºr-die-lexer-generierung">ANTLR-Grammatik f√ºr die Lexer-Generierung</h3>
<ul>
<li>
<p>Start der Grammatik mit dem Namen &quot;<code>XYZ</code>&quot; mit</p>
<pre><code>grammar XYZ;
</code></pre>
<p>oder (nur Lexer)</p>
<pre><code>lexer grammar XYZ;
</code></pre>
</li>
<li>
<p>Token und Lexer-Regeln starten mit <em>gro√üen Anfangsbuchstaben</em>
(Ausblick: Parser-Regeln starten mit kleinen Anfangsbuchstaben)</p>
<p>Format: <code>TokenName : Alternative1 | ... | AlternativeN ;</code></p>
<p>Rekursive Lexer-Regeln sind erlaubt. <strong>Achtung</strong>: Es d√ºrfen keine
<em>links-rekursiven</em> Regeln genutzt werden, etwa wie <code>ID : ID '*' ID ;</code> ...
(Eine genauere Definition und die Transformation in nicht-linksrekursive
Regeln siehe <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory.html">LL-Parser</a>).</p>
</li>
<li>
<p>Alle Literale werden in <em>einfache</em> Anf√ºhrungszeichen eingeschlossen
(es erfolgt keine Unterscheidung zwischen einzelnen Zeichen und Strings
wie in anderen Sprachen)</p>
</li>
<li>
<p>Zeichenmengen: <code>[a-z\n]</code> umfasst alle Zeichen von <code>'a'</code> bis <code>'z'</code> sowie
<code>'\n'</code></p>
<p><code>'a'..'z'</code> ist identisch zu <code>[a-z]</code></p>
</li>
<li>
<p>Schl√ºsselw√∂rter: Die folgenden Strings stellen reservierte Schl√ºsselw√∂rter
dar und d√ºrfen nicht als Token, Regel oder Label genutzt werden:</p>
<pre><code>import, fragment, lexer, parser, grammar, returns, locals, throws, catch, finally, mode, options, tokens
</code></pre>
<p><em>Anmerkung</em>: <code>rule</code> ist zwar kein Schl√ºsselwort, wird aber als Methodenname
bei der Codegenerierung verwendet. =&gt; Wie ein Schl√ºsselwort behandeln!</p>
</li>
</ul>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/lexicon.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/lexicon.md</a>)</p>
<h3 id="greedy-und-non-greedy-lexer-regeln">Greedy und Non-greedy Lexer-Regeln</h3>
<p>Die regul√§ren Ausdr√ºcke <code>(...)?</code>, <code>(...)*</code> und <code>(...)+</code> sind <em>greedy</em> und
versuchen soviel Input wie m√∂glich zu matchen.</p>
<p>Falls dies nicht sinnvoll sein sollte, kann man mit einem weiteren <code>?</code> das
Verhalten auf <em>non-greedy</em> umschalten. Allerdings k√∂nnen non-greedy Regeln
das Verhalten des Lexers u.U. schwer vorhersehbar machen!</p>
<p>Die Empfehlung ist, non-greedy Lexer-Regeln nur sparsam einzusetzen
(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/wildcard.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/wildcard.md</a>).</p>
<h2 id="verhalten-des-lexers-1-l√§ngster-match">Verhalten des Lexers: 1. L√§ngster Match</h2>
<p>Prim√§res Ziel: Erkennen der l√§ngsten Zeichenkette</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>CHARS   : [a-z]<span style="color:#f92672">+</span> ;
</span></span><span style="display:flex;"><span>DIGITS  : [0-9]<span style="color:#f92672">+</span> ;
</span></span><span style="display:flex;"><span>FOO     : [a-z]<span style="color:#f92672">+</span> [0-9]<span style="color:#f92672">+</span> ;</span></span></code></pre></div><p>Die Regel, die den l√§ngsten Match f√ºr die aktuelle Eingabesequenz produziert,
&quot;gewinnt&quot;.</p>
<p>Im Beispiel w√ºrde ein &quot;foo42&quot; als <code>FOO</code> erkannt und nicht als <code>CHARS DIGITS</code>.</p>
<h2 id="verhalten-des-lexers-2-reihenfolge">Verhalten des Lexers: 2. Reihenfolge</h2>
<p>Reihenfolge in Grammatik definiert Priorit√§t</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>FOO     : <span style="color:#e6db74">&#39;f&#39;</span> <span style="color:#f92672">.*?</span> <span style="color:#e6db74">&#39;r&#39;</span> ;
</span></span><span style="display:flex;"><span>BAR     : <span style="color:#e6db74">&#39;foo&#39;</span> <span style="color:#f92672">.*?</span> <span style="color:#e6db74">&#39;bar&#39;</span> ;</span></span></code></pre></div><p>Falls mehr als eine Lexer-Regel die selbe Inputsequenz matcht, dann
hat die in der Grammatik zuerst genannte Regel Priorit√§t.</p>
<p>Im Beispiel w√ºrden f√ºr die Eingabe &quot;foo42bar&quot; beide Regeln den selben l√§ngsten
Match liefern - die Regel <code>FOO</code> ist in der Grammatik fr√ºher definiert und
&quot;gewinnt&quot;.</p>
<h2 id="verhalten-des-lexers-3-non-greedy-regeln">Verhalten des Lexers: 3. Non-greedy Regeln</h2>
<p>Non-greedy Regeln versuchen <em>so wenig</em> Zeichen wie m√∂glich zu matchen</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>FOO     : <span style="color:#e6db74">&#39;foo&#39;</span> <span style="color:#f92672">.*?</span> <span style="color:#e6db74">&#39;bar&#39;</span> ;
</span></span><span style="display:flex;"><span>BAR     : <span style="color:#e6db74">&#39;bar&#39;</span> ;</span></span></code></pre></div><p>Hier w√ºrde ein &quot;foo42barbar&quot; zu <code>FOO</code> gefolgt von <code>BAR</code> erkannt werden.</p>
<p><span class='alert'>Achtung</span>: Nach dem Abarbeiten einer non-greedy Sub-Regel in einer Lexer-Regel
gilt &quot;<em>first match wins</em>&quot;</p>
<p><code>.*? ('4' | '42')</code></p>
<p>=&gt; Der Teil <code>'42'</code> auf der rechten Seite ist
&quot;toter Code&quot; (wegen der non-greedy Sub-Regel <code>.*?</code>)!</p>
<p>Die Eingabe &quot;x4&quot; w√ºrde korrekt erkannt, w√§hrende &quot;x42&quot; nur als &quot;x4&quot; erkannt wird und f√ºr
die verbleibende &quot;2&quot; w√ºrde ein <em>token recognition error</em> geworfen.</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/wildcard.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/wildcard.md</a>)</p>
<h2 id="attribute-und-aktionen">Attribute und Aktionen</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span><span style="color:#66d9ef">grammar</span> <span style="color:#a6e22e">Demo</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@header {
</span></span><span style="display:flex;"><span>import java.util.*;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@members {
</span></span><span style="display:flex;"><span>String s = &#34;&#34;;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>start   : <span style="color:#66d9ef">TYPE</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> <span style="color:#66d9ef">INT</span> <span style="color:#e6db74">&#39;;&#39;</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>TYPE    : <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;float&#39;</span><span style="color:#f92672">)</span> {s = getText();} ;
</span></span><span style="display:flex;"><span>INT     : [0-9]<span style="color:#f92672">+</span>            {System.out.println(s+&#34;:&#34;+Integer.valueOf(getText()));};
</span></span><span style="display:flex;"><span>ID      : [a-z]<span style="color:#f92672">+</span>            {setText(String.valueOf(getText().charAt(0)));} ;
</span></span><span style="display:flex;"><span>WS      : [ \t\n]<span style="color:#f92672">+</span> <span style="color:#f92672">-&gt;</span> skip ;</span></span></code></pre></div><h3 id="attribute-bei-token-auswahl">Attribute bei Token (Auswahl)</h3>
<p>Token haben Attribute, die man abfragen kann. Dies umfasst u.a. folgende Felder:</p>
<ul>
<li><code>text</code>: Das gefundene Lexem als String</li>
<li><code>type</code>: Der Token-Typ als Integer</li>
<li><code>index</code>: Das wievielte Token (als Integer)</li>
</ul>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/actions.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/actions.md</a>)</p>
<p>Zur Auswertung in den Lexer-Regeln muss man anders vorgehen als in
Parser-Regeln: Nach der Erstellung eines Tokens kann man die zum Attribut
geh√∂renden <code>getX()</code> und <code>setX()</code>-Methoden aufrufen, um die Werte abzufragen
oder zu √§ndern.</p>
<p>Dies passiert im obigen Beispiel f√ºr das Attribut <code>text</code>: Abfrage mit
<code>getText()</code>, √Ñndern/Setzen mit <code>setText()</code>.</p>
<p>Die Methodenaufrufe wirken sich immer auf das gerade erstellte Token aus.</p>
<p><em>Achtung</em>: Bei Aktionen in Parser-Regeln gelten andere Spielregeln!</p>
<h3 id="aktionen-mit-den-lexer-regeln">Aktionen mit den Lexer-Regeln</h3>
<p>Aktionen f√ºr Lexer-Regeln sind Code-Bl√∂cke in der Zielsprache, eingeschlossen
in geschweifte Klammern. Die Code-Bl√∂cke werden direkt in die generierten
Lexer-Methoden kopiert.</p>
<p>Zus√§tzlich:</p>
<ul>
<li><code>@header</code>: Package-Deklarationen und/oder Importe (wird vor der
Klassendefinition eingef√ºgt)</li>
<li><code>@members</code>: zus√§tzliche Attribute f√ºr die generierten Lexer- (und
Parser-) Klassen.</li>
</ul>
<p>Mit <code>@lexer::header</code> bzw. <code>@lexer::members</code> werden diese Codebl√∂cke nur in den
generierten Lexer eingef√ºgt.</p>
<p><em>Anmerkung</em>: Lexer-Aktionen m√ºssen am Ende der √§u√üersten Alternative erscheinen.
Wenn eine Lexer-Regel mehr als eine Alternative hat, m√ºssen diese in runde
Klammern eingeschlossen werden.</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/grammars.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/grammars.md</a>)</p>
<h2 id="hilfsregeln-mit-fragmenten">Hilfsregeln mit Fragmenten</h2>
<p>Fragmente sind Lexer-Regeln, die keine Token darstellen/erzeugen, aber
bei der Formulierung von Regeln f√ºr mehr √úbersicht oder Wiederverwendung
sorgen. Fragmente werden mit dem Schl√ºsselwort <code>fragment</code> eingeleitet.</p>
<p><strong>Beispiel</strong>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>NUM         : <span style="color:#66d9ef">DIGIT</span><span style="color:#f92672">+</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fragment</span>
</span></span><span style="display:flex;"><span>DIGIT       : [0-9] ;</span></span></code></pre></div><p>=&gt; Keine Token (f√ºr den Parser)!</p>
<p>Hier w√ºrde der Parser nur <code>NUM</code> &quot;bekommen&quot;, aber keine <code>DIGIT</code>-Token.</p>
<h2 id="lexer-kommandos-auswahl">Lexer Kommandos (Auswahl)</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>TokenName : <span style="color:#66d9ef">Alternative</span> <span style="color:#f92672">-&gt;</span> command<span style="color:#960050;background-color:#1e0010">-</span>name</span></span></code></pre></div><ul>
<li>
<p><code>skip</code></p>
<p>Verwerfe den aktuellen Text: <code>WS : [ \t]+ -&gt; skip ;</code>
(liefert kein Token)</p>
</li>
<li>
<p><code>more</code></p>
<p>Lese weiter ...</p>
<p>Die Regel matcht zwar, aber es wird kein Token erzeugt. Die n√§chste
matchende Regel wird den hier gematchten Text mit in ihr Token einbauen.
Der Token-Typ ist der der zuletzt matchenden Regel.</p>
<p><em>Anmerkung</em>: Wird typischerweise zusammen mit Modes verwendet.</p>
</li>
<li>
<p><code>mode</code> (siehe unten)</p>
</li>
<li>
<p><code>channel</code> (siehe unten)</p>
</li>
</ul>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/lexer-rules.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/lexer-rules.md</a>)</p>
<h2 id="modes-und-insel-grammatiken">Modes und Insel-Grammatiken</h2>
<p>Umschalten zwischen verschiedenen Lexer-Modes: Wie verschiedene Sub-Lexer -
einen f√ºr jeden Kontext.</p>
<p>=&gt; Parsen von &quot;<em>Insel-Grammatiken</em>&quot; (beispielsweise XML).</p>
<p><em>Anmerkung</em>: <code>mode</code>-Spezifikation sind nur im Lexer-Teil der Grammatik erlaubt.</p>
<h3 id="allgemeines-schema">Allgemeines Schema</h3>
<pre><code>rules in default mode
...

mode MODE_1;
rules in MODE_1
...

mode MODE_N;
rules in MODE_N
...
</code></pre>
<h3 id="beispiel">Beispiel</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span><span style="color:#66d9ef">lexer</span> <span style="color:#66d9ef">grammar</span> <span style="color:#a6e22e">ModeLexer</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LCOMMENT    : <span style="color:#e6db74">&#39;/*&#39;</span> <span style="color:#f92672">-&gt;</span> more, mode<span style="color:#f92672">(</span><span style="color:#66d9ef">CMNT</span><span style="color:#f92672">)</span> ;
</span></span><span style="display:flex;"><span>WS          : [ \t\n]<span style="color:#f92672">+</span> <span style="color:#f92672">-&gt;</span> skip ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mode <span style="color:#960050;background-color:#1e0010">CMNT;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">COMMENT</span>     : <span style="color:#e6db74">&#39;*/&#39;</span> <span style="color:#f92672">-&gt;</span> mode<span style="color:#f92672">(</span><span style="color:#66d9ef">DEFAULT_MODE</span><span style="color:#f92672">)</span> ;
</span></span><span style="display:flex;"><span>CHAR        : <span style="color:#f92672">.</span> <span style="color:#f92672">-&gt;</span> more ;</span></span></code></pre></div><p>Nach dem Matchen des Tokens wird mit <code>mode(X)</code> in den Mode <code>X</code> umgeschaltet.
Der Lexer beachtet dann nur die Lexer-Regeln unter Mode <code>X</code>.</p>
<p>Mit <code>pushMode(X)</code> erreicht man das selbe Verhalten wie mit <code>mode(X)</code>,
allerdings wird vor dem Umschalten der aktuelle Mode auf einem Stack abgelegt.
Mit <code>popMode</code> kann der oberste Mode vom Stack wieder herunter genommen werden
und als aktueller Lexer-Mode gesetzt werden.</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/lexer-rules.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/lexer-rules.md</a>)</p>
<h2 id="channels">Channels</h2>
<p>Man kann die Token in verschiedene Kan√§le (&quot;Channels&quot;) schicken. Beispielsweise
werden beim Parsen von Python-Programmen die White-Spaces evtl. noch ben√∂tigt.</p>
<p>Anstatt diese mit <code>skip</code> komplett zu verwerfen, kann man sie in einen anderen
Channel schicken, wo man sie im Parser bei Bedarf wieder abfragen kann. Der
Token-Index bleibt dabei erhalten, auch wenn die Token in verschiedene Kan√§le
verteilt werden.</p>
<p><strong>Anmerkung</strong>: Channel-Spezifikationen sind nur im Lexer-Teil der Grammatik
erlaubt.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>channels { WHITESPACE, COMMENTS }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">BLOCK_COMMENT</span> : <span style="color:#e6db74">&#39;/*&#39;</span> <span style="color:#f92672">.*?</span> <span style="color:#e6db74">&#39;*/&#39;</span> <span style="color:#f92672">-&gt;</span> channel<span style="color:#f92672">(</span><span style="color:#66d9ef">COMMENTS</span><span style="color:#f92672">)</span> ;
</span></span><span style="display:flex;"><span>LINE_COMMENT  : <span style="color:#e6db74">&#39;//&#39;</span> <span style="color:#f92672">~</span>[\n]<span style="color:#f92672">*</span>   <span style="color:#f92672">-&gt;</span> channel<span style="color:#f92672">(</span><span style="color:#66d9ef">COMMENTS</span><span style="color:#f92672">)</span> ;
</span></span><span style="display:flex;"><span>WS            : [ \t\n]<span style="color:#f92672">+</span>      <span style="color:#f92672">-&gt;</span> channel<span style="color:#f92672">(</span><span style="color:#66d9ef">WHITESPACE</span><span style="color:#f92672">)</span> ;</span></span></code></pre></div><h2 id="grammatiken-importieren">Grammatiken importieren</h2>
<p>Mit <code>import XZY;</code> bindet man eine andere Grammatik <code>XYZ</code> ein. Dabei werden nur
Regeln eingebunden, die bisher noch nicht definiert wurden.</p>
<p>Aus einer anderen Perspektive kann man diesen Mechanismus mit dem √úberschreiben
von Methoden in einer abgeleiteten Klasse vergleichen: Dann bekommt man beim
Aufruf einer √ºberschriebenen Methode ebenfalls nur die &quot;neueste&quot;
Implementierung ...</p>
<p>Wenn mehrere verschachtelte Grammatiken eingebunden werden (wie im Beispiel),
dann wird per <em>Tiefensuche</em> der Einbindungsbaum durchlaufen.</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/grammars.md#grammar-imports" target="_blank">github.com/antlr/antlr4/blob/master/doc/grammars.md</a>)</p>
<h2 id="wrap-up">Wrap-Up</h2>
<p>Lexer mit ANTLR generieren: Lexer-Regeln werden mit <strong>Gro√übuchstaben</strong> geschrieben</p>
<ul>
<li>L√§ngster Match gewinnt, Gleichstand: zuerst definierte Regel</li>
<li><em>non greedy</em>-Regeln: versuche so <em>wenig</em> Zeichen zu matchen wie m√∂glich</li>
<li>Aktionen beim Matchen</li>
<li>Hilfsregeln mit &quot;Fragments&quot;</li>
<li>Lexer Kommandos: <code>skip</code>, <code>more</code>, ...</li>
<li>Modes f√ºr Insel-Grammatiken</li>
<li>Channels als parallele Tokenstreams (Vorsortieren)</li>
<li>Teilgrammatiken importieren</li>
</ul>


    



    



    

    
<div class="box notices cstyle note">
  <div class="box-label"><i class="fas fa-puzzle-piece"></i> Challenges</div>
  <div class="box-content">

<p><strong>Token und Lexer-Regeln mit ANTLR</strong></p>
<p>Formulieren Sie f√ºr ANTLR Lexer-Regeln, mit denen folgende Token erkannt werden:</p>
<ul>
<li>White-Space: Leerzeichen, Tabs, Zeilenumbr√ºche</li>
<li>Vergleichsoperatoren: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>&lt;&gt;</code></li>
<li>If: <code>if</code></li>
<li>Then: <code>then</code></li>
<li>Else: <code>else</code></li>
<li>Namen: Ein Buchstabe, gefolgt von beliebig vielen weiteren Buchstaben und/oder Ziffern</li>
<li>Numerische Konstanten: Mindestens eine Ziffer, gefolgt von maximal einem Paar bestehend aus einem Punkt und mindestens einer Ziffer, gefolgt von maximal einem Paar bestehend aus dem Buchstaben &quot;E&quot; gefolgt von einem &quot;+&quot; oder &quot;-&quot; und mindestens einer Ziffer.</li>
</ul>
<p>Formulieren Sie Hilfskonstrukte zur Verwendung in mehreren Lexer-Regeln als ANTLR-Fragmente.</p>
<p>White-Spaces sollen entfernt werden und nicht als Token weitergereicht werden.</p>
<p><strong>Real-World-Lexer mit ANTLR: Programmiersprache Lox</strong></p>
<p>Betrachten Sie folgenden Code-Schnipsel in der Sprache <a href="https://www.craftinginterpreters.com/the-lox-language.html" target="_blank">&quot;Lox&quot;</a>:</p>
<pre><code>fun fib(x) {
    if (x == 0) {
        return 0;
    } else {
        if (x == 1) {
            return 1;
        } else {
            fib(x - 1) + fib(x - 2);
        }
    }
}

var wuppie = fib(4);
</code></pre>
<p>Erstellen Sie f√ºr diese fiktive Sprache einen Lexer mit ANTLR. Die genauere Sprachdefinition finden Sie unter <a href="https://www.craftinginterpreters.com/the-lox-language.html" target="_blank">craftinginterpreters.com/the-lox-language.html</a>.</p>
<p><strong>Pig-Latin mit ANTLR-Lexer</strong></p>
<p>Schreiben Sie eine Lexer-Grammatik mit eingebetteten Aktionen f√ºr ANTLR sowie ein passendes Programm zur Einbindung des generierten Lexers, welches einen Text nach <a href="https://de.wikipedia.org/wiki/Pig_Latin" target="_blank">Pig Latin</a> √ºbersetzt:</p>
<ul>
<li>Ist der erste Buchstabe eines Wortes ein Konsonant, schiebe ihn ans Ende des Wortes und f√ºge &quot;ay&quot; an.</li>
<li>Ist der erste Buchstabe eines Wortes ein Vokal, h√§nge an das Wort ein &quot;ay&quot; an.</li>
</ul>
<p><strong>Lexing mit ANTLR</strong></p>
<p>In einem Telefonbuch sind zeilenweise Namen und Telefonnummern gespeichert.</p>
<p>Definieren Sie eine Lexer-Grammatik f√ºr ANTLR, mit der Sie die Zeilen einlesen k√∂nnen. K√∂nnen Sie dabei verschiedene Formate der Telefonnummern ber√ºcksichtigen?</p>
<pre><code>Heinz 030 5346 983
Kalle +49 30 1234 567
Lina +49.571.8385-255
Rosi (0571) 8385-268
</code></pre>
<p>K√∂nnen Sie die Grammatik so anpassen, dass Sie nur m√∂glichst wenige verschiedene Token an den Parser weitergeben?</p>
<p>Erg√§nzen Sie Ihre Grammatik um Lexer-Aktionen, so dass Sie die Zeilen, die Zeichen (in den Namen) und die Ziffern (in den Telefonnummern) z√§hlen k√∂nnen.</p>
</div>
</div>



    





    




    
    
        
        

        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

          </section>
          <article class="default">
            <header class="headline">
            </header>
<h1 id="parser">Parser</h1>

<p>Der Parser arbeitet mit dem Tokenstrom, der vom Lexer kommt. Mit Hilfe einer Grammatik wird
gepr√ºft, ob hier g√ºltige S√§tze im Sinne der Sprache/Grammatik gebildet wurden. Der Parser
erzeugt dabei den Parse-Tree.</p>

<ul class="children children-li children-sort-">
	
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/cfg.html">CFG</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory.html">LL-Parser (Theorie)</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-impl.html">LL-Parser selbst implementiert</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html">LL-Parser: Fortgeschrittene Techniken</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing.html">Parser mit ANTLR generieren</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/finalwords.html">Grenze Lexer und Parser</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser1.html">Syntaxanalyse: LR-Parser (Teil 1)</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2.html">Syntaxanalyse: LR-Parser (Teil 2)</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery.html">Error-Recovery</a></li>
</ul>

            <footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Parser</h1>
<article class="default">
<h1>CFG</h1>



    
    




    
    
        
        
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="far fa-file-powerpoint"></i> Annotierte Folien</div>
  <div class="box-content">

<ul> <li><a href='https://raw.githubusercontent.com/Compiler-CampusMinden/AnnotatedSlides/master/frontend_parsing_cfg.ann.ma.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Annotierte Folien: CFG, LL-Parser</a></li></ul></div>
</div>




    <h1 id="wiederholung">Wiederholung</h1>
<h2 id="endliche-automaten-regul√§re-ausdr√ºcke-regul√§re-grammatiken-regul√§re-sprachen">Endliche Automaten, regul√§re Ausdr√ºcke, regul√§re Grammatiken, regul√§re Sprachen</h2>
<ul>
<li>Wie sind DFAs und NFAs definiert?</li>
<li>Was sind regul√§re Ausdr√ºcke?</li>
<li>Was sind formale und regul√§re Grammatiken?</li>
<li>In welchem Zusammenhang stehen all diese Begriffe?</li>
<li>Wie werden DFAs und regul√§re Ausdr√ºcke im Compilerbau eingesetzt?</li>
</ul>
<h1 id="motivation">Motivation</h1>
<h2 id="wof√ºr-reichen-regul√§re-sprachen-nicht">Wof√ºr reichen regul√§re Sprachen nicht?</h2>
<p>F√ºr z. B. alle Sprachen, in deren W√∂rtern Zeichen √ºber eine Konstante hinaus gez√§hlt werden m√ºssen. Diese Sprachen lassen sich oft mit Variablen im Exponenten beschreiben, die unendlich viele Werte annehmen k√∂nnen.</p>
<ul>
<li>
<p>
<span class="math align-center">$a^ib^{2*i}$</span> ist nicht regul√§r</p>
</li>
<li>
<p>
<span class="math align-center">$a^ib^{2*i}$</span> f√ºr 
<span class="math align-center">$0 \leq i \leq 3$</span> ist regul√§r</p>
</li>
<li>
<p>Wo finden sich die oben genannten VAriablen bei einem DFA wieder?</p>
</li>
<li>
<p>Warum ist die erste Sprache oben nicht regul√§r, die zweite aber?</p>
</li>
</ul>
<h2 id="themen-f√ºr-heute">Themen f√ºr heute</h2>
<ul>
<li>PDAs: m√§chtiger als DFAs, NFAs</li>
<li>kontextfreie Grammatiken und Sprachen: m√§chtiger als regul√§re Grammatiken und Sprachen</li>
<li>DPDAs und deterministisch kontextfreie Grammatiken: die Grundlage der Syntaxanalyse im Compilerbau</li>
</ul>
<h2 id="einordnung-erweiterung-der-automatenklasse-dfa-um-komplexere-sprachen-als-die-regul√§ren-akzeptieren-zu-k√∂nnen">Einordnung: Erweiterung der Automatenklasse DFA, um komplexere Sprachen als die regul√§ren akzeptieren zu k√∂nnen</h2>
<p>Wir spendieren den DFAs einen m√∂glichst einfachen, aber beliebig gro√üen, Speicher, um z√§hlen und matchen zu k√∂nnen. Wir suchen dabei konzeptionell die &quot;kleinstm√∂gliche&quot; Erweiterung, die die akzeptierte Sprachklasse gegen√ºber DFAs vergr√∂√üert.</p>
<ul>
<li>Der konzeptionell einfachste Speicher ist ein Stack. Wir haben keinen wahlfreien Zugriff auf die gespeicherten Werte.</li>
<li>Es soll eine deterministische und eine indeterministische Variante der neuen Automatenklasse geben.</li>
<li>In diesem Zusammenhang wird der Stack auch Keller genannt.</li>
</ul>
<h2 id="kellerautomaten-push-down-automata-pdas">Kellerautomaten (Push-Down-Automata, PDAs)</h2>
<p><strong>Def.:</strong> Ein Kellerautomat (PDA) 
<span class="math align-center">$P = (Q,\ \Sigma,\ \Gamma,\  \delta,\ q_0,\ \perp,\ F)$</span>
ist ein Septupel mit:</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/cfg/Def_PDA.png" alt="Definition eines PDAs" width="60%" height="auto">
    <figcaption><p>Definition eines PDAs</p></figcaption>
</figure>
<p>Ein PDA ist per Definition nichtdeterministisch und kann spontane Zustands√ºberg√§nge durchf√ºhren.</p>
<h2 id="was-kann-man-damit-akzeptieren">Was kann man damit akzeptieren?</h2>
<p>Strukturen mit paarweise zu matchenden Symbolen.</p>
<p>Bei jedem Zustands√ºbergang wird ein Zeichen (oder 
<span class="math align-center">$\epsilon$</span>) aus der Eingabe gelesen, ein Symbol von Keller genommen. Diese und das Eingabezeichen bestimmen den Folgezustand und eine Zeichenfolge, die auf den Stack gepackt wird. Dabei wird ein Symbol, das sp√§ter mit einem Eingabesymbol zu matchen ist, auf den Stack gepackt.</p>
<p>Soll das automatisch vom Stack genommene Symbol auf dem Stack bleiben, muss es wieder gepusht werden.</p>
<h2 id="beispiel">Beispiel</h2>
<p>Ein PDA f√ºr 
<span class="math align-center">$L=\lbrace ww^{R}\mid w\in \lbrace a,b\rbrace^{\ast}\rbrace$</span>:</p>
<p><a href="#R-image-a729d67a963e5be38ca5a1c576fd1c5e" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/cfg/pda2.png?width=45%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 45%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a729d67a963e5be38ca5a1c576fd1c5e"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/cfg/pda2.png?width=45%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<h2 id="konfigurationen-von-pdas">Konfigurationen von PDAs</h2>
<p><strong>Def.:</strong> Eine Konfiguration (ID) eines PDAs 3-Tupel 
<span class="math align-center">$(q, w, \gamma)$</span>
mit</p>
<ul>
<li>
<span class="math align-center">$q$</span> ist ein Zustand</li>
<li>
<span class="math align-center">$w$</span> ist der verbleibende Input, 
<span class="math align-center">$w\in\Sigma^{\ast}$</span></li>
<li>
<span class="math align-center">$\gamma$</span> ist der Kellerinhalt 
<span class="math align-center">$\gamma\in \Gamma^{\ast}$</span></li>
</ul>
<p>eines PDAs zu einem gegebenen Zeitpunkt.</p>
<h2 id="die-√ºbergangsrelation-eines-pdas">Die √úbergangsrelation eines PDAs</h2>
<p><strong>Def.:</strong> Die Relation 
<span class="math align-center">$\vdash$</span> definiert √úberg√§nge von einer Konfiguration zu einer anderen:</p>
<p>Sei 
<span class="math align-center">$(p, \alpha) \in \delta(q, a, X)$</span>, dann gilt 
<span class="math align-center">$\forall w\ \epsilon \ \Sigma^{\ast}$</span> und

<span class="math align-center">$\beta \in \Gamma^{\ast}$</span>:</p>
<p>
<span class="math align-center">$(q, aw, X\beta)\vdash(p, w, \alpha\beta)$</span>.</p>
<p><strong>Def.:</strong> Wir definieren mit 
<span class="math align-center">$\overset{\ast}{\vdash}$</span> 0 oder endlich viele Schritte des PDAs
induktiv wie folgt:</p>
<ul>
<li>Basis: 
<span class="math align-center">$I\overset{\ast}{\vdash} I$</span> f√ºr eine ID 
<span class="math align-center">$I$</span>.</li>
<li>Induktion: 
<span class="math align-center">$I\overset{\ast}{\vdash}J$</span>, wenn 
<span class="math align-center">$\exists$</span> ID 
<span class="math align-center">$K$</span> mit 
<span class="math align-center">$I\vdash K$</span> und 
<span class="math align-center">$K \overset{\ast}{\vdash}J$</span>.</li>
</ul>
<h2 id="eigenschaften-der-konfigurations√ºberg√§nge">Eigenschaften der Konfigurations√ºberg√§nge</h2>
<p><strong>Satz:</strong> Sei 
<span class="math align-center">$P=(Q, \Sigma, \Gamma, \delta, q_{0}, \perp, F)$</span> ein PDA und 
<span class="math align-center">$(q, x,\alpha)\overset{\ast}{\vdash} (p, y, \beta)$</span>. Dann gilt f√ºr beliebige Strings 
<span class="math align-center">$w\in\Sigma^{\ast}$</span>, 
<span class="math align-center">$\gamma$</span> in 
<span class="math align-center">$\Gamma^{\ast}$</span>:</p>

<span class="math align-center">$(q, xw, \alpha \gamma) \overset{\ast}{\vdash}(p, yw, \beta\gamma)$</span>
<p><strong>Satz:</strong> Sei 
<span class="math align-center">$P = (Q, \Sigma, \Gamma, \gamma, q_0, \perp, F)$</span> ein PDA und 
<span class="math align-center">$(q,xw,\alpha) \overset{\ast}{\vdash} (p,y w, \beta)$</span>.</p>
<p>Dann gilt: 
<span class="math align-center">$(q, x, a) \overset{\ast}{\vdash} (p, y, \beta)$</span></p>
<h2 id="akzeptierte-sprachen">Akzeptierte Sprachen</h2>
<p><strong>Def.:</strong> Sei 
<span class="math align-center">$P=(Q, \Sigma, \Gamma, \delta, q_0, \perp, F)$</span> ein PDA. Dann ist die <em>√ºber einen Endzustand</em>
akzeptierte Sprache 
<span class="math align-center">$L(P) = \lbrace w \mid (q_0, w, \perp) \overset{\ast}{\vdash} (q, \epsilon, \alpha)\rbrace$</span>
f√ºr einen Zustand 
<span class="math align-center">$q \in F, \alpha \in \Gamma^{\ast}$</span>.</p>
<p><strong>Def.:</strong> F√ºr einen PDA 
<span class="math align-center">$P=(Q, \Sigma, \Gamma, \delta, q_{0}, \perp, F)$</span>
definieren wir die √ºber den <em>leeren Keller</em> akzeptierte Sprache

<span class="math align-center">$N(P) = \lbrace (w \mid (q_0, w, \perp) \overset{\ast}{\vdash} (q, \epsilon, \epsilon)\rbrace$</span>.</p>
<h2 id="akzeptanz√§quivalenzen">Akzeptanz√§quivalenzen</h2>
<p><strong>Satz:</strong> Wenn 
<span class="math align-center">$L = N(P_N)$</span> f√ºr einen PDA 
<span class="math align-center">$P_N$</span>, dann gibt es einen PDA 
<span class="math align-center">$P_L$</span> mit

<span class="math align-center">$L = L(P_L)$</span>.</p>
<p><strong>Satz:</strong> F√ºr einen PDA 
<span class="math align-center">$P$</span> mit 
<span class="math align-center">$\epsilon$</span>-Transitionen existiert ein PDA 
<span class="math align-center">$Q$</span> ohne

<span class="math align-center">$\epsilon$</span>-Transitionen mit 
<span class="math align-center">$L(P) = N(P) = L(Q) = N(Q)$</span>.</p>
<p>Die Transitionsfunktion 
<span class="math align-center">$\delta$</span> ist dann von der Form

<span class="math align-center">$\delta: Q \times \Sigma \times \Gamma \to2^{Q \times \Gamma^{\ast}}$</span>.</p>
<h2 id="deterministische-pdas">Deterministische PDAs</h2>
<p><strong>Def.</strong> Ein PDA 
<span class="math align-center">$P = (Q, \Sigma, \Gamma, \delta, q_0, \perp, F)$</span> ist <em>deterministisch</em>

<span class="math align-center">$: \Leftrightarrow$</span></p>
<ul>
<li>
<span class="math align-center">$\delta(q, a, X)$</span> hat h√∂chstens ein Element f√ºr jedes 
<span class="math align-center">$q \in Q, a \in\Sigma$</span> oder 
<span class="math align-center">$(a = \epsilon$</span> und 
<span class="math align-center">$X \in \Gamma)$</span>.</li>
<li>Wenn 
<span class="math align-center">$\delta (q, a, x)$</span> nicht leer ist f√ºr ein 
<span class="math align-center">$a \in \Sigma$</span>, dann muss 
<span class="math align-center">$\delta (q, \epsilon, x)$</span> leer sein.</li>
</ul>
<p>Deterministische PDAs werden auch <em>DPDAs</em> genannt.</p>
<h2 id="der-kleine-unterschied">Der kleine Unterschied</h2>
<p><strong>Satz:</strong> Die von DPDAs akzeptierten Sprachen sind eine echte Teilmenge der von
PDAs akzeptierten Sprachen.</p>
<p>Die Sprachen, die von <em>regex</em> beschrieben werden, sind eine echte Teilmenge der von
DPDAs akzeptierten Sprachen.</p>
<h1 id="kontextfreie-grammatiken-und-sprachen">Kontextfreie Grammatiken und Sprachen</h1>
<h2 id="kontextfreie-grammatiken">Kontextfreie Grammatiken</h2>
<p><strong>Def.</strong> Eine <em>kontextfreie (cf-)</em> Grammatik ist ein 4-Tupel 
<span class="math align-center">$G = (N, T, P, S)$</span> mit <em>N, T, S</em> wie in
(formalen) Grammatiken und <em>P</em> ist eine endliche Menge von Produktionen der Form:</p>
<p>
<span class="math align-center">$X \rightarrow Y$</span> mit 
<span class="math align-center">$X \in N, Y \in {(N \cup T)}^{\ast}$</span>.</p>
<p>
<span class="math align-center">$\Rightarrow, \overset{\ast}{\Rightarrow}$</span> sind definiert wie bei regul√§ren Sprachen. Bei cf-Grammatiken nennt man die Ableitungsb√§ume oft <em>Parse trees</em>.</p>
<h2 id="beispiel-1">Beispiel</h2>

<span class="math align-center">$S \rightarrow a \mid S\ +\  S\ |\  S \ast S$</span>
<p>Ableitungsb√§ume f√ºr 
<span class="math align-center">$a + a \ast a$</span>:</p>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="mehrdeutige-grammatiken">Mehrdeutige Grammatiken</h2>
<p><strong>Def.:</strong> Gibt es in einer von einer kontextfreien Grammatik erzeugten Sprache ein
Wort, f√ºr das mehr als ein Ableitungsbaum existiert, so hei√üt diese Grammatik
<em>mehrdeutig</em>. Anderenfalls hei√üt sie <em>eindeutig</em>.</p>
<p><strong>Satz:</strong> Es gibt kontextfreie Sprachen, f√ºr die keine eindeutige Grammatik existiert.</p>
<h2 id="kontextfreie-grammatiken-und-pdas">Kontextfreie Grammatiken und PDAs</h2>
<p><strong>Satz:</strong> Die kontextfreien Sprachen und die Sprachen, die von PDAs akzeptiert werden, sind dieselbe
Sprachklasse.</p>
<p><strong>Satz:</strong> Sei 
<span class="math align-center">$L = N(P)$</span> f√ºr einen DPDA <em>P</em>, dann hat <em>L</em> eine eindeutige Grammatik.</p>
<p><strong>Def.:</strong> Die Klasse der Sprachen, die von einem DPDA akzeptiert werden, hei√üt
Klasse der <em>deterministisch kontextfreien (oder LR(k)-) Sprachen</em>.</p>
<h2 id="das-pumping-lemma-f√ºr-kontextfreie-sprachen">Das Pumping Lemma f√ºr kontextfreie Sprachen</h2>
<p>Wenn wir beweisen m√ºssen, dass eine Sprache nicht cf ist, hilft das Pumping Lemma f√ºr cf-Sprachen:</p>
<p><strong>Satz:</strong> Sei <em>L</em> eine kontextfreie Sprache</p>
<p>
<span class="math align-center">$\Rightarrow \exists$</span> eine Konstante 
<span class="math align-center">$p \in \mathbb{N}$</span>:</p>
<p>
<span class="math align-center">$\underset{\underset{|z| \geq p} {z \in L}}\forall \exists$</span> 
<span class="math align-center">$u, v, w, x, y \in \Sigma ^{\ast}$</span> mit 
<span class="math align-center">$z = uvwxy$</span> und</p>
<ul>
<li>
<span class="math align-center">$\mid vwx\mid \leq p$</span></li>
<li>
<span class="math align-center">$vx \neq \epsilon$</span></li>
<li>
<span class="math align-center">$\forall i \geq 0 : uv^i wx^i y \in L$</span></li>
</ul>
<h2 id="abschlusseigenschaften-von-kontextfreien-sprachen">Abschlusseigenschaften von kontextfreien Sprachen</h2>
<p><strong>Satz:</strong> Die kontextfreien Sprachen sind abgeschlossen unter:</p>
<ul>
<li>Vereinigung</li>
<li>Konkatenation</li>
<li>Kleene-H√ºllen 
<span class="math align-center">$L^{\ast}$</span> und 
<span class="math align-center">$L^+$</span></li>
</ul>
<p><strong>Satz:</strong> Wenn <em>L</em> kontextfrei ist, dann ist 
<span class="math align-center">$L^R$</span> kontextfrei.</p>
<h2 id="entscheidbarkeit-von-kontextfreien-grammatiken-und-sprachen">Entscheidbarkeit von kontextfreien Grammatiken und Sprachen</h2>
<p><strong>Satz:</strong> Es ist entscheidbar f√ºr eine kontextfreie Grammatik <em>G</em>,</p>
<ul>
<li>ob 
<span class="math align-center">$L(G) = \emptyset$</span></li>
<li>welche Symbole nach 
<span class="math align-center">$\epsilon$</span> abgeleitet werden k√∂nnen</li>
<li>welche Symbole erreichbar sind</li>
<li>ob 
<span class="math align-center">$w \in L(G)$</span> f√ºr ein gegebenes 
<span class="math align-center">$w \in {\Sigma}^{\ast}$</span></li>
</ul>
<p><strong>Satz:</strong> Es ist nicht entscheidbar,</p>
<ul>
<li>ob eine gegebene kontextfreie Grammatik eindeutig ist</li>
<li>ob der Durchschnitt zweier kontextfreier Sprachen leer ist</li>
<li>ob zwei kontextfreie Sprachen identisch sind</li>
<li>ob eine gegebene kontextfreie Sprache gleich 
<span class="math align-center">$\Sigma^{\ast}$</span> ist</li>
</ul>
<h2 id="abschlusseigenschaften-deterministisch-kontextfreier-sprachen">Abschlusseigenschaften deterministisch kontextfreier Sprachen</h2>
<p><strong>Satz:</strong> Deterministisch kontextfreie Sprachen sind abgeschlossen unter</p>
<ul>
<li>Durchschnitt mit regul√§ren Sprachen</li>
<li>Komplement</li>
</ul>
<p>Sie sind nicht abgeschlossen unter</p>
<ul>
<li>Umkehrung</li>
<li>Vereinigung</li>
<li>Konkatenation</li>
</ul>
<h1 id="wrap-up">Wrap-Up</h1>
<h2 id="das-sollen-sie-mitnehmen">Das sollen Sie mitnehmen</h2>
<ul>
<li>Die Struktur von g√§ngigen Programmiersprachen l√§sst sich nicht mit regul√§ren Ausdr√ºcken beschreiben und damit nicht mit DFAs akzeptieren.</li>
<li>Das Automatenmodell der DFAs wird um einen endlosen Stack erweitert, das ergibt PDAs.</li>
<li>Kontextfreie Grammatiken (CFGs) erweitern die regul√§ren Grammatiken.</li>
<li>Deterministisch parsebare Sprachen haben eine eindeutige kontextfreie Grammatik.</li>
<li>Es ist nicht entscheidbar, ob eine gegebene kontextfreie Grammatik eindeutig ist.</li>
</ul>


    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_aho2013compilers'>[aho2013compilers] <strong>Compilers: Pearson New International Edition: Principles, Techniques, and Tools</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Education Limited, 2013. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-2920-3723-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-2920-3723-3</a>.</li> <li id='id_hopcroft2003'>[hopcroft2003] <strong>Einf√ºhrung in die Automatentheorie, formale Sprachen und Komplexit√§tstheorie</strong><br>Hopcroft, J. E. und Motwani, R. und Ullman, J. D., Pearson Education Deutschland GmbH, 2003. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7020-4' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7020-4</a>.</li></ul></div>
</div>



    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) PDAs</li> <li>(K1) Deterministische PDAs</li> <li>(K1) Kontextfreie Grammatiken</li> <li>(K1) Deterministisch kontextfreie Grammatiken</li> <li>(K2) Zusammenhang zwischen PDAs und kontextfreien Grammatiken</li></ul></div>
</div>



    








<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>LL-Parser (Theorie)</h1>



    
    




    
    
        
        
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="far fa-file-powerpoint"></i> Annotierte Folien</div>
  <div class="box-content">

<ul> <li><a href='https://raw.githubusercontent.com/Compiler-CampusMinden/AnnotatedSlides/master/ll-parser-theory.ann.ma.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Annotierte Folien: LL-Parser (Theorie)</a></li></ul></div>
</div>




    <h1 id="wiederholung">Wiederholung</h1>
<h2 id="pdas-und-kontextfreie-grammatiken">PDAs und kontextfreie Grammatiken</h2>
<ul>
<li>Warum reichen uns DFAs nicht zum Matchen von Eingabezeichen?</li>
<li>Wie k√∂nnnen wir sie minimal erweitern?</li>
<li>Sind PDAs deterministisch?</li>
<li>Wie sind kontextfreie Grammatiken definiert?</li>
<li>Sind kontextfreie Grammatiken eindeutig?</li>
</ul>
<h1 id="motivation">Motivation</h1>
<h2 id="was-brauchen-wir-f√ºr-die-syntaxanalyse-von-programmen">Was brauchen wir f√ºr die Syntaxanalyse von Programmen?</h2>
<ul>
<li>einen Grammatiktypen, aus dem sich manuell oder automatisiert ein Programm zur deterministischen Syntaxanalyse erstellen l√§sst</li>
<li>einen Algorithmus zum sog. Parsen von Programmen mit Hilfe einer solchen Grammatik</li>
</ul>
<h2 id="themen-f√ºr-heute">Themen f√ºr heute</h2>
<ul>
<li>Arten der Syntaxanlyse</li>
<li>mehrdeutige Sprachen</li>
<li>Top-down-Analyse</li>
<li>LL(k)-Grammtiken</li>
</ul>
<h1 id="syntaxanalyse">Syntaxanalyse</h1>
<h2 id="syntax">Syntax</h2>
<p>Wir verstehen unter Syntax eine Menge von Regeln, die die Struktur von Daten (z. B. Programmen) bestimmen.</p>
<p>Syntaxanalyse ist die Bestimmung, ob Eingabedaten einer vorgegebenen Syntax entsprechen.</p>
<p>Diese vorgegebene Syntax wird im Compilerbau mit einer Grammatik beschrieben.</p>
<h2 id="ziele-der-syntaxanalyse">Ziele der Syntaxanalyse</h2>
<ul>
<li>aussagekr√§ftige Fehlermeldungen, wenn ein Eingabeprogramm syntaktisch nicht korrekt ist</li>
<li>evtl. Fehlerkorrektur</li>
<li>Bestimmung der syntaktischen Struktur eines Programms</li>
<li>Erstellung des AST (abstrakter Syntaxbaum): Der Parse Tree ohne Symbole, die nach der Syntaxanalyse inhaltlich irrelevant sind (z. B. Semikolons, manche Schl√ºsselw√∂rter)</li>
<li>die Symboltablelle(n) mit Informationen bzgl. Bezeichner (Variable, Funktionen und Methoden, Klassen, benutzerdefinierte Typen, Parameter, ...), aber auch die G√ºltigkeitsbereiche.</li>
</ul>
<h2 id="arten-der-syntaxanalyse">Arten der Syntaxanalyse</h2>
<p>Die Syntax bezieht sich auf die Struktur der zu analysierenden Eingabe, z. B. einem Computerprogramm in einer Hochsprache. Diese Struktur wird mit formalen Grammatiken beschrieben. Einsetzbar sind Grammatiken, die deterministisch kontextfreie Sprachen erzeugen.</p>
<ul>
<li>Top-Down-Analyse: Aufbau des Parse trees von oben
<ul>
<li>Parsen durch rekursiven Abstieg</li>
<li>LL-Parsing</li>
</ul>
</li>
<li>Bottom-Up-Analyse: LR-Parsing</li>
</ul>
<h2 id="mehrdeutigkeiten">Mehrdeutigkeiten</h2>
<p>Wir k√∂nnen nur mit eindeutigen Grammatiken arbeiten, aber:</p>
<p><strong>Def.:</strong> Eine formale Sprache L hei√üt <em>inh√§rent mehrdeutige Sprache</em>, wenn jede formale Grammatik <em>G</em> mit 
<span class="math align-center">$L(G) = L$</span> mehrdeutig ist.</p>
<p>Das hei√üt, solche Grammatiken existieren.</p>
<p>
<span class="math align-center">$\Rightarrow$</span> Es gibt keinen generellen Algorithmus, um Grammatiken eindeutig zu machen.</p>
<h2 id="bevor-wir-richtig-anfangen">Bevor wir richtig anfangen...</h2>
<p><strong>Def.:</strong> Ein Nichtterminal <em>A</em> einer kontextfreien Grammatik <em>G</em> hei√üt <em>unerreichbar</em>, falls es kein 
<span class="math align-center">$a,b \in {(N \cup T)}^{\ast}$</span> gibt mit 
<span class="math align-center">$S \overset{\ast}{\Rightarrow} aAb$</span>. Ein Nichtterminal <em>A</em> einer Grammatik <em>G</em> hei√üt <em>nutzlos</em>, wenn es kein Wort 
<span class="math align-center">$w \in T^{\ast}$</span> gibt mit 
<span class="math align-center">$A \overset{\ast}{\Rightarrow} w$</span>.</p>
<p><strong>Def.:</strong> Eine kontextfreie Grammatik 
<span class="math align-center">$G=(N, T, P, S)$</span> hei√üt <em>reduziert</em>, wenn es keine nutzlosen oder unerreichbaren Nichtterminale in <em>N</em> gibt.</p>
<p>Bevor mit einer Grammatik weitergearbeitet wird, m√ºssen erst alle nutzlosen und dann alle unerreichbaren Symbole eliminiert werden. Wir betrachten ab jetzt nur reduzierte Grammatiken.</p>
<h1 id="top-down-analyse">Top-Down-Analyse</h1>
<h2 id="wie-w√ºrden-sie-manuell-parsen">Wie w√ºrden Sie manuell parsen?</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="algorithmus-rekursiver-abstieg">Algorithmus: Rekursiver Abstieg</h2>
<p>Hier ist ein einfacher Algorithmus, der (indeterministisch) einen Ableitungsbaum vom Nonterminal <em>X</em> von oben nach unten aufbaut:</p>
<p><strong>Eingabe:</strong> Ein Nichtterminal 
<span class="math align-center">$X$</span> und das n√§chste zu verarbeitende Eingabezeichen 
<span class="math align-center">$a$</span>.</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory/recursive_descent.png" alt="Recursive Descent-Algorithmus" width="55%" height="auto">
    <figcaption><p>Recursive Descent-Algorithmus</p></figcaption>
</figure>
<h2 id="grenzen-des-algorithmus">Grenzen des Algorithmus</h2>
<p>Was ist mit</p>
<ol>
<li>
<span class="math align-center">$X \rightarrow a \alpha \mid b \beta$</span></li>
<li>
<span class="math align-center">$X \rightarrow B\alpha \mid C \beta$</span></li>
<li>
<span class="math align-center">$X \rightarrow B \alpha \mid B \beta$</span></li>
<li>
<span class="math align-center">$X \rightarrow B \alpha \mid C \beta$</span> und 
<span class="math align-center">$C\rightarrow B$</span></li>
<li>
<span class="math align-center">$X \rightarrow X \beta$</span></li>
<li>
<span class="math align-center">$X \rightarrow B \alpha$</span> und 
<span class="math align-center">$B \rightarrow X \beta$</span></li>
</ol>
<p>
<span class="math align-center">$X, B, C, D \in N^{\ast}; a, b, c, d \in T^{\ast}; \beta$</span>, 
<span class="math align-center">$\alpha, \beta \in (N \cup T)^{\ast}$</span></p>
<h2 id="linksfaktorisierung">Linksfaktorisierung</h2>

<span class="math align-center">$X \rightarrow BC\  \vert \  BD$</span>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="algorithmus-linksfaktorisierung">Algorithmus: Linksfaktorisierung</h2>
<p><strong>Eingabe:</strong> Eine Grammatik G = (N, T, P, S)</p>
<p><strong>Ausgabe:</strong> Eine √§quivalente links-faktorisierte Grammatik 
<span class="math align-center">$G'$</span></p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory/Linksfaktorisierung.png" alt="Algorithmus zur Linksfaktorisierung" width="85%" height="auto">
    <figcaption><p>Algorithmus zur Linksfaktorisierung</p></figcaption>
</figure>
<h2 id="linksrekursion">Linksrekursion</h2>
<p><strong>Def.:</strong> Eine Grammatik 
<span class="math align-center">$G=(N, T, P, S)$</span> hei√üt <em>linksrekursiv</em>, wenn sie ein Nichtterminal <em>X</em> hat, f√ºr das es eine Ableitung 
<span class="math align-center">$X \overset{+}{\Rightarrow} X\ \alpha$</span> f√ºr ein 
<span class="math align-center">$\alpha \in (N \cup T)^{\ast}$</span> gibt.</p>
<p>Linksrekursion gibt es</p>
<p><em>direkt</em>: 
<span class="math align-center">$X \rightarrow X \alpha$</span></p>
<p>und</p>
<p><em>indirekt</em>: 
<span class="math align-center">$X \rightarrow \ldots \rightarrow \ldots \rightarrow X \alpha$</span></p>
<h2 id="algorithmus-entfernung-von-direkter-linksrekursion" class="fragile">Algorithmus: Entfernung von direkter Linksrekursion</h2>
<p><strong>Eingabe:</strong> Eine Grammatik G = (N, T, P, S)</p>
<p><strong>Ausgabe:</strong> Eine √§quivalente Grammatik 
<span class="math align-center">$G'$</span> ohne direkte Linksrekursion</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory/direkte_Linksrekursion_Elim.png" alt="Algorithmus zur Entfernung direkter Linksrekursion" width="55%" height="auto">
    <figcaption><p>Algorithmus zur Entfernung direkter Linksrekursion</p></figcaption>
</figure>
<h2 id="algorithmus-entfernung-von-indirekter-linksrekursion" class="fragile">Algorithmus: Entfernung von indirekter Linksrekursion</h2>
<p><strong>Eingabe:</strong> Eine Grammatik G = (N, T, P, S) mit 
<span class="math align-center">$N= \lbrace X_1, X_2, \ldots X_n\rbrace$</span> ohne 
<span class="math align-center">$\epsilon$</span>-Regeln oder Zyklen der Form 
<span class="math align-center">$X_1 \rightarrow X_2, X_2 \rightarrow X_3, \ldots X_{m-1} \rightarrow X_m, X_m \rightarrow X_1$</span></p>
<p><strong>Ausgabe:</strong> Eine √§quivalente Grammatik 
<span class="math align-center">$G'$</span> ohne Linksrekursion</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory/indirekte_Linksrekursion_Elim.png" alt="Algorithmus zur Entfernung indirekter Linksrekursion" width="60%" height="auto">
    <figcaption><p>Algorithmus zur Entfernung indirekter Linksrekursion</p></figcaption>
</figure>
<h1 id="arbeiten-mit-generierten-parsern-llk-grammatiken">Arbeiten mit generierten Parsern: LL(k)-Grammatiken</h1>
<h2 id="first-mengen">First-Mengen</h2>

<span class="math align-center">$S \rightarrow A \ \vert \ B \ \vert \ C$</span>
<p>Welche Produktion nehmen?</p>
<p>Wir brauchen die &quot;terminalen k-Anf√§nge&quot; von Ableitungen von Nichtterminalen, um eindeutig die n√§chste zu benutzende Produktion festzulegen. 
<span class="math align-center">$k$</span> ist dabei die Anzahl der Vorschautoken.</p>
<p><strong>Def.:</strong> Wir definieren 
<span class="math align-center">$First$</span> - Mengen einer Grammatik wie folgt:</p>
<ul>
<li>
<span class="math align-center">$a \in T^\ast, |a| \leq k: {First}_k (a) = \lbrace a\rbrace$</span></li>
<li>
<span class="math align-center">$a \in T^\ast, |a| > k: {First}_k (a) = \lbrace v \in T^\ast \mid a = vw, |v| = k\rbrace$</span></li>
<li>
<span class="math align-center">$\alpha \in (N \cup T)^\ast \backslash T^\ast: {First}_k (\alpha) = \lbrace v \in T^\ast \mid \alpha \overset{\ast}{\Rightarrow} w,\text{mit}\ w \in T^\ast, First_k(w) = \lbrace v \rbrace \rbrace$</span></li>
</ul>
<h2 id="linksableitungen">Linksableitungen</h2>
<p><strong>Def.:</strong> Bei einer kontextfreien Grammatik 
<span class="math align-center">$G$</span> ist die <em>Linksableitung</em> von 
<span class="math align-center">$\alpha \in (N \cup T)^{\ast}$</span> die Ableitung, die man erh√§lt, wenn in jedem Schritt das am weitesten links stehende Nichtterminal in 
<span class="math align-center">$\alpha$</span> abgeleitet wird.</p>
<p>Man schreibt 
<span class="math align-center">$\alpha \overset{\ast}{\Rightarrow}_l \beta.$</span></p>
<h2 id="follow-mengen">Follow-Mengen</h2>
<p>Manchmal m√ºssen wir wissen, welche terminalen Zeichen hinter einem Nichtterminal stehen k√∂nnen.</p>
<p><strong>Def.</strong> Wir definieren <em>Follow</em> - Mengen einer Grammatik wie folgt:</p>

<span class="math align-center">$\forall \beta \in (N \cup T)^*:$</span>

<span class="math align-center">$$Follow_k(\beta) = \lbrace w \in T^\ast \mid \exists \alpha, \gamma \in  (N \cup T)^\ast\ \text{ mit }\ S \overset{\ast}{\Rightarrow}_l \alpha \beta \gamma\ \text{ und }\ w \in First_k(\gamma) \rbrace$$</span>
<h2 id="llk-grammatiken">LL(k)-Grammatiken</h2>
<p><strong>Def.:</strong> Eine kontextfreie Grammatik <em>G = (N, T, P, S)</em> ist genau dann eine <em>LL(k)</em>-Grammatik, wenn f√ºr alle Linksableitungen der Form:</p>

<span class="math align-center">$S \overset{\ast}{\Rightarrow}_l\ wA \gamma\ {\Rightarrow}_l\ w\alpha\gamma \overset{\ast}{\Rightarrow}_l wx$</span>
<p>und</p>

<span class="math align-center">$S \overset{\ast}{\Rightarrow}_l wA \gamma {\Rightarrow}_l w\beta\gamma \overset{\ast}{\Rightarrow}_l wy$</span>
<p>mit 
<span class="math align-center">$(w, x, y \in T^\ast, \alpha, \beta, \gamma \in (N \cup T)^\ast, A \in N)$</span> und 
<span class="math align-center">$First_k(x) = First_k(y)$</span>
gilt:</p>

<span class="math align-center">$\alpha = \beta$</span>
<h2 id="llk-grammatiken-1">LL(k)-Grammatiken</h2>
<p>Das hilft manchmal:</p>
<p>F√ºr 
<span class="math align-center">$k = 1$</span>:
G ist 
<span class="math align-center">$LL(1): \forall A \rightarrow \alpha, A \rightarrow \beta \in P, \alpha \neq \beta$</span> gilt:</p>
<ol>
<li>
<span class="math align-center">$\lnot \exists a \in T: \alpha \overset{\ast}{\Rightarrow}_l a\alpha_1$</span> und 
<span class="math align-center">$\beta \overset{\ast}{\Rightarrow}_l a\beta_1$</span></li>
<li>
<span class="math align-center">$((\alpha \overset{\ast}{\Rightarrow}_l \epsilon) \Rightarrow (\lnot (\beta \overset{\ast}{\Rightarrow}_l \epsilon)))$</span> und 
<span class="math align-center">$((\beta \overset{\ast}{\Rightarrow}_l \epsilon) \Rightarrow (\lnot (\alpha\overset{\ast}{\Rightarrow}_l \epsilon)))$</span></li>
<li>
<span class="math align-center">$((\beta \overset{\ast}{\Rightarrow}_l \epsilon)$</span> und 
<span class="math align-center">$(\alpha \overset{\ast}{\Rightarrow}_l a\alpha_1)) \Rightarrow a \notin Follow(A)$</span></li>
<li>
<span class="math align-center">$((\alpha \overset{\ast}{\Rightarrow}_l \epsilon)$</span> und 
<span class="math align-center">$(\beta \overset{\ast}{\Rightarrow}_l a\beta_1)) \Rightarrow a \notin Follow(A)$</span></li>
</ol>
<p>Die ersten beiden Zeilen bedeuten:</p>
<p>
<span class="math align-center">$\alpha$</span> und 
<span class="math align-center">$\beta$</span> k√∂nnen nicht beide 
<span class="math align-center">$\epsilon$</span> ableiten, 
<span class="math align-center">$First_1(\alpha) \cap First_1(\beta) = \emptyset$</span></p>
<p>Die dritte und vierte Zeile bedeuten:</p>

<span class="math align-center">$(\epsilon \in First_1(\beta)) \Rightarrow (First_1(\alpha) \cap Follow_1(A) = \emptyset)$</span>

<span class="math align-center">$(\epsilon \in First_1(\alpha)) \Rightarrow (First_1(\beta) \cap Follow_1(A) = \emptyset)$</span>
<h2 id="ll1-grammatiken">LL(1)-Grammatiken</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="llk-sprachen">LL(k)-Sprachen</h2>
<p>Die von <em>LL(k)</em>-Grammatiken erzeugten Sprachen sind eine echte Teilmenge der deterministisch parsbaren Sprachen.</p>
<p>Die von <em>LL(k)</em>-Grammatiken erzeugten Sprachen sind eine echte Teilmenge der von <em>LL(k+1)</em>-Grammatiken erzeugten Sprachen.</p>
<p>F√ºr eine kontextfreie Grammatik <em>G</em> ist nicht entscheidbar, ob es eine <em>LL(1)</em> - Grammatik <em>G'</em> gibt mit 
<span class="math align-center">$L(G) = L(G')$</span>.</p>
<p>In der Praxis reichen 
<span class="math align-center">$LL(1)$</span> - Grammatiken oft. Hier gibt es effiziente Parsergeneratoren, deren Eingabe eine LL(k)- (meist LL(1)-) Grammatik ist, und die als Ausgabe den Quellcode eines (effizienten) tabellengesteuerten Parsers generieren.</p>
<h2 id="algorithmus-konstruktion-einer-ll-parsertabelle" class="fragile">Algorithmus: Konstruktion einer LL-Parsertabelle</h2>
<p><strong>Eingabe:</strong> Eine Grammatik G = (N, T, P, S)</p>
<p><strong>Ausgabe:</strong> Eine Parsertabelle <em>P</em></p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory/LL-Parsertabelle.png" alt="Algorithmus zur Generierung einer LL-Parsertabelle" width="60%" height="auto">
    <figcaption><p>Algorithmus zur Generierung einer LL-Parsertabelle</p></figcaption>
</figure>
<p>Hier ist 
<span class="math align-center">$\perp$</span> das Endezeichen des Inputs.
Statt 
<span class="math align-center">$First_1(\alpha)$</span> und 
<span class="math align-center">$Follow_1(\alpha)$</span> wird oft nur 
<span class="math align-center">$First(\alpha)$</span> und 
<span class="math align-center">$Follow(\alpha)$</span> geschrieben.</p>
<h2 id="ll-parsertabellen">LL-Parsertabellen</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="ll-parsertabellen-1">LL-Parsertabellen</h2>
<p>Rekursive Programmierung bedeutet, dass das Laufzeitsystem einen Stack benutzt (bei einem Recursive-Descent-Parser, aber auch bei der Parsertabelle). Diesen Stack kann man auch &quot;selbst programmieren&quot;, d. h. einen PDA implementieren. Dabei wird ebenfalls die oben genannte Tabelle zur Bestimmung der n√§chsten anzuwendenden Produktion benutzt. Der Stack enth√§lt die zu erwartenden Eingabezeichen, wenn immer eine Linksableitung gebildet wird. Diese Zeichen im Stack werden mit dem Input gematcht.</p>
<h2 id="algorithmus-tabellengesteuertes-ll-parsen-mit-einem-pda" class="fragile">Algorithmus: Tabellengesteuertes LL-Parsen mit einem PDA</h2>
<p><strong>Eingabe:</strong> Eine Grammatik G = (N, T, P, S), eine Parsertabelle <em>P</em> mit 
<span class="math align-center">$w\perp$</span> als initialem Kellerinhalt</p>
<p><strong>Ausgabe:</strong> Wenn 
<span class="math align-center">$w \in L(G)$</span>, eine Linksableitung von 
<span class="math align-center">$w$</span>, Fehler sonst</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory/LL-Parser.png" alt="Algorithmus zum tabellengesteuerten LL-Parsen" width="50%" height="auto">
    <figcaption><p>Algorithmus zum tabellengesteuerten LL-Parsen</p></figcaption>
</figure>
<p>Der Eingabestring sei 
<span class="math align-center">$w\perp$</span>, der initiale Kellerinhalt sei 
<span class="math align-center">$\perp$</span>.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>Syntaxanalyse wird mit deterministisch kontextfreien Grammatiken durchgef√ºhrt.</li>
<li>Eine Teilmenge der dazu geh√∂rigen Sprachen l√§sst sich top-down parsen.</li>
<li>Ein einfacher Recursive-Descent-Parser arbeitet mit Backtracking.</li>
<li>Ein effizienter LL(k)-Parser realisiert einen DPDA und kann automatisch aus einer LL(k)-Grammatik generiert werden.</li>
<li>Der Parser liefert in der Regel einen abstrakten Syntaxbaum.</li>
</ul>


    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_aho2013compilers'>[aho2013compilers] <strong>Compilers: Pearson New International Edition: Principles, Techniques, and Tools</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Education Limited, 2013. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-2920-3723-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-2920-3723-3</a>.</li> <li id='id_hopcroft2003'>[hopcroft2003] <strong>Einf√ºhrung in die Automatentheorie, formale Sprachen und Komplexit√§tstheorie</strong><br>Hopcroft, J. E. und Motwani, R. und Ullman, J. D., Pearson Education Deutschland GmbH, 2003. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7020-4' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7020-4</a>.</li></ul></div>
</div>



    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) Top-Down-Analyse</li> <li>(K1) Recursive-Descent-Parser</li> <li>(K1) First- und Follow-Mengen</li> <li>(K1) LL-Parser</li> <li>(K2) Zusammenhang zwischen PDAs und kontextfreien Grammatiken</li> <li>(K2) Schreiben von LL-Parsern</li> <li>(K3) Top-Down Analyse programmieren</li></ul></div>
</div>



    








<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>LL-Parser selbst implementiert</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p><a href="#R-image-50771504926c371efe57cccd005207e1" class="lightbox-link"><img src="images/architektur_cb_parser.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-50771504926c371efe57cccd005207e1"><img src="images/architektur_cb_parser.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>LL-Parser k√∂nnen √ºber einen &quot;rekursiven Abstieg&quot; direkt aus einer Grammatik implementiert werden:</p>
<ul>
<li>Zu jeder Produktionsregel erstellt man eine gleichnamige Funktion.</li>
<li>Wenn in der Produktionsregel andere Regeln &quot;aufgerufen&quot; werden, erfolgt in der Funktion an
dieser Stelle der entsprechende Funktionsaufruf.</li>
<li>Bei Terminalsymbolen wird das erwartete Token gepr√ºft.</li>
</ul>
<p>Dabei findet man wie bereits im Lexer die Funktionen <code>match</code> und <code>consume</code>, die sich hier aber
auf den Tokenstrom beziehen. LL(1)-Parser schauen dabei immer das n√§chste Token an, LL(k) haben
ein entsprechendes Look-Ahead von 
<span class="math align-center">$k$</span> Token. Dies kann man mit einem Ringpuffer f√ºr die Token
realisieren.</p>
<p>Zur Beachtung der Vorrang- und Assoziativit√§tsregeln muss die Grammatik entsprechend umgebaut
werden. LL-Parser haben durch die Betrachtung des aktuellen Vorschau-Tokens ein Problem mit
Linksrekursion in der Grammatik, diese muss zun√§chst beseitigt werden. (ANTLR bietet hier gewisse
Vereinfachungen an, kann aber mit indirekter Linksrekursion auch nicht umgehen.)</p>
<p>Eine gute Darstellung finden Sie in <a href="#id_Parr2010">[Parr2010]</a> (Kapitel 2).</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/3djLtMtW82k' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL LL-Parser selbst implementiert</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/fc75fe2bfb0c45447689e386f3e0c227bb30a0d081374134c60e20392a1f8c54536a749aefec5c5825c4d8c9e9aa77c30b37acb56e9b3c314da17691d9c5eee8' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL LL-Parser selbst implementiert</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K2) Prinzipieller Aufbau von LL-Parsern</li> <li>(K3) Implementierung von LL(1)- und LL(k)-Parsern</li> <li>(K3) Implementierung von Vorrang und Assoziativit√§t</li> <li>(K3) Umgang mit Linksrekursion, insbesondere bei ANTLR</li></ul></div>
</div>




    <h2 id="erinnerung-lexer-zeichenstrom--tokenstrom">Erinnerung Lexer: Zeichenstrom =&gt; Tokenstrom</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">nextToken</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (peek <span style="color:#f92672">!=</span> EOF):  <span style="color:#75715e"># globale Variable, √ºber consume()</span>
</span></span><span style="display:flex;"><span>        switch (peek):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39; &#39;</span>: <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#39;</span>: <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>: WS(); <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;[&#39;</span>: consume(); <span style="color:#66d9ef">return</span> Token(LBRACK, <span style="color:#e6db74">&#39;[&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>            default: <span style="color:#66d9ef">raise</span> Error(<span style="color:#e6db74">&#34;invalid character: &#34;</span><span style="color:#f92672">+</span>peek)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Token(EOF_Type, <span style="color:#e6db74">&#34;&lt;EOF&gt;&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">match</span>(c):   <span style="color:#75715e"># Lookahead: Ein Zeichen</span>
</span></span><span style="display:flex;"><span>    consume()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (peek <span style="color:#f92672">==</span> c): <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: rollBack(); <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">consume</span>():
</span></span><span style="display:flex;"><span>    peek <span style="color:#f92672">=</span> buffer[start]
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> (start<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) mod <span style="color:#ae81ff">2</span>n
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (start mod n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>        fill(buffer[start:start<span style="color:#f92672">+</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>        end <span style="color:#f92672">=</span> (start<span style="color:#f92672">+</span>n) mod <span style="color:#ae81ff">2</span>n</span></span></code></pre></div><p>Erinnerung: Der Lexer arbeitet direkt auf dem Zeichenstrom und versucht √ºber l√§ngste Matches daraus
einen Tokenstrom zu erzeugen. Dabei wird immer das n√§chste Zeichen angeschaut (Funktion <code>match</code>) und
mit <code>consume</code> das aktuelle Zeichen &quot;verbraucht&quot; und das n√§chste Zeichen geladen. Hier kann man √ºber
die Doppel-Puffer-Strategie das Einlesen einzelner Zeichen aus einer Datei vermeiden und immer blockweise
in den Puffer einlesen.</p>
<h2 id="grundidee-ll-parser">Grundidee LL-Parser</h2>
<p>Grammatik:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>r : <span style="color:#66d9ef">X</span> s ;</span></span></code></pre></div><p>LL-Implementierung:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">r</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span>(X)
</span></span><span style="display:flex;"><span>    s()</span></span></code></pre></div><ul>
<li>F√ºr jede Regel in der Grammatik wird eine Methode/Funktion mit dem selben Namen definiert</li>
<li>Referenzen auf ein Token <code>T</code> werden durch den Aufruf der Methode <code>match(T)</code> aufgel√∂st
<ul>
<li><code>match(T)</code> &quot;konsumiert&quot; das aktuelle Token, falls dieses mit <code>T</code> √ºbereinstimmt</li>
<li>Anderenfalls l√∂st <code>match()</code> eine Exception aus</li>
</ul>
</li>
<li>Referenzen auf Regeln <code>s</code> werden durch Methodenaufrufe <code>s()</code> aufgel√∂st</li>
</ul>
<p><em>Erinnerung</em>: In ANTLR werden Parser-Regeln (non-Terminale) mit einem kleinen und Lexer-Regeln
(Terminale/Token) mit einem gro√üen Anfangsbuchstaben geschrieben.</p>
<h2 id="alternative-subregeln">Alternative Subregeln</h2>
<pre><code>a | b | c
</code></pre>
<p>kann zu einem <code>switch</code>-Konstrukt aufgel√∂st werden:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>switch (lookahead):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> predicting_a:
</span></span><span style="display:flex;"><span>        a(); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> predicting_b:
</span></span><span style="display:flex;"><span>        b(); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    default: <span style="color:#66d9ef">raise</span> Error()</span></span></code></pre></div><p>Dabei ist <code>lookahead</code> eine globale Variable, die das zu betrachtende Token enth√§lt
(vergleichbar mit <code>peek</code> beim Lexer).</p>
<p>Das Pr√§dikat <code>predicting_a</code> soll andeuten, dass man mit dem aktuellen Token eine
Vorhersage f√ºr die Regel <code>a</code> versucht (hier kommen die FIRST- und FOLLOW-Mengen
ins Spiel ...). Wenn das der Fall ist, springt man entsprechend in die Funktion
bzw. Methode <code>a()</code>.</p>
<h2 id="optionale-subregeln-eins-oder-keins">Optionale Subregeln: Eins oder keins</h2>
<pre><code>(T)?
</code></pre>
<p>wird zu einem <code>if</code> ohne <code>else</code>-Teil:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> lookahead<span style="color:#f92672">.</span>predicting_T: <span style="color:#66d9ef">match</span>(T)</span></span></code></pre></div><h2 id="optionale-subregeln-mindestens-eins">Optionale Subregeln: Mindestens eins</h2>
<pre><code>(T)+
</code></pre>
<p>wird zu einer <code>do-while</code>-Schleife (mind. ein Durchlauf):</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span>(T)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> lookahead<span style="color:#f92672">.</span>predicting_T: <span style="color:#66d9ef">break</span></span></span></code></pre></div><h2 id="ll1-parser">LL(1)-Parser</h2>
<p>Beispiel: Parsen von Listen, also Sequenzen wie <code>[1,2,3,4]</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>list     : <span style="color:#e6db74">&#39;[&#39;</span> elements <span style="color:#e6db74">&#39;]&#39;</span> ;
</span></span><span style="display:flex;"><span>elements : <span style="color:#66d9ef">INT</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;,&#39;</span> <span style="color:#66d9ef">INT</span><span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>INT      : <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">..</span><span style="color:#e6db74">&#39;9&#39;</span><span style="color:#f92672">)+</span> ;</span></span></code></pre></div><p>Formal berechnet man die Lookahead-Mengen mit <code>FIRST</code> und <code>FOLLOW</code>, um eine Entscheidung
f√ºr die n√§chste Regel zu treffen. Praktisch betrachtet kann man sich fragen, welche(s)
Token eine Phrase in der aktuellen Alternative starten k√∂nnen.</p>
<p>F√ºr LL(1)-Parser betrachtet man immer das <strong>aktuelle</strong> Token (<strong>genau <em>EIN</em> Lookahead-Token</strong>),
um eine Entscheidung zu treffen.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">list</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span>(LBRACK); elements(); <span style="color:#66d9ef">match</span>(RBRACK);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">elements</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span>(INT)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> lookahead <span style="color:#f92672">==</span> COMMA:  <span style="color:#75715e"># globale Variable, √ºber consume()</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span>(COMMA); <span style="color:#66d9ef">match</span>(INT)</span></span></code></pre></div><h2 id="detail-match-und-consume">Detail: <em>match()</em> und <em>consume()</em></h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">match</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> lookahead <span style="color:#f92672">==</span> x: consume()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">Exception</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">consume</span>():
</span></span><span style="display:flex;"><span>    lookahead <span style="color:#f92672">=</span> lexer<span style="color:#f92672">.</span>nextToken()</span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, p. 43]</a></span></p>
<p>Dabei setzt man in der Klasse <code>Parser</code> zwei Attribute voraus:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Parser</span>:
</span></span><span style="display:flex;"><span>    Lexer lexer
</span></span><span style="display:flex;"><span>    Token lookahead</span></span></code></pre></div><p>Starten w√ºrde man den Parser nach dem Erzeugen einer Instanz (dabei wird ein Lexer mit
durchgereicht) √ºber den Aufruf der Start-Regel, also beispielsweise <code>parser.list()</code>.</p>
<p><em>Anmerkung</em>: Mit dem generierten Parse-Tree bzw. <em>AST</em> besch√§ftigen wir uns sp√§ter
(=&gt; <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/astdriven-part1.html">AST-basierte Interpreter</a>).</p>
<h2 id="vorrangregeln">Vorrangregeln</h2>
<pre><code>1+2*3 == 1+(2*3) != (1+2)*3
</code></pre>
<p>Die Eingabe <code>1+2*3</code> muss als <code>1+(2*3)</code> interpretiert werden, da <code>*</code> Vorrang vor <code>+</code> hat.</p>
<p>Dies formuliert man √ºblicherweise in der Grammatik:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : expr <span style="color:#e6db74">&#39;+&#39;</span> term
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> term
</span></span><span style="display:flex;"><span>     ;
</span></span><span style="display:flex;"><span>term : term <span style="color:#e6db74">&#39;*&#39;</span> <span style="color:#66d9ef">INT</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">INT</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p>ANTLR nutzt die Strategie des <a href="https://www.antlr.org/papers/Clarke-expr-parsing-1986.pdf" target="_blank">&quot;<em>precedence climbing</em>&quot;</a>
und l√∂st nach der <em>Reihenfolge der Alternativen</em> in einer Regel auf. Entsprechend k√∂nnte man die obige Grammatik
unter Beibehaltung der Vorrangregeln so in ANTLR (v4) formulieren:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : expr <span style="color:#e6db74">&#39;*&#39;</span> expr
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;+&#39;</span> expr
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">INT</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><h2 id="linksrekursion">Linksrekursion</h2>
<p>Normalerweise sind linksrekursive Grammatiken nicht mit einem LL-Parser behandelbar. Man muss die Linksrekursion
manuell aufl√∂sen und die Grammatik umschreiben.</p>
<p><strong>Beispiel</strong>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : expr <span style="color:#e6db74">&#39;*&#39;</span> expr <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;+&#39;</span> expr <span style="color:#f92672">|</span> <span style="color:#66d9ef">INT</span> ;</span></span></code></pre></div><p>Diese linksrekursive Grammatik k√∂nnte man (unter Beachtung der Vorrangregeln) etwa so umformulieren:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr     : addExpr ;
</span></span><span style="display:flex;"><span>addExpr  : multExpr <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;+&#39;</span> multExpr<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>multExpr : <span style="color:#66d9ef">INT</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;*&#39;</span> <span style="color:#66d9ef">INT</span><span style="color:#f92672">)*</span> ;</span></span></code></pre></div><p>ANTLR (v4) kann Grammatiken mit <em>direkter</em> Linksrekursion aufl√∂sen. F√ºr fr√ºhere Versionen von ANTLR muss man die
Rekursion manuell beseitigen.</p>
<p>Vergleiche <a href="https://www.antlr.org/papers/allstar-techreport.pdf" target="_blank">&quot;ALL(*)&quot; bzw. &quot;Adaptive LL(*)&quot;</a>.</p>
<p><strong>Achtung</strong>: Mit <em>indirekter</em> Linksrekursion kann ANTLR (v4) <em>nicht</em> umgehen:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : expM <span style="color:#f92672">|</span> <span style="color:#f92672">...</span> ;
</span></span><span style="display:flex;"><span>expM : expr <span style="color:#e6db74">&#39;*&#39;</span> expr ;</span></span></code></pre></div><p>=&gt; <em>Nicht</em> erlaubt!</p>
<h2 id="assoziativit√§t">Assoziativit√§t</h2>
<p>Die Eingabe <code>2^3^4</code> sollte als <code>2^(3^4)</code> geparst werden. Analog sollte <code>a=b=c</code> in C als <code>a=(b=c)</code> verstanden werden.</p>
<p>Per Default werden Operatoren wie <code>+</code> in ANTLR <em>links-assoziativ</em> behandelt, d.h. die Eingabe <code>1+2+3</code> wird
als <code>(1+2)+3</code> gelesen. F√ºr <em>rechts-assoziative</em> Operatoren muss man ANTLR dies in der Grammatik mitteilen:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : expr <span style="color:#e6db74">&#39;^&#39;</span><span style="color:#960050;background-color:#1e0010">&lt;</span>assoc<span style="color:#f92672">=</span>right<span style="color:#960050;background-color:#1e0010">&gt;</span> expr
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">INT</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p><em>Anmerkung</em>: Laut <a href="https://github.com/antlr/antlr4/blob/master/doc/left-recursion.md" target="_blank">Doku</a> gilt die Angabe
<code>&lt;assoc=right&gt;</code> immer f√ºr die jeweilige Alternative und muss seit Version 4.2 an den Alternativen-Operator <code>|</code>
geschrieben werden. In der √úbergangsphase sei die Annotation an Tokenreferenzen noch zul√§ssig, w√ºrde aber
ignoriert?!</p>
<h2 id="llk-parser">LL(k)-Parser</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;++&#39;</span>    <span style="color:#75715e">// x++</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;--&#39;</span>    <span style="color:#75715e">// x--</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p>Die obige Regel ist f√ºr einen LL(1)-Parser nicht deterministisch behandelbar, da die Alternativen
mit dem selben Token beginnen (die Lookahead-Mengen √ºberlappen sich). Entweder ben√∂tigt man zwei
Lookahead-Tokens, also einen LL(2)-Parser, oder man muss die Regel in eine √§quivalente LL(1)-Grammatik
umschreiben:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : <span style="color:#66d9ef">ID</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;++&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;--&#39;</span><span style="color:#f92672">)</span> ;    <span style="color:#75715e">// x++ oder x--</span></span></span></code></pre></div><h2 id="llk-parser-implementierung-mit-ringpuffer">LL(k)-Parser: Implementierung mit Ringpuffer</h2>
<p>F√ºr einen gr√∂√üeren Lookahead ben√∂tigt man einen Puffer f√ºr die Token. F√ºr einen Lookahead von

<span class="math align-center">$k$</span> Token (also einen LL(k)-Parser) w√ºrde man einen Puffer mit 
<span class="math align-center">$k$</span> Pl√§tzen anlegen und diesen
wie einen Ringpuffer benutzen. Dabei ist <code>start</code> der Index des aktuellen Lookahead-Tokens. √úber
die neue Funktion <code>lookahead(1)</code> ist dieses aktuelle Lookahead-Token abrufbar.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Parser</span>:
</span></span><span style="display:flex;"><span>    Lexer lexer
</span></span><span style="display:flex;"><span>    k <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>               <span style="color:#75715e"># Lookahead: 3 Token =&gt; LL(3)</span>
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>           <span style="color:#75715e"># aktuelle Tokenposition im Ringpuffer</span>
</span></span><span style="display:flex;"><span>    Token[k] lookahead  <span style="color:#75715e"># Ringpuffer mit k Pl√§tzen (vorbef√ºllt via Konstruktor)</span></span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">match</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> lookahead(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> x: consume()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">Exception</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">consume</span>():
</span></span><span style="display:flex;"><span>    lookahead[start] <span style="color:#f92672">=</span> lexer<span style="color:#f92672">.</span>nextToken()
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> (start<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> k
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lookahead</span>(i):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> lookahead[(start<span style="color:#f92672">+</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> k]  <span style="color:#75715e"># i==1: start</span></span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, p. 47]</a></span></p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>LL(1) und LL(k) mit festem Lookahead</li>
<li>Implementierung von Vorrang- und Assoziativit√§tsregeln</li>
<li>Beachtung und Aufl√∂sung von Linksrekursion</li>
</ul>


    



    



    

    
<div class="box notices cstyle note">
  <div class="box-label"><i class="fas fa-puzzle-piece"></i> Challenges</div>
  <div class="box-content">

<ul>
<li>Wie kann man aus einer LL(1)-Grammatik einen LL(1)-Parser mit rekursivem Abstieg implementieren? Wie &quot;√ºbersetzt&quot; man dabei Token und Regeln?</li>
<li>Wie geht man mit Alternativen um? Wie mit optionalen Subregeln?</li>
<li>Warum ist Linksrekursion i.A. bei LL-Parsern nicht erlaubt? Wie kann man Linksrekursion beseitigen?</li>
<li>Wie kann man Vorrangregeln implementieren?</li>
<li>Wann braucht man mehr als ein Token Lookahead? Geben Sie ein Beispiel an.</li>
</ul>
</div>
</div>



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Abschnitte 2.4 und 4.4</em></li> <li id='id_Grune2012'>[Grune2012] <strong>Modern Compiler Design</strong><br>Grune, D. und van, Reeuwijk, K. und Bal, H. E. und Jacobs, C. J. H. und Langendoen, K., Springer, 2012. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-4614-4698-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-4614-4698-9</a>.<br><em>Abschnitte 3.1 bis (einschlie√ülich) 3.4</em></li> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 2 (insbesondere Abschnitte 2.3 bis (einschlie√ülich) 2.19)</em></li> <li id='id_Parr2010'>[Parr2010] <strong>Language Implementation Patterns</strong><br>Parr, T., Pragmatic Bookshelf, 2010. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5645-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5645-6</a>.<br><em>Kapitel 2</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>LL-Parser: Fortgeschrittene Techniken</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p><a href="#R-image-fe0b6cbbf79deae0be869c70351cc1e3" class="lightbox-link"><img src="images/architektur_cb_parser.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fe0b6cbbf79deae0be869c70351cc1e3"><img src="images/architektur_cb_parser.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Man kann einen LL(k)-Parser bei Bedarf um ein &quot;spekulatives Matching&quot; erg√§nzen. Dies ist in Situationen
relevant, wo man das 
<span class="math align-center">$k$</span> nicht vorhersehen kann, etwa bei der Unterscheidung einer Vorw√§rtsdeklaration
und einer Funktionsdefinition in C. Hier kann man erst nach dem Parsen des Funktionsnamens entscheiden,
welche Situation vorliegt; der Funktionsname kann dabei (nahezu) beliebig lang sein.</p>
<p>Beim spekulativen Matching muss man sich merken, an welcher Position im Tokenstrom man die Spekulation
gestartet hat, um im Fall des Nichterfolgs dorthin wieder zur√ºckspringen zu k√∂nnen (&quot;Backtracking&quot;).</p>
<p>Das Backtracking kann sehr langsam werden durch das Ausprobieren mehrerer Alternativen und das jeweils
n√∂tige Zur√ºckrollen. Zudem kann es passieren, dass eine bestimmte Sequenz immer wieder erkannt werden
muss. Hier hilft eine weitere Technik: <strong>Packrat Parsing</strong> <a href="#id_Packrat2006">[Packrat2006]</a> (nutzt
<a href="https://en.wikipedia.org/wiki/Memoization" target="_blank">&quot;<em>memoisation</em>&quot;</a>). Hierbei f√ºhrt man pro Regel eine Map mit,
in der zu einer Position im Tokenstrom festgehalten wird, ob diese Regel an/ab dieser Position bereits
erfolgreich oder nicht erfolgreich war. Dies kann man dann nutzen, um bei einem erneuten Parsen der
selben Regel &quot;vorzuspulen&quot;.</p>
<p>In ANTLR kann man <em>semantische Pr√§dikate</em> benutzen, um Alternativen &quot;abzuschalten&quot;. Dies ist beispielsweise
n√ºtzlich, wenn man nur eine Grammatik f√ºr unterschiedliche Versionen einer Sprache implementieren will.</p>
<p>Eine gute Darstellung finden Sie in <a href="#id_Parr2010">[Parr2010]</a> (Kapitel 3) und in [Packrat2006].</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/12GT2WxZsxY' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL LL-Parser: Fortgeschrittene Techniken</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/c3dc479884ce6b50bbd0fe85a8dd49f7b250576ac73742b879c564d6cba4b83c79fa499f9164b947e81e597add85e6addfd91a41a4eb85438c51218846aac0cb' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL LL-Parser: Fortgeschrittene Techniken</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K3) Implementierung von LL(1)- und LL(k)-Parsern</li> <li>(K3) Dynamischer Lookahead mittels Backtracking; Verbesserung der Laufzeiteigenschaften mit Packrat</li> <li>(K3) Einsatz von semantischen Pr√§dikaten zum (De-) Aktivieren von Regeln oder Token</li></ul></div>
</div>




    <h2 id="ll-parser-mit-backtracking">LL-Parser mit Backtracking</h2>
<p>Problem: Manchmal kennt man den n√∂tigen Lookahead nicht vorher. Beispiel:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>wuppie();         <span style="color:#75715e">// Vorw√§rtsdeklaration
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>wuppie() { ...}   <span style="color:#75715e">// Definition
</span></span></span></code></pre></div><p>Entsprechend s√§he die Grammatik aus:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>func : fdef <span style="color:#f92672">|</span> fdecl ;
</span></span><span style="display:flex;"><span>fdef : head <span style="color:#e6db74">&#39;{&#39;</span> body <span style="color:#e6db74">&#39;}&#39;</span> ;
</span></span><span style="display:flex;"><span>fdecl: head <span style="color:#e6db74">&#39;;&#39;</span> ;
</span></span><span style="display:flex;"><span>head : <span style="color:#f92672">...</span> ;</span></span></code></pre></div><p>Hier m√ºsste man erst den gesamten Funktionskopf parsen, bevor man entscheiden kann, ob es sich um
eine Deklaration oder eine Definition handelt. Ungl√ºcklicherweise gibt es keine L√§ngenbeschr√§nkung
bei den Funktionsnamen ...</p>
<p>Mit Hilfe von Backtracking kann man zun√§chst spekulativ matchen und beim Auftreten eines Fehlers
die Spekulation r√ºckg√§ngig machen:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">func</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> speculate(fdef): fdef()      <span style="color:#75715e"># Spekuliere auf &#34;fdef&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> speculate(fdecl): fdecl()  <span style="color:#75715e"># Spekuliere auf &#34;fdecl&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">Exception</span>()</span></span></code></pre></div><p>Die erste Alternative, die passt, gewinnt. √úber die Reihenfolge der Spekulationen kann man
entsprechend Vorrangregeln implementieren.</p>
<h3 id="anmerkung">Anmerkung</h3>
<p>Man k√∂nnte die obige Grammatik umformen ...</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>func : head <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;{&#39;</span> body <span style="color:#e6db74">&#39;}&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;;&#39;</span><span style="color:#f92672">)</span> ;
</span></span><span style="display:flex;"><span>head : <span style="color:#f92672">...</span> ;</span></span></code></pre></div><p>...und br√§uchte dann kein spekulatives Parsen mit Backtracking.</p>
<p>Da wir aber das Parsen mit Backtracking betrachten wollen, blenden wir diese M√∂glichkeit
jetzt einfach aus ;)</p>
<h2 id="details-spekulatives-matchen">Details: Spekulatives Matchen</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">speculate</span>(fn):
</span></span><span style="display:flex;"><span>    success <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    mark()                  <span style="color:#75715e"># markiere aktuelle Position</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>:   fn()             <span style="color:#75715e"># probiere Regel fn()</span>
</span></span><span style="display:flex;"><span>    catch: success <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    clear()                 <span style="color:#75715e"># Rollback</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> success</span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, p. 60]</a></span></p>
<p>Der Funktion <code>speculate</code> wird die zu testende Regel (Funktion) als Parameter √ºbergeben, im obigen
Beispiel w√§ren dies <code>fdef</code> bzw. <code>fdecl</code>.</p>
<p>Vor dem spekulativen Matchen muss die aktuelle Position im Tokenstrom markiert werden. Falls der
Versuch, die Deklaration zu matchen nicht funktioniert, wird der Regel-Aufruf eine Exception werfen,
entsprechend wird die Hilfsvariable gesetzt. Anschlie√üend muss noch mit <code>clear()</code> das aktuelle
Token wieder hergestellt werden (wir sind ja nur im Spekulationsmodus, d.h. selbst im Erfolgsfall
wird ja die Regel noch &quot;richtig&quot; aufgerufen).</p>
<h2 id="spekulatives-matchen-hilfsmethoden-iii">Spekulatives Matchen: Hilfsmethoden I/II</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Parser</span>:
</span></span><span style="display:flex;"><span>    Lexer lexer
</span></span><span style="display:flex;"><span>    markers <span style="color:#f92672">=</span> []    <span style="color:#75715e"># Integer-Stack: speichere Tokenpositionen</span>
</span></span><span style="display:flex;"><span>    lookahead <span style="color:#f92672">=</span> []  <span style="color:#75715e"># Puffer (1 Token vorbef√ºllt via Konstruktor)</span>
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>       <span style="color:#75715e"># aktuelle Tokenposition im lookahead-Puffer</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">mark</span>():
</span></span><span style="display:flex;"><span>        markers<span style="color:#f92672">.</span>push(start)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">clear</span>():
</span></span><span style="display:flex;"><span>        start <span style="color:#f92672">=</span> markers<span style="color:#f92672">.</span>pop()</span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, pp. 61/62]</a></span></p>
<h2 id="spekulatives-matchen-hilfsmethoden-iiii">Spekulatives Matchen: Hilfsmethoden II/II</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">consume</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">++</span>start
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> start <span style="color:#f92672">==</span> lookahead<span style="color:#f92672">.</span>count() <span style="color:#f92672">and</span> markers<span style="color:#f92672">.</span>isEmpty():
</span></span><span style="display:flex;"><span>        start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; lookahead<span style="color:#f92672">.</span>clear()
</span></span><span style="display:flex;"><span>    sync(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lookahead</span>(i):
</span></span><span style="display:flex;"><span>    sync(i)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> lookahead<span style="color:#f92672">.</span>get(start<span style="color:#f92672">+</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sync</span>(i):
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> start <span style="color:#f92672">+</span> i <span style="color:#f92672">-</span> lookahead<span style="color:#f92672">.</span>count()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>        lookahead<span style="color:#f92672">.</span>add(lexer<span style="color:#f92672">.</span>nextToken()); <span style="color:#f92672">--</span>n</span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, pp. 61/62]</a></span></p>
<p><code>consume</code> holt wie immer das n√§chste Token, hier indem der Index <code>start</code> weiter gesetzt
wird und ein weiteres Token √ºber <code>sync</code> in den Puffer geladen wird. Falls wir nicht am
Spekulieren sind und das Ende des Puffers erreicht haben, nutzen wir die Gelegenheit und
setzen den Puffer zur√ºck. (Dies geht nicht, wenn wir spekulieren -- hier m√ºssen wir ja
ggf. ein Rollback vornehmen und ben√∂tigen also den aktuellen Puffer dann noch.)</p>
<p>Die Funktion <code>sync</code> stellt sicher, dass ab der Position <code>start</code> noch <code>i</code> unverbrauchte
Token im Puffer sind.</p>
<h3 id="hinweis">Hinweis</h3>
<p>Die Methode <code>count</code> liefert die Anzahl der aktuell gespeicherten Elemente in <code>lookahead</code>
zur√ºck (nicht die Gesamtzahl der Pl√§tze in der Liste -- diese kann gr√∂√üer sein). Mit der
Methode <code>add</code> wird ein Element hinten an die Liste angef√ºgt, dabei wird das Token auf den
n√§chsten Index-Platz (<code>count</code>) geschrieben und ggf. die Liste ggf. automatisch um weitere
Speicherpl√§tze erg√§nzt. √úber <code>clear</code> werden die Elemente in der Liste gel√∂scht, aber der
Speicherplatz erhalten (d.h. <code>count()</code> liefert den Wert 0, aber ein <code>add</code> m√ºsste nicht erst
die Liste mit weiteren Pl√§tzen erweitern, sondern k√∂nnte direkt an Index 0 das Token schreiben).</p>
<h3 id="backtracking-f√ºhrt-zu-problemen">Backtracking f√ºhrt zu Problemen</h3>
<ol>
<li>Backtracking kann <em>sehr</em> langsam sein (Ausprobieren vieler Alternativen)</li>
<li>Der spekulative Match muss ggf. r√ºckg√§ngig gemacht werden</li>
<li>Man muss bereits gematchte Strukturen erneut matchen (=&gt; Abhilfe: Packrat-Parsing)</li>
</ol>
<h2 id="verbesserung-backtracking-packrat-parser-memoizing">Verbesserung Backtracking: Packrat Parser (Memoizing)</h2>
<p><a href="#R-image-af4c00c1db659d4009b74342db18c290" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced/packrat.png?width=60%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 60%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-af4c00c1db659d4009b74342db18c290"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced/packrat.png?width=60%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Bei der Eingabe <code>wuppie();</code> wird zun√§chst spekulativ die erste Alternative <code>fdef</code> untersucht
und ein <code>head</code> gematcht. Da die Alternative nicht komplett passt (es kommt ein &quot;;&quot; statt
einem &quot;{&quot;), muss die Spekulation r√ºckg√§ngig gemacht werden und die zweite Alternative
<code>fdecl</code> untersucht werden. Dabei muss man den selben Input erneut auf <code>head</code> matchen!
(Und wenn die Spekulation (irgendwann) erfolgreich war, muss noch einmal ein <code>head</code> gematcht
werden ...)</p>
<p>Idee: Wenn <code>head</code> sich merken w√ºrde, ob damit ein bestimmter Teil des Tokenstroms bereits
behandelt wurde (erfolgreich oder nicht), k√∂nnte man das Spekulieren effizienter gestalten.
Jede Regel muss also durch eine passende Regel mit Speicherung erg√§nzt werden.</p>
<p>Dies wird auch als <a href="https://en.wikipedia.org/wiki/Memoization" target="_blank">&quot;Memoization&quot;</a> bezeichnet
und ist eine zentrales Technik des Packrat Parsers (vgl. <a href="#id_Packrat2006">[Packrat2006]</a>).</p>
<h2 id="skizze-idee-des-packrat-parsing">Skizze: Idee des Packrat-Parsing</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>head_memo <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">head</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> head_memo<span style="color:#f92672">.</span>get(start) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">Exception</span>()                         <span style="color:#75715e"># kein Match</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> head_memo<span style="color:#f92672">.</span>get(start) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        start <span style="color:#f92672">=</span> head_memo[start]; <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>     <span style="color:#75715e"># Vorspulen</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>; start_ <span style="color:#f92672">=</span> start
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span>: <span style="color:#f92672">...</span>     <span style="color:#75715e"># rufe die urspr√ºngliche head()-Regel auf</span>
</span></span><span style="display:flex;"><span>        catch(e): failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>; <span style="color:#66d9ef">raise</span> e
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">finally</span>: head_memo[start_] <span style="color:#f92672">=</span> (failed <span style="color:#960050;background-color:#1e0010">?</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> : start)</span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, pp. 65/66]</a></span></p>
<ul>
<li>Wenn bereits untersucht (Eintrag vorhanden): Vorspulen bzw. Exception werfen</li>
<li>Sonst (aktuelle Position noch nicht in der Tabelle =&gt; Regel noch nicht an
dieser Position getestet):
<ul>
<li>Original-Regel ausf√ºhren</li>
<li>Exception: Regel hatte keinen Erfolg =&gt; merken und Exception weiter reichen</li>
</ul>
</li>
<li>Ergebnis f√ºr diese Startposition und diese Regel merken:
<ul>
<li>Falls Regel erfolgreich, dann Start-Position und die aktuelle Position
(Stopp-Position) in der Tabelle f√ºr diese Regel notieren</li>
<li>Falls Regel nicht erfolgreich, zur Start-Position eine ung√ºltige Position setzen</li>
</ul>
</li>
</ul>
<h3 id="anmerkung-consume">Anmerkung <em>consume()</em></h3>
<p>Die Funktion <code>consume()</code> muss passend erg√§nzt werden: Wann immer man den <code>lookahead</code>-Puffer
zur√ºcksetzt, werden alle <code>*_memo</code> ung√ºltig und m√ºssen ebenfalls zur√ºckgesetzt werden!</p>
<h2 id="semantische-pr√§dikate">Semantische Pr√§dikate</h2>
<p>Problem in Java: <code>enum</code> ab Java5 Schl√ºsselwort (vorher als Identifier-Name verwendbar)</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>prog : <span style="color:#f92672">(</span>enumDecl <span style="color:#f92672">|</span> stat<span style="color:#f92672">)+</span> ;
</span></span><span style="display:flex;"><span>stat : <span style="color:#f92672">...</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>enumDecl : <span style="color:#66d9ef">ENUM</span> id <span style="color:#e6db74">&#39;{&#39;</span> id <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;,&#39;</span> id<span style="color:#f92672">)*</span> <span style="color:#e6db74">&#39;}&#39;</span> ;</span></span></code></pre></div><p>Wie kann ich eine Grammatik bauen, die sowohl f√ºr Java5 und sp√§ter als auch f√ºr die Vorg√§nger
von Java5 funktioniert?</p>
<p>Angenommen, man h√§tte eine Hilfsfunktion (&quot;Pr√§dikat&quot;), mit denen man aus dem Kontext heraus
die Unterscheidung treffen kann, dann w√ºrde die Umsetzung der Regel ungef√§hr so aussehen:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">prog</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> lookahead(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> ENUM <span style="color:#f92672">and</span> java5: enumDecl()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: stat()</span></span></code></pre></div><h2 id="semantische-pr√§dikate-in-antlr">Semantische Pr√§dikate in ANTLR</h2>
<h3 id="semantische-pr√§dikate-in-parser-regeln">Semantische Pr√§dikate in Parser-Regeln</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>@parser::members {public static boolean java5;}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>prog : <span style="color:#f92672">(</span>{java5}<span style="color:#f92672">?</span> enumDecl <span style="color:#f92672">|</span> stat<span style="color:#f92672">)+</span> ;
</span></span><span style="display:flex;"><span>stat : <span style="color:#f92672">...</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>enumDecl : <span style="color:#66d9ef">ENUM</span> id <span style="color:#e6db74">&#39;{&#39;</span> id <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;,&#39;</span> id<span style="color:#f92672">)*</span> <span style="color:#e6db74">&#39;}&#39;</span> ;</span></span></code></pre></div><p>Pr√§dikate in Parser-Regeln aktivieren bzw. deaktivieren alles, was nach der Abfrage
des Pr√§dikats gematcht werden k√∂nnte.</p>
<h3 id="semantische-pr√§dikate-in-lexer-regeln">Semantische Pr√§dikate in Lexer-Regeln</h3>
<p>Alternativ f√ºr Lexer-Regeln:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>ENUM : <span style="color:#e6db74">&#39;enum&#39;</span> {java5}<span style="color:#f92672">?</span> ;
</span></span><span style="display:flex;"><span>ID   : [a-zA-Z]<span style="color:#f92672">+</span> ;</span></span></code></pre></div><p>Bei Token kommt das Pr√§dikat erst am rechten Ende einer Lexer-Regel vor, da der Lexer keine
Vorhersage macht, sondern nach dem l√§ngsten Match sucht und die Entscheidung erst trifft,
wenn das ganze Token gesehen wurde. Bei Parser-Regeln steht das Pr√§dikat links vor der
entsprechenden Alternative, da der Parser mit Hilfe des Lookaheads Vorhersagen trifft, welche
Regel/Alternative zutrifft.</p>
<p><em>Anmerkung</em>: Hier wurden nur Variablen eingesetzt, es k√∂nnen aber auch Methoden/Funktionen
genutzt werden. In Verbindung mit einer Symboltabelle (<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html/cb_symboltabellen1.html">&quot;Symboltabellen&quot;</a>)
und/oder mit Attributen und Aktionen in der Grammatik (<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html/cb_attribute.html">&quot;Attribute&quot;</a> und
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html/cb_interpreter2.html">&quot;Interpreter: Attribute+Aktionen&quot;</a>) hat man hier ein m√§chtiges Hilfswerkzeug!</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>LL(1) und LL(k): Erweiterungen
<ul>
<li>Dynamischer Lookahead: BT-Parser mit Packrat-Erg√§nzung</li>
<li>Semantische Pr√§dikate zum Abschalten von Alternativen</li>
</ul>
</li>
</ul>


    



    



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Abschnitte 2.4 und 4.4</em></li> <li id='id_Grune2012'>[Grune2012] <strong>Modern Compiler Design</strong><br>Grune, D. und van, Reeuwijk, K. und Bal, H. E. und Jacobs, C. J. H. und Langendoen, K., Springer, 2012. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-4614-4698-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-4614-4698-9</a>.<br><em>Abschnitte 3.1 bis (einschlie√ülich) 3.4</em></li> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 2 (insbesondere Abschnitte 2.3 bis (einschlie√ülich) 2.19)</em></li> <li id='id_Packrat2006'>[Packrat2006] <a href='http://arxiv.org/abs/cs/0603077' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>Packrat Parsing: Simple, Powerful, Lazy, Linear Time</strong></a><br>Ford, B., 2006.</li> <li id='id_Parr2010'>[Parr2010] <strong>Language Implementation Patterns</strong><br>Parr, T., Pragmatic Bookshelf, 2010. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5645-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5645-6</a>.<br><em>Kapitel 3</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Parser mit ANTLR generieren</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>Mit ANTLR kann aus einer Grammatik ein LL(*)-Parser generiert werden. Die Parser-Regeln
in der Grammatik fangen dabei mit einem <strong>Kleinbuchstaben</strong> an (Erinnerung: Lexer-Regel
starten mit einem Gro√übuchstaben).</p>
<p>Regeln haben einen Namen (linke Seite) und eine Produktion (rechte Seite). Dabei
k√∂nnen beliebige Abfolgen von Lexer- und Parser-Regeln auf der rechten Seite
einer Parser-Regel auftauchen. Die Token m√ºssen jeweils matchen, die Parser-Regeln
werden in einen Aufruf der jeweiligen generierten Funktion √ºbersetzt.</p>
<p>Parser-Regeln k√∂nnen aus mehreren Alternativen bestehen, diese werden per <code>|</code> separiert.
Dabei hat bei Mehrdeutigkeiten die erste passende Alternative Vorrang. Wie bei Lexer-Regeln
k√∂nnen Teile per <code>?</code> ein- oder keinmal vorkommen, per <code>*</code> beliebig oft oder per <code>+</code> ein-
oder mehrfach.</p>
<p>ANTLR erlaubt im Gegensatz zu allgemeinen LL-Parsern direkte Links-Rekursion. (Indirekte
Links-Rekursion funktioniert allerdings nicht.)</p>
<p>Der von ANTLR generierte Parser erzeugt auf der Eingabe einen Parse-Tree, der die Strukturen
der Grammatik widerspiegelt: Die Token bilden die Bl√§tter und jede erfolgreich durchlaufene
Parser-Regel bildet einen entsprechenden Knoten im Baum.</p>
<p>F√ºr die Traversierung des Parse-Tree kann man die generierten Listener- oder Visitor-Klassen
nutzen. Beim Einsatz der Listener nutzt man die vorgegebene Klasse <code>ParseTreeWalker</code>, die
mit dem Parse-Tree und dem Listener den Baum per Tiefensuche traversiert und immer die
jeweiligen <code>enterRegel</code>- und <code>exitRegel</code>-Methoden aufruft. Beim Visitor muss die Traversierung
selbst erledigt werden, hier steht die aus der Klassenhierarchie geerbte Methode <code>visit</code>
als Startpunkt zur Verf√ºgung. In dieser Methode wird basierend auf dem Knotentyp die in den
Visitor-Klassen implementierte <code>visitRegel</code>-Methode aufgerufen und man muss darauf achten,
die Kindknoten durch passende Aufrufe zu traversieren. Sowohl bei den generierten Listener-
als auch den Visitor-Klassen kann man die leeren Defaultmethoden bei Bedarf selbst √ºberschreiben.
F√ºr den Zugriff auf die Regel-Elemente werden die sogenannten Kontextobjekte als Parameter
√ºbergeben.</p>
<p>Benannte Alternativen und Regel-Elemente sind n√ºtzlich, weil f√ºr die benannten Alternativen
zus√§tzliche Kontextklassen erzeugt werden, √ºber die dann auf die Bestandteile der Alternativen
zugegriffen werden kann. Au√üerdem werden zus√§tzlich passende <code>enterAlternative</code>- und <code>exitAlternative</code>-
bzw. <code>visitAlternative</code>-Methoden generiert. F√ºr benannte Regel-Elemente wird ein entsprechend
benanntes Attribut im Kontextobjekt angelegt, welches <code>public</code> sichtbar ist.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/YuUHBvPUS4k' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Parser mit ANTLR</a></li> <li><a href='https://youtu.be/FJOEPY-TMmw' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Demo ANTLR Parser</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/19925b756d6fc934bfe0b5107eb5fa58373a53af49c690ebce86e15f2b212c89c80ea7665e42c78abdc8dfe0718ea46f6a9817eeba4ad1293bdb4c84f7c8f084' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Parser mit ANTLR</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K2) Aufbau der Parser-Regeln</li> <li>(K3) Alternativen und optionale/mehrfache Regelteile in Parser-Regeln</li> <li>(K3) Vorrang von Alternativen (bei Mehrdeutigkeiten)</li> <li>(K3) Benannte Alternativen und Regel-Elemente</li> <li>(K2) Aufbau des Parse-Tree</li> <li>(K3) Umgang mit Kontext-Objekten</li> <li>(K3) Traversierung des Parse-Tree mit den generierten Listenern oder Visitors</li></ul></div>
</div>




    <h2 id="hello-world">Hello World</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span><span style="color:#66d9ef">grammar</span> <span style="color:#a6e22e">Hello</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>start : stmt<span style="color:#f92672">*</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>stmt  : <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> expr <span style="color:#e6db74">&#39;;&#39;</span> <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;;&#39;</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>expr  : term <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;+&#39;</span> term<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>term  : atom <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;*&#39;</span> atom<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>atom  : <span style="color:#66d9ef">ID</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">NUM</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ID    : [a-z][a-zA-Z]<span style="color:#f92672">*</span> ;
</span></span><span style="display:flex;"><span>NUM   : [0-9]<span style="color:#f92672">+</span> ;
</span></span><span style="display:flex;"><span>WS    : [ \t\n]<span style="color:#f92672">+</span> <span style="color:#f92672">-&gt;</span> skip ;</span></span></code></pre></div><div style="text-align: right;">
<span class="btn cstyle default">
  <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/lecture/frontend/parsing/src/Hello.g4" target="_blank">
    Konsole: Hello (grun, Parse-Tree)
  </a>
</span></div>
<h3 id="starten-des-parsers">Starten des Parsers</h3>
<ol>
<li>Grammatik √ºbersetzen und Code generieren: <code>antlr Hello.g4</code></li>
<li>Java-Code kompilieren: <code>javac *.java</code></li>
<li>Parser ausf√ºhren:
<ul>
<li>
<p><code>grun Hello start -tree</code> oder <code>grun Hello start -gui</code> (Grammatik &quot;Hello&quot;, Startregel &quot;start&quot;)</p>
</li>
<li>
<p>Alternativ mit kleinem Java-Programm:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> org.antlr.v4.runtime.CharStreams<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.antlr.v4.runtime.CommonTokenStream<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.antlr.v4.runtime.tree.ParseTree<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        HelloLexer lexer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HelloLexer<span style="color:#f92672">(</span>CharStreams<span style="color:#f92672">.</span><span style="color:#a6e22e">fromStream</span><span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        CommonTokenStream tokens <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CommonTokenStream<span style="color:#f92672">(</span>lexer<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        HelloParser parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HelloParser<span style="color:#f92672">(</span>tokens<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ParseTree tree <span style="color:#f92672">=</span> parser<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>  <span style="color:#75715e">// Start-Regel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>tree<span style="color:#f92672">.</span><span style="color:#a6e22e">toStringTree</span><span style="color:#f92672">(</span>parser<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div></li>
</ul>
</li>
</ol>
<h3 id="startregeln">Startregeln</h3>
<ul>
<li><code>start</code> ist eine <span class='alert'>Parser-Regel</span>
=&gt; Eine Parser-Regel pro Grammatik wird ben√∂tigt, damit man den generierten
Parser am Ende auch starten kann ...</li>
<li>Alle Regeln mit kleinem Anfangsbuchstaben sind Parser-Regeln</li>
<li>Alle Regeln mit gro√üem Anfangsbuchstaben sind Lexer-Regeln</li>
</ul>
<h3 id="formen-der-subregeln">Formen der Subregeln</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt  : <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> expr <span style="color:#e6db74">&#39;;&#39;</span> ;</span></span></code></pre></div><p>Um die Regel <code>stmt</code> anwenden zu k√∂nnen, m√ºssen alle Elemente auf der rechten
Seite der Regel erf√ºllt werden. Dabei m√ºssen die Token wie <code>ID</code>, <code>=</code> und <code>;</code>
matchen und die Subregel <code>expr</code> muss erf√ºllt werden k√∂nnen. Beachten Sie das
abschlie√üende Semikolon am Ende einer ANTLR-Regel!</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt  : <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> expr <span style="color:#e6db74">&#39;;&#39;</span> <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;;&#39;</span> ;</span></span></code></pre></div><p>Alternativen werden durch ein <code>|</code> getrennt. Hier muss genau eine Alternative
erf√ºllt werden. Falls n√∂tig, trennt man die Alternativen durch Einschlie√üung
in runden Klammern vom Rest der Regel ab: <code>r : a (b | c) d ;</code>.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr  : term <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;+&#39;</span> term<span style="color:#f92672">)*</span> ;</span></span></code></pre></div><p>Der durch den <code>*</code> gekennzeichnete Teil kann beliebig oft vorkommen oder auch
fehlen. Bei einem <code>+</code> m√ºsste der Teil mind. einmal vorkommen und bei einem
<code>?</code> entsprechend einmal oder keinmal.</p>
<p>Auch hier kann man die Operatoren durch ein zus√§tzliches <code>?</code> auf non-greedy
umschalten (analog zu den Lexer-Regeln).</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/parser-rules.md#subrules" target="_blank">github.com/antlr/antlr4/blob/master/doc/parser-rules.md</a>)</p>
<h3 id="reihenfolge-in-grammatik-definiert-priorit√§t">Reihenfolge in Grammatik definiert Priorit√§t</h3>
<p>Falls mehr als eine Parser-Regel die selbe Input-Sequenz matcht, l√∂st ANTLR
diese Mehrdeutigkeit auf, indem es die erste Alternative nimmt, die an der
Entscheidung beteiligt ist.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>start : stmt ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>stmt  : expr <span style="color:#f92672">|</span> <span style="color:#66d9ef">ID</span>  ;
</span></span><span style="display:flex;"><span>expr  : <span style="color:#66d9ef">ID</span>   <span style="color:#f92672">|</span> <span style="color:#66d9ef">NUM</span> ;</span></span></code></pre></div><p>Bei der Eingabe &quot;foo&quot; w√ºrde die Alternative <code>ID</code> in der Regel <code>expr</code> &quot;gewinnen&quot;,
weil sie in der Grammatik vor der Alternative <code>ID</code> in der Regel <code>stmt</code> kommt und
damit Vorrang hat.</p>
<h3 id="parse-tree">Parse-Tree</h3>
<p>Betrachten wir erneut die obige Grammatik.</p>
<p>Die Eingabe von &quot;<code>a = 42;</code>&quot; f√ºhrt zu folgendem Parse-Tree:</p>
<p><a href="#R-image-17460c670750a3d9f3dbfa72b9dc5905" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/hello_ex1.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-17460c670750a3d9f3dbfa72b9dc5905"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/hello_ex1.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Diese Eingabe f√ºhrt zur Erkennung der Token <code>[ID, WS, =, WS, NUM, ;]</code>, wobei die
<code>WS</code>-Token verworfen werden und der Parser den Tokenstream <code>[ID, =, NUM, ;]</code>
erh√§lt.</p>
<p>Die Startregel hat auf der rechten Seite kein oder mehrere <code>stmt</code>-Regeln. Die
<code>stmt</code>-Regel fordert auf der rechten Seite entweder die Token <code>ID</code>und <code>=</code> sowie
die Regel <code>expr</code> gefolgt vom Token <code>;</code>, oder die Regel <code>expr</code> gefolgt vom Token
<code>;</code>. In unserem Beispiel kann f√ºr das &quot;a&quot; das Token <code>ID</code> produziert werden, das
&quot;=&quot; matcht ebenfalls. Die &quot;42&quot; wird erkl√§rt, indem f√ºr <code>expr</code> ein <code>term</code> und
dort ein <code>atom</code> aufgerufen wird. F√ºr das <code>atom</code> muss entweder ein Token <code>ID</code>
oder <code>NUM</code> als n√§chstes Token kommen - hier wird die &quot;42&quot; wird als Token <code>NUM</code>
verarbeitet. Da die weiteren Regelteile in <code>term</code> und <code>expr</code> optional sind,
haben wir damit ein <code>expr</code> erf√ºllt und das nachfolgende <code>;</code>-Token schlie√üt die
erste Alternative der Regel <code>stmt</code> erfolgreich ab.</p>
<p>Im entstehenden Parse-Tree sind diese Abl√§ufe und grammatikalischen Strukturen
direkt erkennbar. Jede erfolgreich durchlaufene Parserregel wird zu einem
Knoten im Parse-Tree. Die Token werden als Terminale (Bl√§tter) in den Baum
eingeh√§ngt.</p>
<p><em>Anmerkung</em>: Der Parse-Tree ist das Ergebnis der Parsers-Phase im Compiler und
dient damit als Input f√ºr die folgenden Compilerstufen. In der Regel ben√∂tigt
man die oft recht komplexen Strukturen aber sp√§ter nicht mehr und vereinfacht
den Baum zu einem <em>Abstract Syntax Tree</em> (AST). Im Beispiel k√∂nnte man den Zweig
<code>stmt - expr - term - atom - 42</code> zu <code>stmt - 42</code> vereinfachen.</p>
<p>Betrachten wir nun die Eingabe <code>foo = 2+3*4; bar = 3*4+2;</code>. Diese f√ºhrt zu
folgendem Parse-Tree:</p>
<p><a href="#R-image-5f78916b80c3433210ac1f091312c713" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/hello_ex2.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5f78916b80c3433210ac1f091312c713"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/hello_ex2.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Wie man sehen kann, sind in der Grammatik die √ºblichen Vorrangregeln f√ºr die
Operationen <code>+</code> und <code>*</code> ber√ºcksichtigt - die Multiplikation wird in beiden
F√§llen korrekt &quot;unter&quot; der Addition im Baum eingeh√§ngt.</p>
<h3 id="to-eof-not-to-eof">To EOF not to EOF?</h3>
<p>Startregeln m√ºssen nicht unbedingt den gesamten Input &quot;konsumieren&quot;. Sie m√ºssen
per Default nur eine der Alternativen in der Startregel erf√ºllen.</p>
<p>Betrachten wir noch einmal einen leicht modifizierten Ausschnitt aus der obigen
Grammatik:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>start : stmt ;</span></span></code></pre></div><p>Die Startregel wurde so ge√§ndert, dass sie nur noch genau ein Statement
akzeptieren soll.</p>
<p>In diesem Fall w√ºrde die Startregel bei der Eingabe &quot;aa; bb;&quot; nur den ersten
Teil &quot;aa;&quot; konsumieren (als Token <code>ID</code>) und das folgende &quot;bb;&quot; ignorieren.
Das w√§re in diesem Fall aber auch kein Fehler.</p>
<p>Wenn der gesamte Eingabestrom durch die Startregel erkl√§rt werden soll,
dann muss das vordefinierte Token <code>EOF</code> am Ende der Startregel eingesetzt
werden:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>start : stmt <span style="color:#66d9ef">EOF</span>;</span></span></code></pre></div><p>Hier w√ºrde die Eingabe &quot;aa; bb;&quot; zu einem Fehler f√ºhren, da nur der Teil &quot;aa;&quot;
durch die Startregel abgedeckt ist (Token <code>ID</code>), und der Rest &quot;bb;&quot; zwar sogar
ein g√ºltiges Token w√§ren (ebenfalls <code>ID</code> und <code>;</code>), aber eben nicht mehr von der
Startregel akzeptiert. Durch das <code>EOF</code> soll die Startregel aber den gesamten
Input konsumieren und erkl√§ren, was hier nicht geht und entsprechend zum Fehler
f√ºhrt.</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/parser-rules.md#start-rules-and-eof" target="_blank">github.com/antlr/antlr4/blob/master/doc/parser-rules.md</a>)</p>
<h2 id="expressions-und-vorrang-operatoren">Expressions und Vorrang (Operatoren)</h2>
<p>Betrachten wir noch einmal den Ausschnitt f√ºr die Ausdr√ºcke (<em>Expressions</em>) in
der obigen Beispielgrammatik:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr  : term <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;+&#39;</span> term<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>term  : atom <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;*&#39;</span> atom<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>atom  : <span style="color:#66d9ef">ID</span> ;</span></span></code></pre></div><p>Diese typische, etwas komplex anmutende Struktur soll sicher stellen, dass die
Vorrangregeln f√ºr Addition und Multiplikation korrekt beachtet werden, d.h. dass
<code>2+3*4</code> als <code>2+(3*4)</code> geparst wird und nicht f√§lschlicherweise als <code>(2+3)*4</code>
erkannt wird.</p>
<p>Zus√§tzlich muss bei LL-Parsern Links-Rekursion vermieden werden: Die Parser-Regeln
werden in Funktionsaufrufe √ºbersetzt, d.h. bei einer Links-Rekursion w√ºrde man die
selbe Regel immer wieder aufrufen, ohne ein Token aus dem Token-Strom zu entnehmen.</p>
<p>ANTLR (ab Version 4) kann mit beiden Aspekten automatisch umgehen:</p>
<ul>
<li>ANTLR kann direkte Linksrekursion automatisch aufl√∂sen. Die Regel <code>r : r T U | V ;</code>
kann also in ANTLR verarbeitet werden.</li>
<li>ANTLR besitzt einen Mechanismus zur Aufl√∂sung von Mehrdeutigkeiten. Wie oben
geschrieben, wird bei der Anwendbarkeit von mehreren Alternativen die erste
Alternative genutzt.</li>
</ul>
<p>Damit l√§sst sich die typische Struktur f√ºr Expression-Grammatiken deutlich lesbarer
gestalten:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr  : expr <span style="color:#e6db74">&#39;*&#39;</span> expr
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;+&#39;</span> expr
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#66d9ef">ID</span>
</span></span><span style="display:flex;"><span>      ;</span></span></code></pre></div><p>Die Regel <code>expr</code> ist links-rekursiv, was normalerweise bei LL-Parsern problematisch
ist. ANTLR l√∂st diese Links-Rekursion automatisch auf (vgl.
<a href="https://github.com/antlr/antlr4/blob/master/doc/left-recursion.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/left-recursion.md</a>).</p>
<p>Da bei Mehrdeutigkeit in der Grammatik, also bei der Anwendbarkeit mehrerer Alternativen
stets die erste Alternative genommen wird, lassen sich die Vorrangregeln durch die
Reihenfolge der Alternativen in der <code>expr</code>-Regel implementieren: Die Multiplikation
hat Vorrang von der Addition, und diese hat wiederum Vorrang von einer einfachen <code>ID</code>.</p>
<h3 id="direkte-vs-indirekte-links-rekursion">Direkte vs. indirekte Links-Rekursion</h3>
<p>ANTLR kann nur <em>direkte</em> Links-Rekursion aufl√∂sen. Regeln wie <code>r : r T U | V ;</code> stellen
in ANTLR also kein Problem dar.</p>
<p><em>Indirekte</em> Links-Rekursion erkennt ANTLR dagegen nicht:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>r : s <span style="color:#66d9ef">T</span> <span style="color:#66d9ef">U</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">V</span> ;
</span></span><span style="display:flex;"><span>s : r <span style="color:#66d9ef">W</span> <span style="color:#66d9ef">X</span> ;</span></span></code></pre></div><p>Hier w√ºrden sich die Regeln <code>r</code> und <code>s</code> gegenseitig aufrufen und kein Token aus dem
Tokenstrom entfernen, so dass der generierte LL-Parser hier in einer Endlosschleife
stecken bleiben w√ºrde. Mit indirekter Links-Rekursion kann ANTLR nicht umgehen.</p>
<h3 id="konflikte-in-regeln">Konflikte in Regeln</h3>
<p>Wenn mehrere Alternativen einer Regel anwendbar sind, entscheidet sich ANTLR f√ºr die
erste Alternative.</p>
<p>Wenn sich mehrere Tokenregeln √ºberlappen, &quot;gewinnt&quot; auch hier die zuerst definierte
Regel.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>def : <span style="color:#e6db74">&#39;func&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;(&#39;</span> <span style="color:#e6db74">&#39;)&#39;</span> block ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>FOR : <span style="color:#e6db74">&#39;for&#39;</span> ;
</span></span><span style="display:flex;"><span>ID  : [a-z][a-zA-Z]<span style="color:#f92672">*</span> ;</span></span></code></pre></div><p>Hier werden ein implizites Token <code>'func'</code> sowie die expliziten Token <code>FOR</code> und <code>ID</code>
definiert. Dabei sind die Lexeme f√ºr <code>'func'</code> und <code>FOR</code> auch in <code>ID</code> enthalten.
Dennoch werden <code>'func'</code> und <code>FOR</code> erkannt und nicht √ºber <code>ID</code> gematcht, weil sie
<em>vor</em> der Regel <code>ID</code> definiert sind.</p>
<p>Tats√§chlich sortiert ANTLR die Regeln intern um, so dass alle Parser-Regeln <em>vor</em> den
Lexer-Regeln definiert sind. Die impliziten Token werden dabei noch vor den expliziten
Token-Regeln angeordnet. Im obigen Beispiel hat also <code>'func'</code> eine h√∂here Priorit√§t
als <code>FOR</code>, und <code>FOR</code> hat eine h√∂here Priorit√§t als <code>ID</code>. Aus diesem Grund gibt es die
Konvention, die Parser-Regeln in der Grammatik vor den Lexer-Regeln zu definieren - dies
entspricht quasi der Anordnung, die ANTLR bei der Verarbeitung sowieso erzeugen w√ºrde.</p>
<p>Aus diesem Grund w√ºrde auch eine Umsortierung der obigen Grammatik funktionieren:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>FOR : <span style="color:#e6db74">&#39;for&#39;</span> ;
</span></span><span style="display:flex;"><span>ID  : [a-z][a-zA-Z]<span style="color:#f92672">*</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def : <span style="color:#e6db74">&#39;func&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;(&#39;</span> <span style="color:#e6db74">&#39;)&#39;</span> block ;</span></span></code></pre></div><p>Intern w√ºrde ANTLR die Parser-Regel <code>def</code> wieder vor den beiden Lexer-Regeln anordnen,
und zwischen den Parser-Regeln und den Lexer-Regeln die impliziten Token (hier <code>'func'</code>).</p>
<h2 id="kontext-objekte-f√ºr-parser-regeln">Kontext-Objekte f√ºr Parser-Regeln</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>s    : expr         {List&lt;EContext&gt; x = $expr.ctx.e();}
</span></span><span style="display:flex;"><span>     ;
</span></span><span style="display:flex;"><span>expr : e <span style="color:#e6db74">&#39;*&#39;</span> e ;</span></span></code></pre></div><p><a href="#R-image-9ab78d8370d1b91852d454d9b51156ca" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParserRuleContext.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9ab78d8370d1b91852d454d9b51156ca"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParserRuleContext.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Jede Regel liefert ein passend zu dieser Regel generiertes Kontext-Objekt
zur√ºck. Dar√ºber kann man das/die Kontextobjekt(e) der Sub-Regeln abfragen.</p>
<p>Die Regel <code>s</code> liefert entsprechend ein <code>SContext</code>-Objekt und die Regel
<code>expr</code> liefert ein <code>ExprContext</code>-Objekt zur√ºck.</p>
<p>In der Aktion fragt man das Kontextobjekt √ºber <code>ctx</code> ab, in den Listener-
und Visitor-Methoden erh√§lt man die Kontextobjekte als Parameter.</p>
<p>F√ºr einfache Regel-Aufrufe liefert die parameterlose Methode nur ein
einziges Kontextobjekt (statt einer Liste) zur√ºck.</p>
<p><strong>Anmerkung</strong>: ANTLR generiert nur dann <em>Felder</em> f√ºr die Regel-Elemente im
Kontextobjekt, wenn diese in irgendeiner Form referenziert werden. Dies
kann beispielsweise durch Benennung (Definition eines Labels, siehe n√§chste
Folie) oder durch Nutzung in einer Aktion (siehe obiges Beispiel) geschehen.</p>
<h2 id="benannte-regel-elemente-oder-alternativen">Benannte Regel-Elemente oder Alternativen</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stat  : <span style="color:#e6db74">&#39;return&#39;</span> value<span style="color:#f92672">=</span>e <span style="color:#e6db74">&#39;;&#39;</span>    <span style="color:#f92672">#</span> <span style="color:#66d9ef">Return</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;break&#39;</span> <span style="color:#e6db74">&#39;;&#39;</span>             <span style="color:#f92672">#</span> <span style="color:#66d9ef">Break</span>
</span></span><span style="display:flex;"><span>      ;</span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StatContext</span> <span style="color:#66d9ef">extends</span> ParserRuleContext <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReturnContext</span> <span style="color:#66d9ef">extends</span> StatContext <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> EContext value<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> EContext <span style="color:#a6e22e">e</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BreakContext</span> <span style="color:#66d9ef">extends</span> StatContext <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span></span></span></code></pre></div><p>Mit <code>value=e</code> wird der Aufruf der Regel <code>e</code> mit dem Label <code>value</code> belegt,
d.h. man kann mit <code>$e.text</code> oder <code>$value.text</code> auf das <code>text</code>-Attribut von
<code>e</code> zugreifen. Falls es in einer Produktion mehrere Aufrufe einer anderen
Regel gibt, <strong>muss</strong> man f√ºr den Zugriff auf die Attribute eindeutige Label
vergeben.</p>
<p>Analog wird f√ºr die beiden Alternativen je ein eigener Kontext erzeugt.</p>
<h2 id="arbeiten-mit-antlr-listeners">Arbeiten mit ANTLR-Listeners</h2>
<p>ANTLR (generiert auf Wunsch) zur Grammatik passende Listener (Interface und
leere Basisimplementierung). Beim Traversieren mit dem Default-<code>ParseTreeWalker</code>
wird der Parse-Tree mit Tiefensuche abgelaufen und jeweils beim Eintritt in
bzw. beim Austritt aus einen/m Knoten der passende Listener mit dem passenden
Kontext-Objekt aufgerufen.</p>
<p>Damit kann man die Grammatik &quot;f√ºr sich&quot; halten, d.h. unabh√§ngig von einer
konkreten Zielsprache und die Aktionen √ºber die Listener (oder Visitors, s.u.)
ausf√ºhren.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;*&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">MULT</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;+&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">ADD</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">DIGIT</span>                    <span style="color:#f92672">#</span> <span style="color:#66d9ef">ZAHL</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p>ANTLR kann zu dieser Grammatik <code>calc.g4</code> einen passenden Listener (Interface
<code>calcListener</code>) generieren (Option <code>-listener</code> beim Aufruf von <code>antlr</code>).
Weiterhin generiert ANTLR eine leere Basisimplementierung (Klasse <code>calcBaseListener</code>):</p>
<p><a href="#R-image-d24621cefc1dbfeb9e6d3b7bbdd0a076" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParseTreeListener.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d24621cefc1dbfeb9e6d3b7bbdd0a076"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParseTreeListener.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>(Nur &quot;interessante&quot; Methoden gezeigt.)</p>
<p>Von dieser Basisklasse leitet man einen eigenen Listener ab und implementiert
die Methoden, die man ben√∂tigt.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyListener</span> <span style="color:#66d9ef">extends</span> calcBaseListener <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exitMULT</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">MULTContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exitADD</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">ADDContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exitZAHL</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">ZAHLContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div><p>Anschlie√üend baut man das alles in eine Traversierung des Parse-Trees ein:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestMyListener</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyListener</span> <span style="color:#66d9ef">extends</span> calcBaseListener <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        calcLexer lexer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcLexer<span style="color:#f92672">(</span>CharStreams<span style="color:#f92672">.</span><span style="color:#a6e22e">fromStream</span><span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        CommonTokenStream tokens <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CommonTokenStream<span style="color:#f92672">(</span>lexer<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        calcParser parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcParser<span style="color:#f92672">(</span>tokens<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ParseTree tree <span style="color:#f92672">=</span> parser<span style="color:#f92672">.</span><span style="color:#a6e22e">s</span><span style="color:#f92672">();</span>    <span style="color:#75715e">// Start-Regel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        ParseTreeWalker walker <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ParseTreeWalker<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        MyListener eval <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyListener<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        walker<span style="color:#f92672">.</span><span style="color:#a6e22e">walk</span><span style="color:#f92672">(</span>eval<span style="color:#f92672">,</span> tree<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div><div style="text-align: right;">
<span class="btn cstyle default">
  <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/lecture/frontend/parsing/src/TestMyListener.java" target="_blank">
    Beispiel: TestMyListener.java und calc.g4
  </a>
</span></div>
<p>In <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/syntaxdriven.html">Syntaxgesteuerte Interpreter</a>
werden wir damit einen einfachen syntaxgesteuerten Interpreter aufbauen.</p>
<h2 id="arbeiten-mit-dem-visitor-pattern">Arbeiten mit dem Visitor-Pattern</h2>
<p>ANTLR (generiert ebenfalls auf Wunsch) zur Grammatik passende Visitoren
(Interface und leere Basisimplementierung).</p>
<p>Hier muss man im Gegensatz zu den Listeners allerdings selbst f√ºr eine geeignete
Traversierung des Parse-Trees sorgen. Daf√ºr hat man mehr Freiheiten im Vergleich
zum Einsatz von Listeners, insbesondere im Hinblick auf R√ºckgabewerte.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;*&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">MULT</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;+&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">ADD</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">DIGIT</span>                    <span style="color:#f92672">#</span> <span style="color:#66d9ef">ZAHL</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p>ANTLR kann zu dieser Grammatik einen passenden Visitor (Interface <code>calcVisitor&lt;T&gt;</code>)
generieren (Option <code>-visitor</code> beim Aufruf von <code>antlr</code>). Weiterhin generiert ANTLR
eine leere Basisimplementierung (Klasse <code>calcBaseVisitor&lt;T&gt;</code>):</p>
<p><a href="#R-image-114f335f30d84c9819ebc2bf736e2cc3" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParseTreeVisitor.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-114f335f30d84c9819ebc2bf736e2cc3"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParseTreeVisitor.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>(Nur &quot;interessante&quot; Methoden gezeigt.)</p>
<p>Von dieser Basisklasse leitet man einen eigenen Visitor ab und √ºberschreibt
die Methoden, die man ben√∂tigt. Wichtig ist, dass man selbst f√ºr das &quot;Besuchen&quot;
der Kindknoten sorgen muss (rekursiver Aufruf der geerbten Methode <code>visit()</code>).</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyVisitor</span> <span style="color:#66d9ef">extends</span> calcBaseVisitor<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">visitMULT</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">MULTContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">visitADD</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">ADDContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">visitZAHL</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">ZAHLContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div><p>Anschlie√üend baut man das alles in eine manuelle Traversierung des Parse-Trees ein:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestMyVisitor</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyVisitor</span> <span style="color:#66d9ef">extends</span> calcBaseVisitor<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        calcLexer lexer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcLexer<span style="color:#f92672">(</span>CharStreams<span style="color:#f92672">.</span><span style="color:#a6e22e">fromStream</span><span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        CommonTokenStream tokens <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CommonTokenStream<span style="color:#f92672">(</span>lexer<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        calcParser parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcParser<span style="color:#f92672">(</span>tokens<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ParseTree tree <span style="color:#f92672">=</span> parser<span style="color:#f92672">.</span><span style="color:#a6e22e">s</span><span style="color:#f92672">();</span>    <span style="color:#75715e">// Start-Regel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        MyVisitor eval <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyVisitor<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        eval<span style="color:#f92672">.</span><span style="color:#a6e22e">visit</span><span style="color:#f92672">(</span>tree<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div><div style="text-align: right;">
<span class="btn cstyle default">
  <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/lecture/frontend/parsing/src/TestMyVisitor.java" target="_blank">
    Beispiel: TestMyVisitor.java und calc.g4
  </a>
</span></div>
<p>In <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/syntaxdriven.html">Syntaxgesteuerte Interpreter</a>
werden wir damit einen einfachen syntaxgesteuerten Interpreter aufbauen.</p>
<h2 id="eingebettete-aktionen-und-attribute">Eingebettete Aktionen und Attribute</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>s   : expr                      {System.err.println($expr.v);}
</span></span><span style="display:flex;"><span>    ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>expr <span style="color:#66d9ef">returns</span> [int v]
</span></span><span style="display:flex;"><span>    : e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;*&#39;</span> e2<span style="color:#f92672">=</span>expr       {$v = $e1.v * $e2.v;}
</span></span><span style="display:flex;"><span>    ;</span></span></code></pre></div><p>Auch die Parser-Regeln k√∂nnen mit eingebetteten Aktionen erg√§nzt werden, die
in die (f√ºr die jeweilige Regel) generierte Methode eingef√ºgt werden und bei
erfolgreicher Anwendung der Parser-Regel ausgef√ºhrt werden.</p>
<p>√úber <code>returns [int v]</code> f√ºgt man der Regel <code>expr</code> ein Attribut <code>v</code> (Integer)
hinzu, welches man im jeweiligen Kontext abfragen bzw. setzen kann (agiert
als R√ºckgabewert der generierten Methode). Auf diesen Wert kann in den
Aktionen mit <code>$v</code> zugegriffen werden.</p>
<p>In <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/attribgrammars.html">Attributierte Grammatiken</a>
werfen wir einen genaueren Blick auf die attributierten Grammatiken. In
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/syntaxdriven.html">Syntaxgesteuerte Interpreter</a>
werden wir eingebettete Aktionen und Attribute nutzen, um einen einfachen
syntaxgesteuerten Interpreter aufzubauen.</p>
<p><em>Anmerkung</em>: Durch den Einsatz von eingebetteten Aktionen und Attributen wird
die Grammatik abh√§ngig von der Zielsprache des generierten Lexers/Parsers!</p>
<h2 id="ausblick">Ausblick</h2>
<p>Damit haben wir die sprichw√∂rtliche &quot;Spitze des Eisbergs&quot; gesehen. Mit ANTLR
sind noch viele weitere Dinge m√∂glich. Bitte nutzen Sie aktiv die Dokumentation
auf <a href="https://github.com/antlr/antlr4" target="_blank">github.com/antlr/antlr4</a>.</p>
<p>Mit Hilfe von semantischen Pr√§dikaten (vgl.
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html">LL-Parser: Fortgeschrittene Techniken</a>)
k√∂nnen Parser-Regeln aktiviert oder abgeschaltet werden, je nachdem, was vorher
gesehen wurde.</p>
<p>Dem Thema Behandlung von Fehlern ist eine eigene Sitzung gewidmet:
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery.html">Error-Recovery</a>.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<p>Parser mit ANTLR generieren: Parser-Regeln werden mit <strong>Kleinbuchstaben</strong> geschrieben</p>
<ul>
<li>Regeln k√∂nnen Lexer- und Parser-Regeln &quot;aufrufen&quot;</li>
<li>Regeln k√∂nnen Alternativen haben</li>
<li>Bei Mehrdeutigkeit: Vorrang f√ºr erste Alternative</li>
<li>ANTLR erlaubt direkte Links-Rekursion</li>
<li>ANTLR erzeugt Parse-Tree</li>
<li>Benannte Alternativen und Regel-Elemente</li>
<li>Traversierung des Parse-Tree: Listener oder Visitoren, Zugriff auf Kontextobjekte</li>
</ul>


    



    



    

    
<div class="box notices cstyle note">
  <div class="box-label"><i class="fas fa-puzzle-piece"></i> Challenges</div>
  <div class="box-content">

<p><strong>Lexer und Parser mit ANTLR: Programmiersprache Lox</strong></p>
<p>Betrachten Sie folgenden Code-Schnipsel in der Sprache <a href="https://www.craftinginterpreters.com/the-lox-language.html" target="_blank">&quot;Lox&quot;</a>:</p>
<pre><code>fun fib(x) {
    if (x == 0) {
        return 0;
    } else {
        if (x == 1) {
            return 1;
        } else {
            fib(x - 1) + fib(x - 2);
        }
    }
}

var wuppie = fib(4);
</code></pre>
<p>Erstellen Sie f√ºr diese fiktive Sprache einen Lexer+Parser mit ANTLR.</p>
<p>(Die genauere Sprachdefinition finden Sie bei Bedarf unter <a href="https://www.craftinginterpreters.com/the-lox-language.html" target="_blank">craftinginterpreters.com/the-lox-language.html</a>.)</p>
</div>
</div>



    





    




    
    
        
        

        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Grenze Lexer und Parser</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>Die Grenze zwischen Lexer und Parser ist gleitend. Das Ziel jeder Verarbeitungsstufe in der
Compilerpipeline sollte es sein, eine m√∂glichst hohe Abstraktion auf der jeweiligen Ebene
zu erreichen.</p>
<p>Das f√ºhrt zu einfachen Grundregeln:</p>
<ul>
<li>Verwerfe im Lexer alles, was ich sp√§ter nicht mehr ben√∂tige</li>
<li>Fasse so viel wie m√∂glich zusammen:
<ul>
<li>Dinge, die der Parser unterscheiden k√∂nnen muss, sollten vom Lexer als unterschiedliche
Token erkannt werden</li>
<li>Dinge, die der Parser nicht unterscheiden muss, k√∂nnten in einen gemeinsamen Token-Typ
geschrieben werden</li>
<li>Fasse nach M√∂glichkeit passende Zeichenfolgen als ein Token zusammen, d.h. pr√§sentiere
dem Parser nicht eine Folge von Ziffern-Token, sondern <em>ein</em> Number-Token (wenn im
Zeichenstrom eine Integerzahl kommt)</li>
</ul>
</li>
</ul>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/u9fE_I764rg' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Grenze Lexer und Parser</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/cb1486383c3bc9cf2e1c88b2dd94dea71954ceb2f6ea23dea512f10b3d86c34363b8d9c0ab41ef56fc07d9e3b22726752a92ff426592f129c6d6e674795f91cb' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Grenze Lexer und Parser</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K2) Grenze zwischen Lexer und Parser: Was mache ich auf welcher Stufe?</li></ul></div>
</div>




    <h2 id="grenze-lexer-und-parser-faustregeln">Grenze Lexer und Parser (Faustregeln)</h2>
<p>Der Lexer verwendet einfache regul√§re Ausdr√ºcke, w√§hrend der Parser
mit Lookaheads unterschiedlicher Gr√∂√üe, Backtracking und umfangreicher
Error-Recovery arbeitet. Entsprechend sollte man alle Arbeit, die
man bereits im Lexer erledigen kann, auch dort erledigen. Oder
andersherum: Man sollte dem Parser nicht unn√∂tige Arbeit aufb√ºrden.</p>
<p>=&gt; Erreiche in jeder Verarbeitungsstufe die maximal m√∂gliche Abstraktionsstufe!</p>
<ol>
<li>
<p>Matche und verwerfe im Lexer alles, was der Parser nicht braucht.</p>
<p>Wenn bestimmte Dinge sp√§ter nicht gebraucht werden, sollten sie bereits
im Lexer erkannt und aussortiert werden. Der Lexer arbeitet deutlich
einfacher und schneller als der Parser ... Und je weniger Token der
Parser betrachten muss, um so einfacher und schneller kann er werden.</p>
</li>
<li>
<p>Matche gebr√§uchliche Token (Namen, Schl√ºsselw√∂rter, Strings, Zahlen) im Lexer.</p>
<p>Der Lexer hat deutlich weniger Overhead als der Parser. Es lohnt sich deshalb,
beispielsweise Ziffern bereits im Lexer zu Zahlen zusammenzusetzen und dem
Parser als entsprechendes Token zu pr√§sentieren.</p>
</li>
<li>
<p>Quetsche alle lexikalischen Strukturen, die der Parser nicht unterscheiden muss, in einen Token-Typ.</p>
<p>Wenn der Parser bestimmte Strukturen nicht unterscheiden muss, dann macht es
wenig Sinn, dennoch unterschiedliche Token an den Parser zu senden.</p>
<p>Beispiel:
Wenn eine Anwendung nicht zwischen Integer- und Gleitkommazahlen unterscheidet,
sollte der Lexer daf√ºr nur einen Token-Typ erzeugen und an den Parser senden
(etwa <code>NUMBER</code>).</p>
<p>Beispiel:
Wenn der Parser nicht den Inhalt eines XML-Tags &quot;verstehen&quot; muss, dann kann man
diesen in ein einzelnes Token packen.</p>
</li>
<li>
<p>Wenn der Parser Texteinheiten unterscheiden muss, erzeuge daf√ºr eigene Token-Typen im Lexer.</p>
<p>Wenn der Parser etwa Elemente einer Telefonnummer verarbeiten muss, sollte
der Lexer passende Token f√ºr die Teile der Telefonnummer erzeugen und an den
Parser schicken.</p>
</li>
</ol>
<h2 id="diskussion-parsen-von-adressb√ºchern-und-telefonnummern">Diskussion: Parsen von Adressb√ºchern und Telefonnummern</h2>
<p>Typischer Aufbau eines Adressbuch-Eintrags:</p>
<pre><code>Vorname Name: +49.571.8385-268
</code></pre>
<ul>
<li>
<p>Z√§hlen der Zeilen des Adressbuchs</p>
<p>Wenn es nur um das Z√§hlen der Zeilen geht, muss der Parser nicht den
Aufbau der Zeilen oder sogar den Aufbau von Telefonnummern verstehen.
Es reichen einfache Lexer-Regeln (<code>ROW</code>), die quasi die Zeilenumbr√ºche
repr√§sentieren. Der Rest (<code>OTHER</code>) wird per <code>skip</code> (ANTLR-Syntax)
einfach entfernt ...</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>addrbk : <span style="color:#66d9ef">ROW</span><span style="color:#f92672">+</span>;
</span></span><span style="display:flex;"><span>ROW    : <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>OTHER  : <span style="color:#f92672">~</span><span style="color:#e6db74">&#39;\n&#39;</span> <span style="color:#f92672">-&gt;</span> skip ;</span></span></code></pre></div></li>
<li>
<p>Liste aller Telefonnummern</p>
<p>Wenn man nun eine Liste aller Telefonnummern erzeugen will, w√§re es ausreichend,
die Struktur einer Zeile (und damit die Telefonnummern) mit Lexer-Regeln
(und -Fragmenten) zu erkennen.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>addrbk  : row<span style="color:#f92672">+</span>;
</span></span><span style="display:flex;"><span>row     : <span style="color:#66d9ef">SURNAME</span> <span style="color:#66d9ef">NAME</span> <span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#66d9ef">TELNR</span>;</span></span></code></pre></div></li>
<li>
<p>Weitere Verarbeiten der Telefonnummern im Parser (Aktionen)</p>
<p>Wenn man zus√§tzlich die Telefonnummern noch weiter im Parser verarbeiten will
(etwa durch eingebettete Aktionen), dann muss die Regel zum Erkennen der
Adressen entsprechend eine Parser-Regel sein:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>addrbk  : row<span style="color:#f92672">+</span>;
</span></span><span style="display:flex;"><span>row     : <span style="color:#66d9ef">SURNAME</span> <span style="color:#66d9ef">NAME</span> <span style="color:#e6db74">&#39;:&#39;</span> telnr;</span></span></code></pre></div></li>
</ul>
<p>Die weiterf√ºhrenden Lexer- und Parser-Regeln (<code>telnr</code>, <code>TELNR</code>, <code>SURNAME</code>, <code>NAME</code>)
sind hier nicht dargestellt.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>Grenze zw. Lexer und Parser ist gleitend</li>
<li>Ziel: m√∂glichst hohe Abstraktion auf jeder Ebene erreichen</li>
</ul>


    



    



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Nystrom2021'>[Nystrom2021] <a href='https://github.com/munificent/craftinginterpreters' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>Crafting Interpreters</strong></a><br>Nystrom, R., Genever Benning, 2021. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-9905829-3-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-9905829-3-9</a>.</li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Syntaxanalyse: LR-Parser (Teil 1)</h1>



    
    




    
    
        
        
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="far fa-file-powerpoint"></i> Annotierte Folien</div>
  <div class="box-content">

<ul> <li><a href='https://raw.githubusercontent.com/Compiler-CampusMinden/AnnotatedSlides/master/lr-parser1.ann.ma.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Annotierte Folien: LR-Parser1</a></li></ul></div>
</div>




    <h1 id="wiederholung">Wiederholung</h1>
<h2 id="top-down-analyse">Top-Down-Analyse</h2>
<ul>
<li>Baumaufbau von oben nach unten</li>
<li>die Grammatik muss reduziert sein</li>
<li>recursive-descent parser</li>
<li><em>First-</em> und <em>Follow</em>-Mengen bestimmen Wahl der Ableitungen</li>
<li>tabellengesteuert</li>
<li>nicht mehr rekursiv, sondern mit PDA</li>
</ul>
<h1 id="motivation">Motivation</h1>
<h2 id="ll-ist-nicht-alles"><em>LL</em> ist nicht alles</h2>
<p>Die Menge der <em>LL</em>-Sprachen ist eine echte Teilmenge der deterministisch kontextfreien Sprachen. Wir brauchen ein Verfahren, mit dem man alle deterministisch kontextfreien Sprachen parsen kann.</p>
<h1 id="bottom-up-analyse">Bottom-Up-Analyse</h1>
<h2 id="von-unten-nach-oben">Von unten nach oben</h2>
<p>Bei 
<span class="math align-center">$LL$</span>-Sprachen muss man nach den ersten 
<span class="math align-center">$k$</span> Eingabezeichen entscheiden, welche Ableitung ganz oben im Baum als erste durchgef√ºhrt wird, also eine, die im Syntaxbaum ganz weit weg ist von den Terminalen, die die Entschiedung bestimmen.Es gibt deterministisch kontextfreie Sprachen, die nicht 
<span class="math align-center">$LL(k)$</span> sind f√ºr irgendein <em>k</em>.</p>
<p>Bei der Bottom-Up-Analyse geht man den umgekehrten Weg. Der Parse Tree wird von unten nach oben aufgebaut, die Entscheidung, welche Produktion angewandt wird, erfolgt &quot;n√§her&quot; am Terminal. Mit Hilfe der Produktionen und der Vorschautoken werden die Ableitungen &quot;r√ºckw√§rts&quot; angewandt und &quot;Reduktionen&quot; genannt.</p>
<p>Fehlermeldungen k√∂nnen n√§her am Programmtext erfolgen.</p>
<h2 id="baumaufbau-von-unten">Baumaufbau von unten</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="kann-ein-stack-helfen">Kann ein Stack helfen?</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="probleme-damit">Probleme damit?</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h1 id="konfliktf√§lle">Konfliktf√§lle</h1>
<h2 id="mehrdeutigkeiten--konflikte-beim-parsen">Mehrdeutigkeiten = Konflikte beim Parsen</h2>
<p>Es gibt Grammatiken, bei denen nicht aus dem Inhalt des Stacks und dem Eingabezeichen entschieden werden kann, wie fortgefahren wird, auch nicht, wenn man, wie auch schon im Fall 
<span class="math align-center">$LL$</span>, eine feste Zahl 
<span class="math align-center">$k$</span> von Vorschautoken ber√ºcksichtigt. Diese Grammatiken k√∂nnen mehrdeutig sein.</p>
<p>Folgen von falschen Entscheidungen:</p>
<ul>
<li>falscher Baum, falsche B√§ume</li>
<li>kein Baum</li>
</ul>
<h2 id="m√∂gliche-konflikte">M√∂gliche Konflikte</h2>
<ul>
<li>Reduce-Reduce-Konflikt: Es sind zwei oder mehr verschiedene Reduktionen m√∂glich</li>
<li>Shift-Reduce-Konflikt: Es kann nicht entschieden werden, ob eine Reduktion oder ein Shift durchgef√ºhrt werden soll.</li>
</ul>
<p>Shiften bedeutet, das n√§chste Eingabesymbol miteinbeziehen.</p>
<h1 id="lr-parsing">LR-Parsing</h1>
<h2 id="da-wollen-wir-hin">Da wollen wir hin</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser1/Parser-Automat.png" alt="Parser-Automat" width="80%" height="auto">
    <figcaption><p>Parser-Automat</p></figcaption>
</figure>
<h2 id="so-geht-es">So geht es</h2>
<p>Der Stack enth√§lt Zust√§nde, keine Terminals oder Nonterminals.</p>
<p>Der Top-of-Stack ist immer der aktuelle Zustand, am Anfang

<span class="math align-center">$I_0$</span>. Im Stack steht 
<span class="math align-center">$I_0\ \bot$</span>.</p>
<p>Vorgehen:
Im aktuellen Zustand nachschauen, ob das Eingabezeichen auf einem Pfeil steht.</p>
<ul>
<li>
<p>ja: Shiften, d. h. dem Pfeil folgen und den Zustand am Ende des Pfeils pushen. Dort weiter.</p>
</li>
<li>
<p>nein: Reduzieren nach der Regel aus dem aktuellen Zustand mit dem Punkt hinten, d. h. so viele Zust√§nde poppen, wie die Regel Elemente auf der rechten Seite hat. Der Zustand darunter wird aktuell, dem Pfeil mit dem zu reduzierenden Nonterminal der linken Seite der Regel folgen und pushen.</p>
</li>
</ul>
<p>Am Schluss kann nur noch mit 
<span class="math align-center">$\bot$</span> akzeptiert werden.</p>
<h2 id="beispiel">Beispiel</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="definitionen">Definitionen</h2>
<p><strong>Def.:</strong> Bei einer kontextfreien Grammatik <em>G</em> ist die <em>Rechtsableitung</em> von 
<span class="math align-center">$\alpha \in (N \cup T)^{\ast}$</span> die Ableitung, die man erh√§lt, wenn das am weitesten rechts stehende Nichtterminal in 
<span class="math align-center">$\alpha$</span> abgeleitet wird. Man schreibt 
<span class="math align-center">$\alpha \overset{\ast}{\Rightarrow}_r \beta$</span>.</p>
<p><strong>Def.:</strong> Eine <em>Rechtssatzform</em> 
<span class="math align-center">$\alpha$</span> einer Grammatik <em>G</em> ist ein Element aus

<span class="math align-center">$(N \cup T)^{\ast}$</span> mit 
<span class="math align-center">$S \overset{\ast}{\Rightarrow}_r \alpha$</span>.</p>
<p><strong>Def.:</strong> In dem Syntaxbaum von 
<span class="math align-center">$S \overset{\ast}{\Rightarrow}_r \alpha\ A\ w \Rightarrow_r \alpha\ \beta\ w$</span> einer kontextfreien Grammatik ist 
<span class="math align-center">$\beta$</span> ein <em>Handle</em> von der Produktion 
<span class="math align-center">$A \rightarrow \beta$</span>.</p>
<h2 id="lr-parsing-1">LR-Parsing</h2>
<p>Bei der <em>LR</em>-Analyse eines Wortes <em>w</em> wird <em>w</em> von links nach rechts gelesen, dabei wird die Rechtsableitung von <em>w</em> in <em>G</em> von unten nach oben aufgebaut.
Man spricht nicht nicht mehr von Ableitungen, sondern von Reduktionen.</p>
<p>Mehrdeutige Grammatiken k√∂nnen nicht <em>LR</em> sein.</p>
<ul>
<li>Vor der Konstruktion des Automaten wird die Grammatik um eine neues Nonterminal 
<span class="math align-center">$S'$</span> und die neue Produktion 
<span class="math align-center">$S' \rightarrow S$</span> erweitert. 
<span class="math align-center">$S'$</span> ist dann Startsymbol.</li>
<li>Es wird ein Automat erstellt (s.o.)</li>
<li>Es wird eine Parse Table aus dem Automaten erstellt, die den Parse-Vorgang steuert, mit Aktionsteil und Sprungteil.</li>
</ul>
<h2 id="steuerung-des-parsens-mittels-der-parse-table">Steuerung des Parsens mittels der Parse Table</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser1/ParserProgram.png" alt="Parser Schema" width="80%" height="auto">
    <figcaption><p>Parser Schema</p></figcaption>
</figure>
<h2 id="arbeitsweise">Arbeitsweise</h2>
<p>Im Stack stehen nur Zustandsnummern, am Anfang die Nummer des Startzustandes (+ Bottomzeichen, oft auch 
<span class="math align-center">$\$$</span>). Es ist nicht n√∂tig, Symbole zu stacken.</p>
<ul>
<li>Lesen des obersten Stackelements ergibt Zustand <em>q</em></li>
<li>Lesen des n√§chsten Eingabezeichens ergibt Zeichen <em>a</em></li>
<li>Nachschlagen der Reaktion auf 
<span class="math align-center">$(q, a)$</span> in der Parse Table</li>
<li>Durchf√ºhrung der Reaktion</li>
</ul>
<h2 id="m√∂gliche-actions-ohne-ber√ºcksichtigung-von-vorschautoken">M√∂gliche &quot;Actions&quot; ohne Ber√ºcksichtigung von Vorschautoken</h2>
<ul>
<li>Shift: Schiebe logisch das n√§chste Eingabesymbol auf den Stack (in Wirklichkeit Zustandsnummern)</li>
<li>Reduce: (Identifiziere ein Handle oben auf dem Stack und ersetze es durch das Nichtterminal der dazugeh√∂rigen Produktion.) Das ist gleichbedeutend mit: Entferne so viele Zust√§nde vom Stack wie die rechte Seite der zu reduzierenden Regel Elemente hat, und schreibe den Zustand, der im Goto-Teil f√ºr 
<span class="math align-center">$(q, a)$</span> steht, auf den Stack.</li>
<li>Accept: Beende das Parsen erfolgreich</li>
<li>Reagiere auf einen Syntaxfehler</li>
</ul>
<h1 id="0-vorschautoken--lr0-parsing">0 Vorschautoken = LR(0)-Parsing</h1>
<h2 id="lr-parsing-ohne-vorschautoken">LR-Parsing ohne Vorschautoken</h2>
<p>Wichtig: Das Handle, d. h. die rechte Seite einer zu reduzierenden Regel, erscheint oben auf dem Stack, nie weiter unten.</p>
<p>Je nach Anwendungsfall m√ºssen beim Reduzieren von Handles weitere Aktionen ausgef√ºhrt werden: z. B. Syntaxb√§ume aufgebaut, Werte in Tabellen geschrieben werden, usw. Nicht alle rechten Seiten von Produktionen, die oben auf dem Stack stehen, sind auch Handles, manchmal muss nur geshiftet werden.</p>
<p>Bsp: Steht bei der Beispielgrammatik von Folie 8 oben auf dem Stack ein 
<span class="math align-center">$T$</span> mit dem n√§chsten Eingabezeichen 
<span class="math align-center">$\ast$</span>, darf 
<span class="math align-center">$T$</span> nicht zu 
<span class="math align-center">$E$</span> reduziert werden.</p>
<p>L√∂sung: Der Parser merkt sich, wo er steht in noch nicht komplett reduzierten Regeln. Dazu benutzt er sogenannte <em>Items</em> oder <em>LR(0)-Items</em>, auch <em>dotted Items</em> oder <em>(kanonische) LR(0)-Elemente</em> genannt.</p>
<h2 id="items">Items</h2>
<p><strong>Def.:</strong> Ein <em>Item</em> einer Grammatik <em>G</em> ist eine Produktion von <em>G</em> mit einem Punkt auf der rechten Seite der Regel vor, zwischen oder nach den Elementen.</p>
<p>Bsp.:</p>
<p>Zu der Produktion 
<span class="math align-center">$A \rightarrow BC$</span> geh√∂ren die Items:</p>

<span class="math align-center">$[A\rightarrow \cdot B C]$</span>
<p>
<span class="math align-center">$[A\rightarrow B \cdot C$</span>]</p>

<span class="math align-center">$[A\rightarrow B C \cdot]$</span>
<p>Das zu 
<span class="math align-center">$A \rightarrow \epsilon$</span> geh√∂rende Item ist 
<span class="math align-center">$[A \rightarrow \cdot]$</span></p>
<h2 id="was-bedeuten-die-items">Was bedeuten die Items?</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="berechnung-der-closure_0-von-einer-menge-i-von-items">Berechnung der <em>Closure_0</em> von einer Menge <em>I</em> von Items</h2>
<ol>
<li>
<p>f√ºge 
<span class="math align-center">$I$</span> zu 
<span class="math align-center">$CLOSURE_0 (I)$</span> hinzu</p>
</li>
<li>
<p>gibt es ein Item 
<span class="math align-center">$[A \rightarrow \alpha \cdot B\beta]$</span> aus 
<span class="math align-center">$CLOSURE_0 (I)$</span> und eine Produktion 
<span class="math align-center">$(B \rightarrow \gamma)$</span>, f√ºge 
<span class="math align-center">$[B \rightarrow \cdot \gamma]$</span> zu 
<span class="math align-center">$CLOSURE_0 (I)$</span> hinzu</p>
</li>
</ol>
<h2 id="berechnung-der-goto_0-sprungmarken">Berechnung der <em>GOTO_0</em>-Sprungmarken</h2>

<span class="math align-center">$GOTO_0(I, X) = CLOSURE_0(\lbrace[A \rightarrow \alpha X \cdot \beta] \mid [A \rightarrow \alpha \cdot X \beta] \in I\rbrace)$</span>
<p>f√ºr eine Itemmenge <em>I</em> und 
<span class="math align-center">$X \in N \cup T, A \in N, \alpha, \beta \in (N \cup T)^{\ast}$</span>.</p>
<h2 id="konstruktion-des-hahahugoshortcode23s44hbhb---automaten">Konstruktion des 
<span class="math align-center">$LR(0)$</span> - Automaten</h2>
<ol>
<li>
<p>Bilde die H√ºlle von 
<span class="math align-center">$S' \rightarrow S$</span> und mache sie zum ersten Zustand.</p>
</li>
<li>
<p>F√ºr jedes noch nicht betrachtete 
<span class="math align-center">$\cdot X, X \in (N \cup T)$</span> in einem Zustand 
<span class="math align-center">$q$</span> des Automaten berechne 
<span class="math align-center">$GOTO_0(q, X)$</span> und mache 
<span class="math align-center">$GOTO_0(q, X)$</span> zu einem neuen Zustand 
<span class="math align-center">$r$</span>. Verbinde 
<span class="math align-center">$q$</span> mit einem Pfeil mit 
<span class="math align-center">$r$</span> und schreibe 
<span class="math align-center">$X$</span> an den Pfeil. Ist ein zu 
<span class="math align-center">$r$</span> identischer Zustand schon vorhanden, wird 
<span class="math align-center">$p$</span> mit diesem verbunden und kein neuer erzeugt.</p>
</li>
</ol>
<h2 id="konstruktion-der-parse-table">Konstruktion der Parse Table</h2>
<ol>
<li>
<p>Erstelle eine leere Tabelle mit den Zust√§nden als Zeilen√ºberschriften. F√ºr den Aktionstabellenteil √ºberschreibe die Spalten mit den Terminalen, f√ºr den Sprungtabellenteil mit den Nonterminals.</p>
</li>
<li>
<p>Shift: F√ºr jeden mit einem Terminal beschrifteten Pfeil aus einem Zustand erstelle in der Aktionstabelle die Aktion shift mit der Nummer des Zustands, auf den der Pfeil zeigt. F√ºr Pfeile mit Nonterminals schreibe in die Sprungtabelle nur die Nummer des Folgezustands.</p>
</li>
<li>
<p>Schreibe beim Zustand 
<span class="math align-center">$[S' \rightarrow S \cdot]$</span> ein 
<span class="math align-center">$accept$</span> bei dem Symbol 
<span class="math align-center">$\bot$</span>.</p>
</li>
<li>
<p>F√ºr jedes Item mit 
<span class="math align-center">$[A \rightarrow \beta \cdot]$</span> aus allen Zust√§nden schreibe f√ºr alle Terminals 
<span class="math align-center">$reduce$</span> und die Nummer der entsprechenden Grammatikregel in die Tabelle.</p>
</li>
</ol>
<h2 id="und-wenn-in-einer-zelle-schon-ein-eintrag-ist">Und wenn in einer Zelle schon ein Eintrag ist?</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="die-beispielgrammatik-g1">Die Beispielgrammatik G1</h2>
<p>(0) 
<span class="math align-center">$S^{'} \rightarrow S$</span></p>
<p>(1) 
<span class="math align-center">$S \rightarrow a A b S c S$</span></p>
<p>(2) 
<span class="math align-center">$S \rightarrow a A b S$</span></p>
<p>(3) 
<span class="math align-center">$S \rightarrow d$</span></p>
<p>(4) 
<span class="math align-center">$A \rightarrow e$</span></p>
<h2 id="der-lr0-automat-zu-g1">Der LR(0)-Automat zu G1</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser1/LR_0-SLR_1-Automat.png" alt="LR(0)-Automat" width="auto" height="auto">
    <figcaption><p>LR(0)-Automat</p></figcaption>
</figure>
<h2 id="die-lr0-parsertabelle-zu-g1">Die LR(0)-Parsertabelle zu G1</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser1/LR_0-Table.png" alt="LR(0)-Parsertabelle" width="60%" height="auto">
    <figcaption><p>LR(0)-Parsertabelle</p></figcaption>
</figure>
<h1 id="wrap-up">Wrap-Up</h1>
<h2 id="wrap-up-1">Wrap-Up</h2>
<ul>
<li>
<p>LR-Analyse baut den Ableitungbaum von unten nach oben auf.</p>
</li>
<li>
<p>Es wird ein DFA benutzt zusammen mit einem Stack, der Zust√§nde speichert.</p>
</li>
<li>
<p>Eine Parse-Tabelle steuert √ºber Aktions- und Sprungbefehle das Verhalten des Parsers.</p>
</li>
<li>
<p>Die Tabelle wird mit Items und Closures konstruiert.</p>
</li>
</ul>


    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Kapitel 4.5 bis 4.8</em></li> <li id='id_aho2013compilers'>[aho2013compilers] <strong>Compilers: Pearson New International Edition: Principles, Techniques, and Tools</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Education Limited, 2013. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-2920-3723-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-2920-3723-3</a>.</li> <li id='id_hopcroft2003'>[hopcroft2003] <strong>Einf√ºhrung in die Automatentheorie, formale Sprachen und Komplexit√§tstheorie</strong><br>Hopcroft, J. E. und Motwani, R. und Ullman, J. D., Pearson Education Deutschland GmbH, 2003. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7020-4' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7020-4</a>.</li> <li id='id_Kunert2018'>[Kunert2018] <a href='http://amor.cms.hu-berlin.de/\~kunert/papers/lr-analyse/lr.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>LR(k)-Analyse f√ºr Pragmatiker</strong></a><br>Kunert, A., 2018.</li> <li id='id_Wagenknecht2014'>[Wagenknecht2014] <strong>Formale Sprachen, abstrakte Automaten und Compiler</strong><br>Wagenknecht, C. und Hielscher, M., Springer Fachmedien Wiesbaden, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-658-02692-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-658-02692-9</a>. DOI <a href='https://doi.org/10.1007/978-3-658-02692-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-658-02692-9</a>.</li></ul></div>
</div>



    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) Prinzipien der Bottom-Up-Analyse</li> <li>(K1) Items</li> <li>(K1) Closure</li> <li>(K1) Parse Table</li> <li>(K2) LR(0)-Parsing</li> <li>(K3) Konstruktion der Parse Tables</li> <li>(K3) Durchf√ºhren des Parsens</li></ul></div>
</div>



    








<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Syntaxanalyse: LR-Parser (Teil 2)</h1>



    
    




    
    
        
        
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="far fa-file-powerpoint"></i> Annotierte Folien</div>
  <div class="box-content">

<ul> <li><a href='https://raw.githubusercontent.com/Compiler-CampusMinden/AnnotatedSlides/master/lr-parser2.ann.ma.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Annotierte Folien: LR-Parser2</a></li></ul></div>
</div>




    <h1 id="wiederholung">Wiederholung</h1>
<p>Ein PDA f√ºr 
<span class="math align-center">$L=\lbrace ww^{R}\mid w\in \lbrace a,b\rbrace^{\ast}\rbrace$</span>:</p>
<p><a href="#R-image-358048f532d792aab9f84bdec706dcd9" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/pda.png?width=60%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 60%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-358048f532d792aab9f84bdec706dcd9"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/pda.png?width=60%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<h2 id="top-down-analyse">Top-Down-Analyse</h2>
<ul>
<li>LL reicht nicht.</li>
<li>LR: Aufbau des Ableitungsbaums von unten nach oben.</li>
<li>LR(0): Parsen ohne Vorschautoken</li>
<li>Ein DFA mit einem Stack wird √ºber eine Tabelle mit Aktions- und Sprungbefehlen gesteuert.</li>
<li>Im Stack stehen Zust√§nde des DFAs.</li>
<li>Diese Zust√§nde werden mit sog. Dotted Items und deren Closures identifiziert.</li>
</ul>
<h1 id="motivation">Motivation</h1>
<h2 id="auch-lr0-ist-nicht-alles">Auch <em>LR(0)</em> ist nicht alles</h2>
<p>Die Menge der <em>LR(0)</em>-Sprachen ist eine echte Teilmenge der deterministisch kontextfreien Sprachen. Wir brauchen ein Verfahren, mit dem man alle deterministisch kontextfreien Sprachen parsen kann.</p>
<h1 id="bottom-up-analyse-mit-vorschautoken">Bottom-Up-Analyse mit Vorschautoken</h1>
<h2 id="lr-parsen-mit-1-vorschautoken">LR-Parsen mit 1 Vorschautoken</h2>
<p>Ist eine Grammatik nicht LR(0), kann sie vielleicht mit einem Vorschautoken geparst werden. Hier gibt es drei Verfahren:</p>
<ul>
<li>SLR(1)-Parsing</li>
<li>(kanonisches) LR(1)-Parsing</li>
<li>LALR(1)-Parsing</li>
</ul>
<h1 id="slr">SLR</h1>
<h2 id="simple-lr1--slr-parsing">Simple LR(1) = (SLR)-Parsing</h2>
<p>
<span class="math align-center">$A \rightarrow \beta$</span> wird nur reduziert, wenn das Vorschautoken in der 
<span class="math align-center">$FOLLOW$</span>-Menge von 
<span class="math align-center">$A$</span> ist.</p>
<p>
<span class="math align-center">$\Rightarrow$</span> Es √§ndert sich nur die Parse Table:</p>
<p>Bei allen LR(0)-Items in der Tabelle, die einen Punkt am Ende der
rechten Seite stehen haben, trage in der
Aktionstabelle beim zugeh√∂rigen Zustand die Reduktion mittels der zugeh√∂rigen
Regel bei allen Terminals ein, die in der FOLLOW-Menge des Nonterminals auf der linken Seite der Regel enthalten sind.</p>
<h2 id="der-slr-automat-der-grammatik-g1">Der SLR-Automat der Grammatik G1:</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/LR_0-SLR_1-Automat.png" alt="SLR(1)-Automat" width="auto" height="auto">
    <figcaption><p>SLR(1)-Automat</p></figcaption>
</figure>
<h2 id="die-slr-parsertabelle-der-grammatik-g1">Die SLR-Parsertabelle der Grammatik G1</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/SLR_1-Table.png" alt="SLR(1)-Parsertabelle" width="60%" height="auto">
    <figcaption><p>SLR(1)-Parsertabelle</p></figcaption>
</figure>
<h2 id="zum-vergleich-die-lr0-tabelle-von-g1-letzte-vorlesung">Zum Vergleich: Die LR(0)-Tabelle von G1 (letzte Vorlesung)</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/LR_0-Table.png" alt="LR(0)-Parsertabelle" width="60%" height="auto">
    <figcaption><p>LR(0)-Parsertabelle</p></figcaption>
</figure>
<h1 id="kanonische-lr1-syntaxanalyse">Kanonische LR(1)-Syntaxanalyse</h1>
<h2 id="mehr-geht-nicht-kanonische-lr1-syntaxanalyse--lr-analyse">Mehr geht nicht: Kanonische LR(1)-Syntaxanalyse = LR-Analyse</h2>
<p>Beim SLR-Verfahren wird nach 
<span class="math align-center">$A \rightarrow \beta$</span> reduziert, wenn das Vorschautoken in 
<span class="math align-center">$Follow(A)$</span> liegt. Dabei kann es vorkommen, dass das Vorschautoken ein Element davon ist, aber genau bei dieser Regel kann es nicht dem <em>A</em> folgen. Es wird also falsch reduziert, und es entstehen zu viele Eintr√§ge in der Tabelle (Konflikte!).</p>
<p>Jetzt werden nicht Follow-Mengen von Nichtterminalen, sondern LOOKAHEAD-Mengen von Produktionen berechnet.</p>
<h2 id="die-lr1-items">Die LR(1)-Items</h2>
<p>Zu jedem LR(0)-Item (hier auch <em>Kern</em> genannt) wird eine <em>LOOKAHEAD</em> - Menge 
<span class="math align-center">$L$</span> hinzugef√ºgt, die angibt, welche Terminals dem Symbol auf der linken Seite folgen k√∂nnen.</p>
<p>z.  B. 
<span class="math align-center">$[S' \rightarrow \cdot S, \lbrace \bot \rbrace ]$</span></p>
<h2 id="die-h√ºlle-hahahugoshortcode24s12hbhb">Die H√ºlle 
<span class="math align-center">$CLOSURE_1$</span></h2>
<ol>
<li>
<p>f√ºge 
<span class="math align-center">$I$</span> zu 
<span class="math align-center">$CLOSURE_1 (I)$</span> hinzu</p>
</li>
<li>
<p>gibt es ein LR(1) - Item 
<span class="math align-center">$[A \rightarrow \alpha \cdot B \beta,\ L]$</span> aus 
<span class="math align-center">$CLOSURE_1 (I)$</span> und eine Produktion 
<span class="math align-center">$(B \rightarrow \gamma)$</span>, f√ºge 
<span class="math align-center">$[B \rightarrow \cdot \gamma, FIRST(\beta\ L)]$</span> zu 
<span class="math align-center">$CLOSURE_1 (I)$</span> hinzu (
<span class="math align-center">$\alpha, \beta$</span> d√ºrfen 
<span class="math align-center">$\epsilon$</span> sein).</p>
</li>
</ol>
<h2 id="hahahugoshortcode24s22hbhb">
<span class="math align-center">$Goto_1$</span></h2>
<p>
<span class="math align-center">$GOTO_1(I, X) =$</span> eine Produktion</p>

<span class="math align-center">$CLOSURE_1(\lbrace[A \rightarrow \alpha X \cdot \beta, \ L] \mid [A \rightarrow \alpha \cdot X \beta,\ L] \in I\rbrace)$</span>
<p>f√ºr eine Itemmenge 
<span class="math align-center">$I$</span> und 
<span class="math align-center">$X \in N \cup T, A \in N, \alpha, \beta \in (N \cup T)^{\ast}$</span>.</p>
<h2 id="der-lr1-automat">Der LR(1)-Automat</h2>
<p>Der Automat wird analog zum LR(0)-Automaten erstellt mit dem Startzustand</p>

<span class="math align-center">$[S' \rightarrow \cdot S, \lbrace \bot \rbrace ]$</span>
<p>Die Tabelle unterscheidet sich nur bei der Reduktion von der LR(0)-Tabelle:</p>
<p>Reduktionsoperationen werden in den Spalten der
Terminals eingetragen, die in der LOOKAHEAD-Menge der entsprechenden Regel enthalten sind.</p>
<h2 id="die-beispielgrammatik-g2">Die Beispielgrammatik G2</h2>
<p>(0) 
<span class="math align-center">$S^{'} \rightarrow S$</span></p>
<p>(1) 
<span class="math align-center">$S \rightarrow NN$</span></p>
<p>(2) 
<span class="math align-center">$N \rightarrow 0N$</span></p>
<p>(3) 
<span class="math align-center">$N \rightarrow 1$</span></p>
<h2 id="der-lr1-automat-der-grammatik-g2">Der LR(1)-Automat der Grammatik G2</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/LR_1-Automat.png" alt="LR(1)-Automat" width="auto" height="auto">
    <figcaption><p>LR(1)-Automat</p></figcaption>
</figure>
<h2 id="die-lr1-parsertabelle-der-grammatik-g2">Die LR(1)-Parsertabelle der Grammatik G2</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/LR_1-Table.png" alt="LR(1)-Parsertabelle" width="45%" height="auto">
    <figcaption><p>LR(1)-Parsertabelle</p></figcaption>
</figure>
<h1 id="lookahead-lr--lalr">Lookahead-LR = LALR</h1>
<h2 id="lalr1">LALR(1)</h2>
<p>Zusammenfassung aller LR(1)-Zust√§nde, die sich nur in den LOOKAHEAD-Mengen unterscheiden</p>
<p>Parsergeneratoren generieren oft direkt aus einem LR(0)- einen LALR(1)-Zustands-
√úbergangsgraphen durch Hinzuf√ºgen der LOOKAHEAD-Mengen.</p>
<h2 id="der-lalr-automat-der-grammatik-g2">Der LALR-Automat der Grammatik G2</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/LALR-Automat.png" alt="LALR(1)-Automat" width="auto" height="auto">
    <figcaption><p>LALR(1)-Automat</p></figcaption>
</figure>
<h2 id="die-lalr-parsertabelle-der-grammatik-g2">Die LALR-Parsertabelle der Grammatik G2</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/LALR-Table.png" alt="LALR(1)-Parsertabelle" width="60%" height="auto">
    <figcaption><p>LALR(1)-Parsertabelle</p></figcaption>
</figure>
<h1 id="hahahugoshortcode24s36hbhb-vorschautoken">
<span class="math align-center">$k \geq 2$</span> Vorschautoken</h1>
<h2 id="hierarachie">Hierarachie</h2>
<p>Zu jeder LR(k)-Sprache gibt es eine LR(1)-Grammatik.</p>
<h1 id="mehrdeutige-grammatiken">Mehrdeutige Grammatiken</h1>
<h2 id="es-gibt-auch-auswege">Es gibt auch Auswege</h2>
<p>Mehrdeutige Grammatiken sind oft leichter zu lesen und kleiner als die Grammatiken, die man erh√§lt, wenn man die Mehrdeutigkeit aufl√∂st, sofern m√∂glich.
Also die Grammatik mehrdeutig lassen!</p>
<p>Folgendes kann trotzdem helfen:</p>
<ul>
<li>Angabe von Vorrangregeln</li>
<li>Angabe von Assoziativit√§t</li>
<li>Voreinstellung des Parsergenearators: z. B. Shiften bei Shift-Reduce-Konflikten</li>
<li>Voreinstellung des Parsergenearators: z. B. Reduzieren nach der Regel, die in der Grammatik zuerst kommt bei Reduce-Reduce-Konflikten</li>
</ul>
<h1 id="hierarchie-der-kontextfreien-sprachen">Hierarchie der kontextfreien Sprachen</h1>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/CFG-Hierarchy.png" alt="Sprachenhierarchie" width="80%" height="auto">
    <figcaption><p>Sprachenhierarchie</p></figcaption>
</figure>
<h1 id="wrap-up">Wrap-Up</h1>
<h2 id="wrap-up-1">Wrap-Up</h2>
<ul>
<li>
<p>mit Bottom-Up-Parsing LR(1) kann man alle deterministisch kontextfreien Sprachen parsen</p>
</li>
<li>
<p>ein Vorschautoken gen√ºgt</p>
</li>
<li>
<p>LR(0)-, SLR- und LALR- Parsing sind vereinfachte Verfahren f√ºr Teilmengen der LR-Sprachen</p>
</li>
</ul>


    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Kapitel 4.5 bis 4.8</em></li> <li id='id_aho2013compilers'>[aho2013compilers] <strong>Compilers: Pearson New International Edition: Principles, Techniques, and Tools</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Education Limited, 2013. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-2920-3723-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-2920-3723-3</a>.</li> <li id='id_hopcroft2003'>[hopcroft2003] <strong>Einf√ºhrung in die Automatentheorie, formale Sprachen und Komplexit√§tstheorie</strong><br>Hopcroft, J. E. und Motwani, R. und Ullman, J. D., Pearson Education Deutschland GmbH, 2003. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7020-4' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7020-4</a>.</li> <li id='id_Kunert2018'>[Kunert2018] <a href='http://amor.cms.hu-berlin.de/\~kunert/papers/lr-analyse/lr.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>LR(k)-Analyse f√ºr Pragmatiker</strong></a><br>Kunert, A., 2018.</li> <li id='id_Wagenknecht2014'>[Wagenknecht2014] <strong>Formale Sprachen, abstrakte Automaten und Compiler</strong><br>Wagenknecht, C. und Hielscher, M., Springer Fachmedien Wiesbaden, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-658-02692-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-658-02692-9</a>. DOI <a href='https://doi.org/10.1007/978-3-658-02692-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-658-02692-9</a>.</li></ul></div>
</div>



    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) Prinzipien der Bottom-Up-Analyse</li> <li>(K1) Items</li> <li>(K1) Closure</li> <li>(K1) Parse Table</li> <li>(K2) LR(0)-Parsing</li> <li>(K2) SLR-Parsing</li> <li>(K2) LR(1)-Parsing</li> <li>(K2) LALR-Parsing</li> <li>(K3) Konstruktion der Parse Tables</li> <li>(K3) Durchf√ºhren des Parsens</li></ul></div>
</div>



    








<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Error-Recovery</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>Umgang mit Fehlern ist im Compiler sehr wichtig: Falscher Code darf nicht in ein ausf√ºhrbares Programm
umgewandelt werden oder ausgef√ºhrt werden, gleichzeitig erwarten Nutzer zielf√ºhrende Fehlermeldungen
und auch das Erkennen von m√∂glichst mehreren Fehlern in einem Lauf.</p>
<p>Auf der Ebene des Parsers kann man Fehler in Bezug auf die Grammatik erkennen. Typische Strategien sind
das Entfernen von Token aus dem Eingabestrom, bis wieder ein Token erscheint, welches die weitere Abarbeitung
der aktuellen Regel erlaubt (&quot;Synchronisierung&quot;). Dies sind oft Zeilenenden, ein Semikolon oder eine schlie√üende
geschweifte Klammer. Dieses recht einfache, aber grobe Vorgehen kann verfeinert werden, indem man versucht,
√ºbersch√ºssige Token zu entfernen oder fehlender Token zu ersetzen. In ANTLR wird beispielsweise maximal ein
fehlendes Token virtuell &quot;ersetzt&quot; bzw. max. ein √ºbersch√ºssiges Token entfernt, damit man den restlichen Code
weiter parsen kann. Wenn mehr als ein Token fehlt oder zu viel ist, geht ANTLR in einen &quot;Panic Mode&quot; und
entfernt so lange Token aus dem Eingabestrom, bis das aktuelle Token in einem <em>Resynchronization Set</em> enthalten
ist. Die Bildung dieser Menge erinnert an die Regeln zum Bilden der <em>FOLLOW</em>-Mengen, ist aber an den Kontext
der &quot;aufgerufenen&quot; Parser-Regeln gebunden. Zus√§tzlich gibt es weitere Strategien zum Behandeln von Fehlern in
Schleifen sowie zur Vermeidung von Endlos-Fehlerbehebungsschleifen (&quot;Fail-Save&quot;). In Bison wird dagegen mit
einem speziellen <em>error</em>-Token gearbeitet und man f√ºgt an &quot;strategischen&quot; Stellen Regeln der Form Regel 
<span class="math align-center">$A \to \operatorname{error} \alpha$</span> hinzu. Dabei ist 
<span class="math align-center">$\alpha$</span> ein Token, welches zur Synchronisierung genutzt werden
soll. Im Fehlerfall werden so lange Token vom Stack entfernt, bis man eine Regel 
<span class="math align-center">$A \to \operatorname{error} \alpha$</span> anwenden kann und das <em>error</em>-Token shiften kann. Danach werden ggf. so lange Token aus dem Eingabestrom
entfernt, bis das Token 
<span class="math align-center">$\alpha$</span> auftaucht und man die Regel mit einem <em>reduce</em> abschlie√üen kann. Diese Form
der Behandlung stellt einen Kompromiss zwischen Aufwand (auch Zeit) und Nutzen dar.</p>
<p>Zus√§tzlich kann man in der Grammatik bereits typische Fehler (vergessene Klammern oder Typos wie Dreher bei
Schl√ºsselw√∂rtern) schon √ºber &quot;Fehlerproduktionen&quot; vorwegnehmen. Das bedeutet, dass man eine Regel formuliert,
die diesen typischen Tippfehler akzeptiert (und korrigiert), aber zus√§tzlich eine Warnung generiert. Es muss
dann aber jeweils entschieden werden, ob der entsprechende Quellcode in ein ausf√ºhrbares Programm √ºbersetzt
werden darf.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/9sFdI7pYMQs' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Error-Recovery</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/eabf5e829fbcd6be866e20b169989c8fef4fd10f13704999d0c1b531d15d4255975cd4490ac127156874d8334d6cade0ece8e2d15f2f2d34cb965a0c1697eade' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Error-Recovery</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K2) Varianten der Fehler bei Parsern</li> <li>(K2) Fehlerbehandlung bei LL-Parsern: <em>single token deletion</em>, <em>single token insertion</em>, <em>sync-and-return</em></li> <li>(K2) Berechnung und Anwendung des <em>Resynchronization Sets</em></li> <li>(K3) √Ñndern der Fehlermeldungen bei ANTLR</li> <li>(K3) Eigene Errorhandler in ANTLR-Parser bauen und einbinden</li> <li>(K3) Nutzen von speziellen Fehler-Alternativen in Grammatiken</li></ul></div>
</div>




    <h2 id="fehler-beim-parsen">Fehler beim Parsen</h2>
<p><a href="#R-image-90d978e2402caae0e611096874d121bb" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/bc_xml-parsing-error.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-90d978e2402caae0e611096874d121bb"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/bc_xml-parsing-error.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p><span class='origin'>Quelle: Vorlesung &quot;Einf√ºhrung in die Programmierung mit Skriptsprachen&quot; by <a href="mailto:bc.george@hsbi.de">BC George</a> (<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC BY-SA 4.0</a>)</span></p>
<ul>
<li>Compiler ist ein schnelles Mittel zum Finden von (syntaktischen) Fehlern</li>
<li>Wichtige Eigenschaften:
<ul>
<li>Reproduzierbare Ergebnisse</li>
<li>Aussagekr√§ftige Fehlermeldungen</li>
<li>Nach Erkennen eines Fehlers: (vorl√§ufige) Korrektur und Parsen des restlichen Codes
=&gt; weitere Fehler anzeigen.
Problem: Bis wohin &quot;gobbeln&quot;, d.h. was als Synchronisationspunkt nehmen? Semikolon?</li>
<li>Syntaktisch fehlerhafte Programme d√ºrfen nicht in die Zielsprache √ºbersetzt werden!</li>
</ul>
</li>
</ul>
<h2 id="typische-fehler-beim-parsing">Typische Fehler beim Parsing</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span><span style="color:#66d9ef">grammar</span> <span style="color:#a6e22e">VarDef</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>alt   : stmt <span style="color:#f92672">|</span> stmt2 ;
</span></span><span style="display:flex;"><span>stmt  : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span> ;
</span></span><span style="display:flex;"><span>stmt2 : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span>  ;</span></span></code></pre></div><p><em>Anmerkung</em>: Die nachfolgenden Fehler werden am Beispiel der Grammatik
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery.html/src/VarDef.g4">VarDef.g4</a> und ANTLR demonstriert.</p>
<h3 id="lexikalische-fehler">Lexikalische Fehler</h3>
<p>Eingabe: <code>int x1;</code> (Startregel <code>stmt</code>)</p>
<p>Fehlermeldung: <code>token recognition error at: '1'</code></p>
<p>Die ist ein Fehler aus dem Lexer, wenn beim Erkennen eines Tokens ein komplett
unbekanntes Zeichen auftritt.</p>
<h3 id="ein-extra-token">Ein extra Token</h3>
<p>Eingabe: <code>int x y;</code> (Startregel <code>stmt</code>)</p>
<p>Fehlermeldung: <code>extraneous input 'y' expecting ';'</code></p>
<p>Wenn nur ein Token zu viel ist, dann kann der von ANTLR generierte Parser eine
passende Fehlermeldung ausgeben.</p>
<h3 id="mehrere-extra-token">Mehrere extra Token</h3>
<p>Eingabe: <code>int x y z;</code> (Startregel <code>stmt</code>)</p>
<p>Fehlermeldung: <code>mismatched input 'y' expecting ';'</code></p>
<p>Wenn dagegen mehr als ein Token zu viel ist, dann gibt der von ANTLR generierte
Parser eine generische Fehlermeldung aus.</p>
<h3 id="fehlendes-token">Fehlendes Token</h3>
<p>Eingabe: <code>int ;</code> (Startregel <code>stmt</code>)</p>
<p>Fehlermeldung: <code>missing ID at ';'</code></p>
<p>Ein anderer typischer Fehler sind fehlende Token, die kann der Parser analog zu
√ºberz√§hligen Token erkennen und ausgeben.</p>
<h3 id="fehlendes-token-am-entscheidungspunkt">Fehlendes Token am Entscheidungspunkt</h3>
<p>Eingabe: <code>int ;</code> (Startregel <code>alt</code>)</p>
<p>Fehlermeldung: <code>no viable alternative at input 'int;'</code></p>
<p>Hier fehlt ein Token, aber an einer Stelle, wo sich der Parser zwischen zwei
Alternativen (Sub-Regeln) entscheiden muss.</p>
<h2 id="√ºberblick-recovery-bei-parser-fehlern">√úberblick Recovery bei Parser-Fehlern</h2>
<p><a href="#R-image-c7112418d2031833991c09dd1b1fca67" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/recovery.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c7112418d2031833991c09dd1b1fca67"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/recovery.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<ul>
<li>Fehler im Lexer (hier nicht weiter betrachtet):
<ul>
<li>Aktuelles Zeichen passt zu keinem Token: Entfernen oder Hinzuf√ºgen
von Zeichen (plus R√ºckmeldung an den Parser)</li>
<li>Spezielle Token, die typische fehlerhafte Zeichenketten als Token
erkennen (mit Weiterverarbeitung im Parser)</li>
</ul>
</li>
<li>Fehler im Parser:
<ul>
<li>Token passt nicht: Token entfernen oder ein Dummy-Token erzeugen</li>
<li>Panic-Mode: Entferne Token bis zu einem Synchronisationspunkt.
Problem: Dabei nicht zu weit zu springen!</li>
<li>Spezielle Fehlerproduktionen: Spezielle Regeln in der Grammatik,
die typische Fehler matchen.</li>
</ul>
</li>
</ul>
<p>Anmerkung LR-Parser: Ein Syntaxfehler wird entdeckt, wenn die Action-Tabelle
f√ºr Top-of-Stack und akt. Token leer ist =&gt; Stack und/oder Token modifizieren,
aber deutlich schwieriger als bei LL ...</p>
<h2 id="skizze-generierte-parser-regeln-antlr">Skizze: Generierte Parser-Regeln (ANTLR)</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt  : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span> ;</span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">stmt</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>: <span style="color:#66d9ef">match</span>(<span style="color:#e6db74">&#34;int&#34;</span>); <span style="color:#66d9ef">match</span>(ID); <span style="color:#66d9ef">match</span>(<span style="color:#e6db74">&#34;;&#34;</span>)
</span></span><span style="display:flex;"><span>    catch (RecognitionException re):
</span></span><span style="display:flex;"><span>        _errHandler<span style="color:#f92672">.</span>reportError(self)               <span style="color:#75715e"># let&#39;s report it</span>
</span></span><span style="display:flex;"><span>        _errHandler<span style="color:#f92672">.</span>recover(self)                   <span style="color:#75715e"># Panic-Mode</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">match</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> lookahead <span style="color:#f92672">==</span> x: consume()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: _errHandler<span style="color:#f92672">.</span>recoverInline(self)           <span style="color:#75715e"># Inline-Mode</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Der im Parser registrierte ErrorHandler erzeugt in der Methode
<code>reportError()</code> eine geeignete Meldung und gibt sie an den Parser
√ºber dessen Methode <code>notifyErrorListeners()</code> weiter.</p>
<p>Die eigentliche Fehlerbehandlung findet in der Methode <code>recover()</code>
bzw. <code>recoverInline()</code> des ErrorHandlers statt.</p>
<h2 id="inline-recovery-bei-token-mismatch-skizze">Inline-Recovery bei Token-Mismatch (Skizze)</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">recoverInline</span>(parser):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># SINGLE TOKEN DELETION</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> singleTokenDeletion(parser):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> getMatchedSymbol(parser)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># SINGLE TOKEN INSERTION</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> singleTokenInsertion(parser):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> getMissingSymbol(parser)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># that didn&#39;t work, throw a new exception</span>
</span></span><span style="display:flex;"><span>    throw new InputMismatchException(parser)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Die Klasse <code>InputMismatchException</code> dr√ºckt aus, dass das aktuelle Token nicht
zur Erwartung des Parsers passt. Deshalb wird diese Exception am Ende von
<code>recoverInline()</code> geworfen. Die Klasse <code>RecognitionException</code>, die in den
Parserregeln wie <code>stmt</code> gefangen wird, ist die gemeinsame Oberklasse aller
Parser-Exceptions.</p>
<p>Liste der wichtigsten Exceptions (nach
<a href="https://github.com/antlr/antlr4/blob/master/doc/parser-rules.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/parser-rules.md</a>):</p>
<table>
<thead>
<tr>
<th style="text-align:left">Exception</th>
<th style="text-align:left">Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>RecognitionException</code></td>
<td style="text-align:left">Basisklasse f√ºr alle Parser-Exceptions</td>
</tr>
<tr>
<td style="text-align:left"><code>NoViableAltException</code></td>
<td style="text-align:left">Parser konnte sich nicht f√ºr (mind.) einen Pfad entscheiden angesichts des Tokenstroms</td>
</tr>
<tr>
<td style="text-align:left"><code>LexerNoViableAltException</code></td>
<td style="text-align:left">Lexer-Pendant zu <code>NoViableAltException</code></td>
</tr>
<tr>
<td style="text-align:left"><code>InputMismatchException</code></td>
<td style="text-align:left">Das aktuelle Token ist nicht das, was der Parser erwartet</td>
</tr>
</tbody>
</table>
<h2 id="panic-mode-sync-and-return-skizze">Panic Mode: Sync-and-Return (Skizze)</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rule</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>: <span style="color:#f92672">...</span> rule<span style="color:#f92672">-</span>body <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    catch (RecognitionException re):
</span></span><span style="display:flex;"><span>        _errHandler<span style="color:#f92672">.</span>reportError(self)       <span style="color:#75715e"># let&#39;s report it</span>
</span></span><span style="display:flex;"><span>        _errHandler<span style="color:#f92672">.</span>recover(self)           <span style="color:#75715e"># Panic-Mode</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>=&gt; Entferne solange Token, bis aktuelles Token im &quot;<em>Resynchronization Set</em>&quot;</p>
<h2 id="antlr-einsatz-des-resynchronization-set">ANTLR: Einsatz des &quot;<em>Resynchronization Set</em>&quot;</h2>
<ul>
<li><strong>Following Set</strong>: Menge der Token, die direkt auf eine Regel-Referenz folgen,
ohne dass die aktuelle Regel/Alternative verlassen wird</li>
<li><strong>Resynchronization Set</strong>: Vereinigung der <em>Following Sets</em> f√ºr alle Regeln im
aktuellen Aufruf-Stack</li>
</ul>
<p><span class='origin'>Quelle: nach <a href="#id_Parr2014">[Parr2014, pp. 161-163]</a></span></p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt : <span style="color:#e6db74">&#39;if&#39;</span> expr <span style="color:#e6db74">&#39;:&#39;</span> stmt           <span style="color:#75715e">// Following Set f√ºr &#34;expr&#34;: {&#39;:&#39;}</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;while&#39;</span> <span style="color:#e6db74">&#39;(&#39;</span> expr <span style="color:#e6db74">&#39;)&#39;</span> stmt ;  <span style="color:#75715e">// Following Set f√ºr &#34;expr&#34;: {&#39;)&#39;}</span>
</span></span><span style="display:flex;"><span>expr : term <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#66d9ef">INT</span> ;               <span style="color:#75715e">// Following Set f√ºr &#34;term&#34;: {&#39;+&#39;}</span></span></span></code></pre></div><ul>
<li>Eingabe: <code>if :</code></li>
<li>Aufruf-Stack nach Bearbeitung von <code>if</code>: <code>[stmt, expr, term]</code></li>
<li><strong>Resynchronization Set</strong>: <code>{'+', ':'}</code></li>
</ul>
<h3 id="hinweis-follow-hahahugoshortcode25s0hbhb-following">Hinweis: <em>FOLLOW</em> 
<span class="math align-center">$\ne$</span> <em>Following</em></h3>
<p><strong>FOLLOW</strong> ist die Menge aller Token, die auf eine Regel folgen k√∂nnen</p>
<ul>
<li><code>FOLLOW(term) = {'+'}</code></li>
<li><code>FOLLOW(expr) = {':', ')'}</code></li>
</ul>
<p><strong>Following</strong> ist dagegen <strong>abh√§ngig vom aktuellen Kontext</strong>!</p>
<ul>
<li>Stack: <code>[stmt, expr, term]</code> =&gt; <em>Resynchronization Set</em>: <code>{'+', ':'}</code></li>
</ul>
<h3 id="beispiele-resynchronisation-im-panic-mode-antlr">Beispiele Resynchronisation im Panic Mode (ANTLR)</h3>
<p><strong>Hinweis</strong>: Die Regel <code>term</code> ist in obigem Beispiel nicht weiter detailliert. Hier wird
angenommen, dass das aktuelle Token <code>':'</code> nicht passt.</p>
<ul>
<li>Eingabe: <code>if :</code>
<ul>
<li>In Regel <code>term</code>: Token <code>':'</code> passt nicht
<ul>
<li><code>consume()</code>, bis aktuelles Token in <em>Resynchronization Set</em>: <code>{'+', ':'}</code>
(d.h. hier bleibt <code>':'</code> das aktuelle Token)</li>
<li>R√ºckkehr zu Regel <code>expr</code></li>
</ul>
</li>
<li>In Regel <code>expr</code>: Token <code>':'</code> passt nicht
<ul>
<li><code>consume()</code>, bis aktuelles Token in <em>Resynchronization Set</em>: <code>{':'}</code>
(d.h. hier bleibt <code>':'</code> das aktuelle Token)</li>
<li>R√ºckkehr zu Regel <code>stmt</code></li>
</ul>
</li>
<li>In Regel <code>stmt</code>: Token <code>':'</code> passt jetzt
<ul>
<li>Abschluss des Parsing (mit Fehlermeldung)</li>
</ul>
</li>
</ul>
</li>
<li>Eingabe: <code>if x + 42 ))):</code>
<ul>
<li>In Regel <code>stmt</code>: Token <code>')'</code> passt nicht
<ul>
<li><code>consume()</code>, bis aktuelles Token in <em>Resynchronization Set</em>: <code>{':'}</code> (d.h.
hier werden alle <code>')'</code> entfernt)</li>
</ul>
</li>
<li>In Regel <code>stmt</code>: Token <code>':'</code> passt jetzt
<ul>
<li>Abschluss des Parsing (mit Fehlermeldung)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="antlr-anmerkungen-fehlerbehandlung-in-sub-regeln">ANTLR: Anmerkungen Fehlerbehandlung in Sub-Regeln</h2>
<p>Bei Sub-Regeln (d.h. eine Regel enth√§lt Alternativen) oder Schleifenkonstrukten
(d.h. eine Regel enth√§lt <code>(...)*</code> oder <code>(...)+</code>) geht ANTLR etwas anders vor.</p>
<ol>
<li>
<p>Start einer Sub-Regel/Alternative: Versuch einer <em>single token deletion</em></p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># am Anfang einer Alternative oder Schleife</span>
</span></span><span style="display:flex;"><span>_errHandler<span style="color:#f92672">.</span>sync(self)</span></span></code></pre></div></li>
<li>
<p>Schleifenkonstrukte: <code>(...)*</code> oder <code>(...)+</code></p>
<p>Versuche, in der Schleife zu bleiben! Im Fehlerfall <code>consume()</code> bis</p>
<ul>
<li>Weitere Iteration der Schleife erkannt</li>
<li>Token, welches der Schleife folgt, erkannt</li>
<li>Token im <em>Resynchronization Set</em> des aktuellen Aufruf-Stacks</li>
</ul>
<p>Anmerkung: Im Prinzip entspricht dies dem <em>Panic Mode</em>, der Unterschied liegt
darin, bis wohin der Parser nach der Recovery in einer Funktion/Methode (Regel)
zur√ºckspringt. D.h. wenn es verschiedene M√∂glichkeiten gibt, haben diese die
obige Priorisierung.</p>
</li>
<li>
<p>Fail-Save</p>
<p>Um Endlos-Schleifen durch die Schritte (1) bzw. (2) zu vermeiden, l√∂st der Parser
beim zweiten Versuch, die selbe Parser-Stelle und Input-Position zu bearbeiten
(also bei bereits aktivem Fehler), einen &quot;<em>Fail-Safe</em>&quot; aus. Der Parser konsumiert
dann ein Token und f√§hrt dann mit der Recovery fort.</p>
</li>
</ol>
<p>Zu Details zur Fehlerbehandlung durch ANTLR vergleiche <a href="#id_Parr2014">[Parr2014, S. 170 ff.]</a>.</p>
<h2 id="antlr-√§ndern-der-fehlerbehandlungs-strategie">ANTLR: √Ñndern der Fehlerbehandlungs-Strategie</h2>
<h3 id="√§ndern-der-fehlerbehandlungs-strategie-global">√Ñndern der Fehlerbehandlungs-Strategie (global)</h3>
<p><a href="#R-image-97eb931b5339c2b19b91d5ed721a6537" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/handler.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-97eb931b5339c2b19b91d5ed721a6537"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/handler.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Sie √ºberschreiben die Klasse <code>DefaultErrorStrategy</code> und m√ºssen die oben gezeigten Methoden
<code>recover()</code> und <code>recoverInline()</code>aufrufen. Die eigene Fehlerbehandlung setzen Sie √ºber die
Methode <code>setErrorHandler</code> des Parsers.</p>
<h3 id="√§ndern-der-fehlerbehandlungs-strategie-lokal">√Ñndern der Fehlerbehandlungs-Strategie (lokal)</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>r : <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>  ;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">catch</span>[RecognitionException e] { throw e; }</span></span></code></pre></div><p>Es lassen sich auch andere bzw. mehrere Exceptions fangen. Der <code>catch</code>-Block ersetzt den
Default-<code>catch</code>-Block der generierten Methode. Das bedeutet, dass sich der ge√§nderte Modus
nur f√ºr die eine Regel auswirkt.</p>
<h3 id="√§ndern-der-fehler-meldungen">√Ñndern der Fehler-Meldungen</h3>
<p><a href="#R-image-56aaad48c95fea35d49326363d96d71f" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/listener.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-56aaad48c95fea35d49326363d96d71f"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/listener.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>F√ºr einen eigenen Listener leitet man sinnvollerweise von <code>BaseErrorListener</code> ab und
√ºberschreibt die leere Implementierung von <code>syntaxError()</code>.</p>
<p>Damit die Fehlermeldungen nicht mehrfach ausgegeben werden, entfernt man zun√§chst alle
Listener und f√ºgt dann den eigenen hinzu, bevor man den Parser startet.</p>
<h2 id="panic-mode-in-bison-error-recovery">Panic Mode in Bison (Error Recovery)</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span>     { printf(&#34;%s\n&#34;, <span style="color:#960050;background-color:#1e0010">$</span>2); }
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> error <span style="color:#e6db74">&#39;\n&#39;</span>       { yyerror(); yyerrok; }
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p>Bison kennt ein spezielles Fehler-Token <code>error</code>. Dieses Token wird genutzt, um
einen Synchronisationspunkt in der Grammatik zu definieren, von dem aus man
<em>h√∂chstwahrscheinlich</em> weiter parsen kann.</p>
<h3 id="parsen-mit-error-token">Parsen mit <em>error</em>-Token</h3>
<p>Der Parser wird mit diesen Produktionen generiert wie mit normalen Token auch.
Im Fehlerfall werden so lange Symbole vom Stack entfernt, bis eine Regel der
Form 
<span class="math align-center">$A \to \operatorname{error} \alpha$</span> anwendbar ist. Dann wird das Token
<code>error</code> auf den Stack geschoben und so lange Eingabe-Token gelesen und verworfen,
bis eines gefunden wird, welches auf das <code>error</code>-Token folgen kann. Dies nennt
Bison &quot;Resynchronisation&quot;. Anschlie√üend wird im Recovery-Modus normal fortgefahren,
bis drei weitere Token auf den Stack geschoben wurden und damit der Recovery-Modus
verlassen wird. Falls bereits vorher weitere Fehler auftreten, werden diese nicht
separat gemeldet.</p>
<h3 id="anwendung-im-obigen-beispiel">Anwendung im obigen Beispiel</h3>
<p>Im obigen Beispiel ist die Regel <code>stmt : error '\n'</code> enthalten. Im Fehlerfall
werden die Symbole vom Stack entfernt, bis ein Zustand erreicht ist, der eine
Shift-Aktion auf das Token <code>error</code> hat. Das Error-Token wird auf den Stack
geschoben und alle Eingabetoken bis zum n√§chsten <code>'\n'</code> gelesen und direkt
entfernt. Mit dem Erreichen des Zeilenumbruchs wird die zugeordnete Aktion
ausgef√ºhrt. Diese gibt den Fehler auf der Konsole aus und f√ºhrt mit dem Makro
<code>yyerrok</code> einen Reset des Parsers aus (d.h. er verl√§sst den Recovery-Modus
<strong>vor</strong> dem Shiften der per Default drei g√ºltigen Token). Anschlie√üend ist der
Bison-Parser wieder im normalen Modus. Die fehlerhaften Symbole/Token wurden
aus dem Eingabestrom entfernt.</p>
<h3 id="wo-kommen-die-error-token-am-besten-hin">Wo kommen die <em>error</em>-Token am besten hin?</h3>
<p>Die &quot;schwarze Kunst&quot; ist, die Error-Token an geeigneten Stellen unterzubringen,
d.h. vorherzusehen, wo der Parser am sinnvollsten wieder aufsetzen kann. H√§ufig
sind dies beispielsweise das ein Statement beendende Semikolon oder die einen
Block beendende schlie√üende geschweifte Klammer. Beispielsweise k√∂nnte man f√ºr
die Sprache C bei der Definition von Statements mehrere Synchronisationspunkte
einbauen:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt : <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> error <span style="color:#e6db74">&#39;;&#39;</span>    <span style="color:#75715e">/* Synchronisation f√ºr &#39;return&#39; */</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> error <span style="color:#e6db74">&#39;}&#39;</span>    <span style="color:#75715e">/* Synchronisation nach Block */</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> error <span style="color:#e6db74">&#39;\n&#39;</span>   <span style="color:#75715e">/* Synchronisation nach Zeilenumbruch */</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><h3 id="bison-und-c-und-speichermanagement-im-fehlerfall">Bison und C und Speichermanagement im Fehlerfall</h3>
<p>Wenn Bison im Recovery-Modus ist, werden Symbole und ihre Werte vom Stack entfernt.
Falls diese Werte (vgl. <code>%union</code>) Pointer mit dynamisch alloziertem Speicher sind,
muss Bison diesen Speicher freigeben.</p>
<p>Dazu kann man sich √ºber die Direktive <code>%destructor { code } symbols</code> oder
<code>%destructor { code } &lt;types&gt;</code> Code definieren, der dann f√ºr die jeweiligen Symbole
oder Typen ausgef√ºhrt wird.</p>
<p>Die Typangabe <code>&lt;*&gt;</code> dient dabei als Catch-All f√ºr Symbole, f√ºr die ein Typ definiert
wurde, aber kein Destruktor.</p>
<p>Beispiel:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">%</span>union {
</span></span><span style="display:flex;"><span>    char* str;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">%token</span> <span style="color:#960050;background-color:#1e0010">&lt;str&gt;</span> <span style="color:#960050;background-color:#1e0010">ID</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">%destructor</span> { free(<span style="color:#960050;background-color:#1e0010">$$</span>); } <span style="color:#960050;background-color:#1e0010">&lt;str&gt;</span></span></span></code></pre></div><p>F√ºr weitere Details vergleiche <a href="#id_Levine2009">[Levine2009, Kap. 8]</a>.</p>
<h2 id="fehlerproduktionen">Fehlerproduktionen</h2>
<p>H√§ufig vorkommende Fehler kann man bereits in der Grammatik ber√ºcksichtigen.
Dadurch kommt es nicht zu einem Parser-Error mit Recovery-Mechanismus, sondern
der Fehler wird √ºber eine entsprechende Alternative in der Grammatik korrigiert.</p>
<p>Es bietet sich an, in diesem Fall eine entsprechende Ausgabe zu t√§tigen. Dies
wird in der folgenden Grammatik √ºber eingebettete Aktionen erledigt.</p>
<h3 id="antlr">ANTLR</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span>
</span></span><span style="display:flex;"><span>     : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span>             {notifyErrorListeners(&#34;Missing &#39;;&#39;&#34;);}
</span></span><span style="display:flex;"><span>     : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span> <span style="color:#e6db74">&#39;;&#39;</span>     {notifyErrorListeners(&#34;Too many &#39;;&#39;&#34;);}
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p>Der aus der Grammatik generierte Parser leitet von der Basisklasse <code>Parser</code>
ab. Dort wird eine Methode <code>notifyErrorListeners()</code> implementiert, die man
mit Hilfe von in die Grammatik eingebetteten Aktionen aufrufen kann (Vorgriff
auf <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/syntaxdriven.html">Syntaxgesteuerte Interpreter</a>).
Letztlich steht im generierten Parser in der generierten Methode <code>stmt()</code> an
der passenden Stelle ein Aufruf <code>notifyErrorListeners(Too many ';'&quot;);</code> ...</p>
<h3 id="flex-und-bison">Flex und Bison</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span>     { <span style="color:#960050;background-color:#1e0010">$$</span> = <span style="color:#960050;background-color:#1e0010">$</span>2; }
</span></span><span style="display:flex;"><span>     : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span>         { yyerror(&#34;unterminated id&#34;);
</span></span><span style="display:flex;"><span>                          <span style="color:#960050;background-color:#1e0010">$$</span> = <span style="color:#960050;background-color:#1e0010">$</span>2; }
</span></span><span style="display:flex;"><span>     ;
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">%%</span>
</span></span><span style="display:flex;"><span>void <span style="color:#960050;background-color:#1e0010">yyerror(char</span> <span style="color:#960050;background-color:#1e0010">*s,</span> <span style="color:#960050;background-color:#1e0010">...)</span> {
</span></span><span style="display:flex;"><span>    va_list ap; va_start(ap, s);
</span></span><span style="display:flex;"><span>    fprintf(stderr, &#34;%d: error: &#34;, yylineno);
</span></span><span style="display:flex;"><span>    vfprintf(stderr, s, ap); fprintf(stderr, &#34;\n&#34;);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Analog zu ANTLR ist es auch in Flex/Bison √ºblich, f√ºr typische Szenarien
&quot;nicht ganz korrekte&quot; Eingaben zu akzeptieren. Dazu definiert man zus√§tzliche
Lexer- oder Parser-Regeln, die diese Eingaben als das, was gemeint war akzeptieren
und eine zus√§tzliche Warnung ausgeben.</p>
<p>Dabei definiert man sich typischerweise die Funktion <code>yyerror()</code>. √úber
<code>yytext</code> hat man Zugriff auf den Eingabetext des aktuellen Tokens, und
mit <code>yylineno</code> hat man Zugriff auf die aktuelle Eingabezeile (<code>yylineno</code>
wird automatisch bei jedem <code>\n</code> inkrementiert). Wenn man weitere Informationen
ben√∂tigt, muss man mit dem Bison-Feature &quot;Locations&quot; arbeiten. Dies ist ein
spezieller Datentyp <code>YYLTYPE</code>.</p>
<p>F√ºr weitere Details vergleiche <a href="#id_Levine2009">[Levine2009, Kap. 8]</a>.</p>
<h2 id="anmerkung-nicht-eindeutige-grammatiken">Anmerkung: Nicht eindeutige Grammatiken</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stat: expr <span style="color:#e6db74">&#39;;&#39;</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span> ;
</span></span><span style="display:flex;"><span>expr: <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">INT</span> ;</span></span></code></pre></div><p>=&gt; Was passiert bei der Eingabe: <code>a+b</code> ??! Welche Regel/Alternative soll
jetzt matchen, d.h. welcher AST soll am Ende erzeugt werden?!</p>
<h3 id="antlr-1">ANTLR</h3>
<p>Nicht eindeutige Grammatiken f√ºhren <strong>nicht</strong> zu einer Fehlermeldung,
da nicht der Nutzer mit seiner Eingabe Schuld ist, sondern das Problem
in der Grammatik selbst steckt.</p>
<p>W√§hrend des Debuggings von Grammatiken lohnt es sich aber, diese
Warnungen zu aktivieren. Dies kann entweder mit der Option &quot;<code>-diagnostics</code>&quot;
beim Aufruf des <code>grun</code>-Tools geschehen oder √ºber das Setzen des
<code>DiagnosticErrorListener</code> aus der ANTLR-Runtime als ErrorListener.</p>
<h3 id="bison">Bison</h3>
<p>Bison meldet nicht eindeutige Grammatiken beim Erzeugen des Parsers
(vgl. Shift/Reduce- und Reduce/Reduce-Konflikte) und entscheidet sich
jeweils f√ºr eine Operation (wobei Shift bevorzugt wird). Dies kann
man im √ºber die Option <code>-v</code> erzeugten <code>&lt;name&gt;.output</code>-File √ºberpr√ºfen.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Fehler bei <code>match()</code>: <em>single token deletion</em> oder <em>single token insertion</em></p>
</li>
<li>
<p>Panic Mode: <em>sync-and-return</em> bis Token in <em>Resynchronization Set</em> (ANTLR)
oder <code>error</code>-Token shiftbar (Bison)</p>
<ul>
<li>ANTLR: Sonderbehandlung bei Start von Sub-Regeln und in Schleifen</li>
<li>ANTLR: Fail-Save zur Vermeidung von Endlosschleifen</li>
</ul>
</li>
<li>
<p>Fehler-Alternativen in Grammatik einbauen</p>
</li>
</ul>


    



    



    

    
<div class="box notices cstyle note">
  <div class="box-label"><i class="fas fa-puzzle-piece"></i> Challenges</div>
  <div class="box-content">

<ul>
<li>Erkl√§ren Sie, welche Fehler typischerweise beim Parsen auftreten k√∂nnen.</li>
<li>Wie reagiert der von ANTLR generierte LL-Parser auf typische Fehler?</li>
<li>Was sind &quot;Fehlerproduktionen&quot;, wozu sind sie gut?</li>
</ul>
</div>
</div>



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Levine2009'>[Levine2009] <strong>flex & bison</strong><br>Levine, J., O'Reilly, 2009. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-5961-5597-1' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-5961-5597-1</a>.<br><em>Kapitel 7 und 8</em></li> <li id='id_Parr2010'>[Parr2010] <strong>Language Implementation Patterns</strong><br>Parr, T., Pragmatic Bookshelf, 2010. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5645-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5645-6</a>.<br><em>Kapitel 2 und 3</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

          </section>
          <article class="default">
            <header class="headline">
            </header>
<h1 id="semantische-analyse">Semantische Analyse</h1>

<p>Auf die lexikalische Analyse und die Syntaxanalyse folgt die semantische Analyse. Nach dem
Parsen steht fest, dass ein Programm syntaktisch korrekt ist. Nun muss gepr√ºft werden, ob
es auch semantisch korrekt ist.</p>

<ul class="children children-li children-sort-">
	
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables.html">Symboltabellen</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/attribgrammars.html">Typen, Type Checking und Attributierte Grammatiken</a></li>
</ul>

            <footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Semantische Analyse</h1>
          <article class="default">
            <header class="headline">
            </header>
<h1 id="symboltabellen">Symboltabellen</h1>

<p>Zur semantischen Analyse geh√∂rt die Identifikation und Sammlung von Bezeichnern und die
Zuordnung zur richtigen Ebene (Scopes). Das Werkzeug hierf√ºr sind die Symboltabellen.</p>
<p><a href="#R-image-274f600db011aa677b82bc13ba9b96df" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/architektur_cb.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-274f600db011aa677b82bc13ba9b96df"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/architektur_cb.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>

<ul class="children children-li children-sort-">
	
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/intro-symbtab.html">Semantische Analyse: Symboltabellen</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/scopes.html">Nested Scopes</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/functions.html">Funktionen</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/classes.html">Strukturen und Klassen</a></li>
</ul>

            <footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Symboltabellen</h1>
<article class="default">
<h1>Semantische Analyse: Symboltabellen</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>Auf die lexikalische Analyse und die Syntaxanalyse folgt die semantische Analyse. Nach dem
Parsen steht fest, dass ein Programm syntaktisch korrekt ist. Nun muss gepr√ºft werden, ob
es auch semantisch korrekt ist. Dies umfasst in der Regel die Identifikation und Sammlung
von Bezeichnern und die Zuordnung zur richtigen Ebene (Scopes). Au√üerdem muss die Nutzung
von Symbolen validiert werden: Je nach Sprache m√ºssen beispielsweise Variablen und Funktionen
vor ihrer Benutzung zumindest deklariert sein; Funktionen sollten sich nicht wie Variablen
benutzen lassen, ...</p>
<p>Als Werkzeug werden (hierarchische) Tabellen eingesetzt, um die verschiedenen Symbole und
Informationen dar√ºber zu verwalten. Dabei werden die Symboltabelleneintr√§ge oft an verschiedenen
Stellen im Compiler generiert und benutzt.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/5637iNH0wWk' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Symboltabellen (Intro)</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/af37ca12a1e720f50544efd742b34a297da3e96b74904cb521e51cf42138b083510c8e4456377c945a6e9def30c039b207d572b8dae163b02f8509c137eb6446' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Symboltabellen (Intro)</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K2) Aufgaben der semantischen Analyse</li> <li>(K2) Bedeutung von Symboltabellen: Aufgaben, Verbindung zu Compiler-Phasen</li></ul></div>
</div>




    <h2 id="was-passiert-nach-der-syntaxanalyse">Was passiert nach der Syntaxanalyse?</h2>
<div class='columns'>
<div class='column'>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> y<span style="color:#f92672">+</span>x;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#a6e22e">f</span>(x);</span></span></code></pre></div></div>
<div class='column'>
<p><a href="#R-image-89521b14e7606c26f072ad612ec033a1" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/intro-symbtab/parsetree.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-89521b14e7606c26f072ad612ec033a1"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/intro-symbtab/parsetree.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
</div>
</div>
<p>Nach der Syntaxanalyse braucht der Compiler f√ºr die darauf folgenden Phasen
<strong>semantische Analyse</strong>, Optimierung und Codegenerierung <strong>Informationen
√ºber Bezeichner</strong>, z.B.</p>
<ul>
<li>Welcher Bezeichner ist gemeint?</li>
<li>Welchen Typ hat ein Bezeichner?</li>
</ul>
<p>Auf dem Weg zum Interpreter/Compiler m√ºssen die Symbole im AST korrekt zugeordnet
werden. Dies geschieht √ºber Symboltabellen. Im Folgenden werden wir verschiedene
Aspekte von Symboltabellen betrachten und eine m√∂gliche Implementierung erarbeiten,
bevor wir uns (in <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/syntaxdriven.html">Interpreter</a>)
um die Auswertung (Interpretation) des AST k√ºmmern k√∂nnen.</p>
<h3 id="logische-compilierungsphasen">Logische Compilierungsphasen</h3>
<ul>
<li>
<p>Die lexikalische Analyse generiert eine Folge von Token.</p>
</li>
<li>
<p>Die Syntaxanalyse generiert einen Parse Tree.</p>
</li>
<li>
<p>Die semantische Analyse macht folgendes:</p>
<ul>
<li>Der Parse Tree wird in einen abstrakten Syntaxbaum (AST) umgewandelt.</li>
<li>Dieser wird h√§ufig mit Attributen annotiert.</li>
<li>Dabei sind oft mehrere Baumdurchl√§ufe n√∂tig (z.B. wegen der Abh√§ngigkeiten
der Attribute).</li>
</ul>
</li>
<li>
<p>Nachfolgende Stufen:</p>
<ul>
<li>Der AST wird in einen Zwischencode umgewandelt mit Registern und virtuellen
Adressen.</li>
<li>Der Zwischencode wird optimiert.</li>
<li>Aus dem optimierten Zwischencode wird der endg√ºltige Code, aber immer noch
mit virtuellen Adressen, generiert.</li>
<li>Der generierte Code wird nachoptimiert.</li>
<li>Der Linker ersetzt die virtuellen Adressen durch reale Adressen.</li>
</ul>
</li>
</ul>
<h3 id="abgrenzung-der-phasen">Abgrenzung der Phasen</h3>
<p>Diese Phasen sind oft nicht klar unterscheidbar. Schon allein zur Verbesserung der
Laufzeit baut der Parser oft schon den abstrakten Syntaxbaum auf, der Lexer tr√§gt schon
Bezeichner in Symboltabellen ein, der Parser berechnet beim Baumaufbau schon Attribute,
...</p>
<p>Oft werden gar nicht alle Phasen und alle Zwischendarstellungen ben√∂tigt.</p>
<h2 id="semantische-analyse-und-symboltabellen">Semantische Analyse und Symboltabellen</h2>
<p><a href="#R-image-ba9cfd7df76c27ea0df9415f946ee12f" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/intro-symbtab/architektur_cb.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ba9cfd7df76c27ea0df9415f946ee12f"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/intro-symbtab/architektur_cb.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<h2 id="syntax-und-semantik">Syntax und Semantik</h2>
<ul>
<li>
<p><strong>Syntaxregeln</strong>: Formaler Aufbau eines Programms</p>
</li>
<li>
<p><strong>Semantik</strong>: Bedeutung eines (syntaktisch korrekten) Programms</p>
</li>
</ul>
<p>=&gt; Keine Codegenerierung f√ºr syntaktisch/semantisch inkorrekte Programme!</p>
<p>Zur Erinnerung: Die <em>Syntaxregeln</em> einer Programmiersprache bestimmen den formalen
Aufbau eines zu √ºbersetzenden Programms. Die <em>Semantik</em> gibt die Bedeutung eines
syntaktisch richtigen Programms an.</p>
<p>Lexikalische und syntaktische Analyse k√∂nnen formalisiert mit regul√§ren Ausdr√ºcken und
endlichen Automaten, sowie mit CFG und Parsern durchgef√ºhrt werden.</p>
<p>Die Durchf√ºhrung der semantischen Analyse ist stark von den Eigenschaften der zu
√ºbersetzenden Sprache, sowie der Zielsprache abh√§ngig und kann hier nur beispielhaft
f√ºr einige Eigenschaften erkl√§rt werden.</p>
<p>Es darf kein lauff√§higes Programm erstellt werden k√∂nnen, dass nicht syntaktisch und
semantisch korrekt ist. Ein lauff√§higes Programm muss syntaktisch und semantisch korrekt
sein!</p>
<h2 id="aufgaben-der-semantischen-analyse">Aufgaben der semantischen Analyse</h2>
<ul>
<li>
<p>Identifikation und Sammlung der Bezeichner</p>
</li>
<li>
<p>Zuordnung zur richtigen Ebene (Scopes)</p>
</li>
<li>
<p>Typ-Inferenz</p>
</li>
<li>
<p>Typkonsistenz (Ausdr√ºcke, Funktionsaufrufe, ...)</p>
</li>
<li>
<p>Validieren der Nutzung von Symbolen</p>
<ul>
<li>Vermeidung von Mehrfachdefinition</li>
<li>Zugriff auf nicht definierte Bezeichner</li>
<li>(Lesender) Zugriff auf nicht initialisierte Bezeichner</li>
<li>Funktionen werden nicht als Variablen genutzt</li>
<li>...</li>
</ul>
</li>
</ul>
<p>Die semantische Analyse √ºberpr√ºft die G√ºltigkeit eines syntaktisch korrekten Programms
bzgl. statischer semantischer Eigenschaften und liefert die Grundlage f√ºr die (Zwischen-)
Codeerzeugung und -optimierung. Insbesondere wird hier die Typkonsistenz (in Ausdr√ºcken,
von Parametern, ...) √ºberpr√ºft, und implizite Typumwandlungen werden vorgenommen. Oft
m√ºssen Typen automatisch bestimmt werden (z.B. bei Polymorphie, Typinferenz). Damit
Typen bestimmt oder angepasst werden k√∂nnen, m√ºssen Bezeichner zun√§chst identifiziert
werden, d.h. bei namensgleichen Bezeichnern der richtige Bezug bestimmt werden.</p>
<p>Zu Annotationen/Attributen, Typen und Type-Checks siehe VL
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/attribgrammars.html">Typpr√ºfungen, Attributgrammatiken</a></p>
<p>=&gt; Ein wichtiges Hilfsmittel dazu sind <strong>Symboltabellen</strong></p>
<h3 id="identifizierung-von-objekten">Identifizierung von Objekten</h3>
<p>Beim Compiliervorgang m√ºssen Namen immer wieder den dazugeh√∂rigen Definitionen
zugeordnet, ihre Eigenschaften gesammelt und gepr√ºft und darauf zugegriffen werden.
Symboltabellen werden im Compiler fast √ºberall gebraucht (siehe Abbildung unter
&quot;Einordnung&quot;).</p>
<p>Welche Informationen zu einem Bezeichner gespeichert und ermittelt werden, ist dann
abh√§ngig von der Klasse des Bezeichners.</p>
<h3 id="validieren-der-nutzung-von-symbolen">Validieren der Nutzung von Symbolen</h3>
<p>Hier sind unendlich viele M√∂glichkeiten denkbar. Dies reicht von den unten aufgef√ºhrten
Basispr√ºfungen bis hin zum Pr√ºfen der Typkompatibilit√§t bei arithmetischen Operationen.
Dabei m√ºssen f√ºr alle Ausdr√ºcke die Ergebnistypen berechnet werden und ggf. automatische
Konvertierungen vorgenommen werden, etwa bei <code>3+4.1</code> ...</p>
<ul>
<li>Zugriff auf Variablen: M√ºssen sichtbar sein</li>
<li>Zugriff auf Funktionen: Vorw√§rtsreferenzen sind OK</li>
<li>Variablen werden nicht als Funktionen genutzt</li>
<li>Funktionen werden nicht als Variablen genutzt</li>
</ul>
<p>=&gt; Verweis auf VL <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/attribgrammars.html">Typpr√ºfungen, Attributgrammatiken</a></p>
<p>Da Funktionen bereits vor dem Bekanntmachen der Definition aufgerufen werden d√ºrfen, bietet
sich ein <strong>zweimaliger Durchlauf</strong> (<em>pass</em>) an: Beim ersten Traversieren des AST werden alle
Definitionen in der Symboltabelle gesammelt. Beim zweiten Durchlauf werden dann die Referenzen
aufgel√∂st.</p>
<h3 id="das-mittel-der-wahl-tabellen-f√ºr-die-symbole--bezeichner">Das Mittel der Wahl: Tabellen f√ºr die Symbole (= Bezeichner)</h3>
<p><strong>Def.:</strong> <em>Symboltabellen</em> sind die zentrale Datenstruktur zur Identifizierung und
Verwaltung von bezeichneten Elementen.</p>
<p>Die Organisation der Symboltabellen ist stark anwendungsabh√§ngig. Je nach Sprachkonzept
gibt es eine oder mehrere Symboltabellen, deren Eintr√§ge vom Lexer oder Parser angelegt
werden. Die jeweiligen Inhalte jedes einzelnen Eintrags kommen aus den verschiedenen
Phasen der Compilierung. Symboltabellen werden oft als Hashtables oder auch als B√§ume
implementiert, manchmal als verkettete Listen. In seltenen F√§llen kommt man auch mit
einem Stack aus.</p>
<p>Eine Symboltabelle enth√§lt benutzerdefinierte Bezeichner (oder Verweise in eine Hashtable
mit allen vorkommenden Namen), manchmal auch die Schl√ºsselw√∂rter der Programmiersprache.
Die einzelnen Felder eines Eintrags variieren stark, abh√§ngig vom Typ des Bezeichners
(= Bezeichnerklasse).</p>
<p>Manchmal gibt es f√ºr Datentypen eine Extra-Tabelle, ebenso eine f√ºr die Werte von Konstanten.</p>
<p>Manchmal werden die Namen selbst in eine (Hash-) Tabelle geschrieben. Die Symboltabelle
enth√§lt dann statt der Namen Verweise in diese (Hash-) Tabelle.</p>
<h2 id="einfache-verwaltung-von-variablen-primitiven-typs">Einfache Verwaltung von Variablen primitiven Typs</h2>
<div class='columns'>
<div class='column'>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    x<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></div>
<div class='column'>
<p><a href="#R-image-7e7946b0c793d7b0b01bb32942206967" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/intro-symbtab/simpletable.png?width=20%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 20%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7e7946b0c793d7b0b01bb32942206967"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/intro-symbtab/simpletable.png?width=20%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
</div>
</div>
<p><strong>Bsp.:</strong> Die zu √ºbersetzende Sprache hat nur einen (den globalen) Scope und kennt nur
Bezeichner f√ºr Variablen.</p>
<ul>
<li><strong>Eine</strong> Symboltabelle f√ºr <strong>alle</strong> Bezeichner</li>
<li>Jeder Bezeichner ist der Name einer Variablen</li>
<li>Symboltabelle wird evtl. mit Eintr√§gen aller Schl√ºsselw√∂rter initialisiert -- warum?</li>
<li>Scanner erkennt Bezeichner und sucht ihn in der Symboltabelle</li>
<li>Ist der Bezeichner nicht vorhanden, wird ein (bis auf den Namen leerer) Eintrag angelegt</li>
<li>Scanner √ºbergibt dem Parser das erkannte Token und einen Verweis auf den
Symboltabelleneintrag</li>
</ul>
<p>Die Symboltabelle k√∂nnte hier eine (Hash-) Tabelle oder eine einfache verkettete Liste sein.</p>
<h2 id="was-kann-jetzt-weiter-passieren">Was kann jetzt weiter passieren?</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    x<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>a <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;</span></span></code></pre></div><p>In vielen Sprachen muss √ºberpr√ºft werden, ob es ein definierendes Vorkommen des Bezeichners oder
ein angewandtes Vorkommen ist.</p>
<h3 id="definitionen-und-deklarationen-von-bezeichnern">Definitionen und Deklarationen von Bezeichnern</h3>
<p><strong>Def.:</strong> Die <em>Definition</em> eines (bisher nicht existenten) Bezeichners in einem Programm
generiert einen neuen Bezeichner und legt f√ºr ihn seinem Typ entsprechend Speicherplatz an.</p>
<p><strong>Def.:</strong> Unter der <em>Deklaration</em> eines (bereits existierenden) Bezeichners verstehen wir
seine Bekanntmachung, damit er benutzt werden kann. Er ist oft in einem anderen Scope
definiert und bekommt dort Speicherplatz zugeteilt.</p>
<p>Insbesondere werden auch Typen deklariert. Hier gibt es in der Regel gar keine
Speicherplatzzuweisung.</p>
<p>Ein Bezeichner kann beliebig oft deklariert werden, w√§hrend er in einem Programm nur einmal
definiert werden kann. Oft wird bei der Deklarationen eines Elements sein Namensraum mit
angegeben.</p>
<p><strong>Vorsicht</strong>: Die Begriffe werden auch anders verwendet. Z.B. findet sich in der
Java-Literatur der Begriff <em>Deklaration</em> anstelle von <em>Definition</em>.</p>
<p><strong>Anmerkung</strong>:
Deklarationen beziehen sich auf Definitionen, die woanders in einer Symboltabelle stehen, evtl.
in einer anderen Datei, also in diesem Compilerlauf nicht zug√§nglich sind und erst von Linker
aufgel√∂st werden k√∂nnen. Beim Auftreten einer Deklaration muss die dazugeh√∂rige Definition gesucht
werden,und wenn vorhanden, im Symboltabelleneintrag f√ºr den deklarierten Bezeichner festgehalten
werden. Hier ist evtl. ein zweiter Baumdurchlauf n√∂tig, um alle offenen Deklarationen, die sich
auf Definitionen in derselben Datei beziehen, aufzul√∂sen.</p>
<p>Wird bei objektorientierten Sprachen ein Objekt definiert, dessen Klassendefinition in einer anderen
Datei liegt, kann man die Definition des Objekts gleichzeitig als Deklaration der Klasse auffassen
(Java).</p>
<h2 id="wo-werden-verweise-in-symboltabellen-gebraucht">Wo werden Verweise in Symboltabellen gebraucht?</h2>
<p>=&gt; Parse Tree und AST enthalten Verweise auf Symboltabelleneintr√§ge</p>
<ul>
<li>Im Parse Tree enth√§lt der Knoten f√ºr einen Bezeichner einen Verweis auf den
Symboltabelleneintrag.</li>
<li>Parser und semantische Analyse (AST) vervollst√§ndigen die Eintr√§ge.</li>
<li>Attribute des AST k√∂nnen Feldern der Symboltabelle entsprechen, bzw. sich aus
ihnen berechnen.</li>
<li>F√ºr Debugging-Zwecke k√∂nnen die Symboltabellen die ganze Compilierung und das
Linken √ºberleben.</li>
</ul>
<h2 id="grenzen-der-semantischen-analyse">Grenzen der semantischen Analyse</h2>
<p><strong>Welche semantischen Eigenschaften einer Sprache kann die semantische Analyse nicht √ºberpr√ºfen?</strong></p>
<ul>
<li>Wer ist dann daf√ºr verantwortlich?</li>
<li>Wie √§u√üert sich das im Fehlerfall?</li>
</ul>
<p>Dinge, die erst durch eine Ausf√ºhrung/Interpretation eines Programms berechnet werden k√∂nnen.</p>
<p>Beispielsweise k√∂nnen Werte von Ausdr√ºcken oft erst zur Laufzeit bestimmt werden. Insbesondere
kann die semantische Analyse in der Regel nicht feststellen, ob ein Null-Pointer √ºbergeben wird
und anschlie√üend dereferenziert wird.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Semantische Analyse:</p>
<ul>
<li>Identifikation und Sammlung der Bezeichner</li>
<li>Zuordnung zur richtigen Ebene (Scopes)</li>
<li>Validieren der Nutzung von Symbolen</li>
<li>Typ-Inferenz</li>
<li>Typkonsistenz (Ausdr√ºcke, Funktionsaufrufe, ...)</li>
</ul>
</li>
<li>
<p>Symboltabellen: Verwaltung von Symbolen und Typen (Informationen √ºber Bezeichner)</p>
</li>
<li>
<p>Symboltabelleneintr√§ge werden an verschiedenen Stellen des Compilers generiert und benutzt</p>
</li>
</ul>


    



    



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 3</em></li> <li id='id_Parr2010'>[Parr2010] <strong>Language Implementation Patterns</strong><br>Parr, T., Pragmatic Bookshelf, 2010. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5645-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5645-6</a>.<br><em>Kapitel 6, 7 und 8</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.<br><em>Kapitel 6.4 und 8.4</em></li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Nested Scopes</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>In Symboltabellen werden Informationen √ºber Bezeichner verwaltet. Wenn es in der zu
√ºbersetzenden Sprache <em>Nested Scopes</em> gibt, spiegelt sich dies in den Symboltabellen
wider: Auch hier wird eine entsprechende hierarchische Organisation notwendig. In der
Regel nutzt man Tabellen, die untereinander verlinkt sind.</p>
<p>Eine wichtige Aufgabe ist das Binden von Bezeichner gleichen Namens an ihren jeweiligen
Scope =&gt; <code>bind()</code>. Zus√§tzlich m√ºssen Symboltabellen auch das Abrufen von Bezeichnern
aus dem aktuellen Scope oder den Elternscopes unterst√ºtzen =&gt; <code>resolve()</code>.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/CdM1gvsi6P0' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Nested Scopes</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/1ce547df40e91e7a07497e6a070076157868b7d4b1fa18c2f1e17ee5c348e9063582da157de251ae1eb5daff45cfa97efdff7367b4bdd4634da0c00498c876ab' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Nested Scopes</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K3) Aufbau von Symboltabellen f√ºr Nested Scopes inkl. Strukturen/Klassen mit einem Listener</li> <li>(K3) Aufl√∂sen von Symbolen √ºber die Scopes</li> <li>(K3) Einfache statische Pr√ºfungen anhand der Symboltabellen</li></ul></div>
</div>




    <h2 id="scopes-und-name-spaces">Scopes und Name Spaces</h2>
<p><strong>Def.:</strong> Unter dem <em>G√ºltigkeitsbereich</em> (Sichtbarkeitsbereich, Scope) eines
Bezeichners versteht man den Programmabschnitt, in dem der Bezeichner sichtbar
und nutzbar ist. Das ist oft der kleinste umgebende Block, au√üer darin enthaltene
Scopes, die ein eigenes Element dieses Namens benutzen.</p>
<p>Scopes sind fast immer hierarchisch angeordnet.</p>
<p><strong>Def.:</strong> Unter einem <em>Namensraum</em> (name space) versteht man die Menge der zu
einem Zeitpunkt sichtbaren Bezeichner.</p>
<p>Es gibt Sprachen, in denen man eigene Namensr√§ume explizit definieren kann (z.B.
C++).</p>
<p>Vorsicht: Diese Begriffe werden nicht immer gleich definiert und auch gerne
verwechselt.</p>
<h2 id="symbole-und-nested-scopes">Symbole und (nested) Scopes</h2>
<div class='columns'>
<div class='column'>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> y;
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    { <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> x; }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></div>
<div class='column'>
<p><a href="#R-image-2c44ff90b5796a45086f20aaf9c7801a" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/scopes/nestedscopes.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2c44ff90b5796a45086f20aaf9c7801a"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/scopes/nestedscopes.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
</div>
</div>
<p><strong>Aufgaben</strong>:</p>
<ul>
<li><code>bind()</code>: Symbole im Scope definieren</li>
<li><code>resolve()</code>: Symbole aus Scope oder Eltern-Scope abrufen</li>
</ul>
<h3 id="hinzunahme-von-scopes">Hinzunahme von Scopes</h3>
<p><strong>Bsp.:</strong> Die zu √ºbersetzende Sprache ist scope-basiert und kennt nur Bezeichner
f√ºr Variablen</p>
<p>Scopes k√∂nnen ineinander verschachtelt sein. Die Spezifikation der zu √ºbersetzenden
Sprache legt fest, in welcher Reihenfolge Scopes zu durchsuchen sind, wenn auf einen
Bezeichner Bezug genommen wird, der nicht im aktuellen Scope definiert ist.</p>
<p>Insgesamt bilden die Scopes oft eine Baumstruktur, wobei jeder Knoten einen Scope
repr√§sentiert und seine Kinder die direkt in ihm enthaltenen Scopes sind. Dabei ist
es in der Regel so, dass Scopes sich entweder vollst√§ndig √ºberlappen oder gar nicht.
Wenn ein Bezeichner nicht im aktuellen Scope vorhanden ist, muss er in der Regel in
umschlie√üenden Scopes gesucht werden. Hier kann ein Stack aller &quot;offenen&quot; Scopes
benutzt werden.</p>
<h3 id="grundlegendes-vorgehen">Grundlegendes Vorgehen</h3>
<p>Das Element, das einen neuen Scope definiert, steht selbst in dem aktuell
behandelten Scope. Wenn dieses Element selbst ein Bezeichner ist, geh√∂rt
dieser in den aktuellen Scope. Nur das, was nur innerhalb des oben genannten
Elements oder Bezeichners definiert wird, geh√∂rt in den Scope des Elements
oder Bezeichners.</p>
<h2 id="nested-scopes-symbole-und-scopes">Nested Scopes: Symbole und Scopes</h2>
<h3 id="implementierung-mit-hierarchischen-verketteten-tabellen">Implementierung mit hierarchischen (verketteten) Tabellen</h3>
<p>Pro Scope wird eine Symboltabelle angelegt, dabei enth√§lt jede Symboltabelle zus√§tzlich
einen Verweis auf ihre Vorg√§ngersymboltabelle f√ºr den umgebenden Scope. Die globale
Symboltabelle wird typischerweise mit allen Schl√ºsselw√∂rtern initialisiert.</p>
<ul>
<li>Wenn ein neuer Scope betreten wird, wird eine neue Symboltabelle erzeugt.</li>
<li>Scanner: Erkennt Bezeichner und sucht ihn in der Symboltabelle des aktuellen
Scopes bzw. tr√§gt ihn dort ein und √ºbergibt dem Parser das erkannte Token und
einen Verweis auf den Symboltabelleneintrag (<strong>Erinnerung</strong>: Der Scanner wird
i.d.R. vom Parser aus aufgerufen, d.h. der Parser setzt den aktuellen Scope!)</li>
<li>Parser:
<ul>
<li>Wird ein neues Element (ein Bezeichner) definiert, muss bestimmt werden, ob
es einen eigenen Scope hat. Wenn ja, wird eine neue Symboltabelle f√ºr den
Scope angelegt. Sie enth√§lt alle Definitionen von Elementen, die in diesem
Scope liegen. Der Bezeichner selbst wird in die aktuelle Symboltabelle eingetragen
mit einem Verweis auf die neue Tabelle, die all die Bezeichner beinhaltet, die
au√üerhalb dieses Scopes nicht sichtbar sein sollen. Die Tabellen werden untereinander
verzeigert.</li>
<li>Wird ein Element deklariert oder benutzt, muss sein Eintrag in allen sichtbaren
Scopes in der richtigen Reihenfolge entlang der Verzeigerung gesucht (und je nach
Sprachdefinition auch gefunden) werden.</li>
</ul>
</li>
<li>Der Parse-Tree enth√§lt im Knoten f√ºr den Bezeichner den Verweis in die Symboltabelle</li>
</ul>
<h3 id="klassenhierarchie-f√ºr-scopes">Klassenhierarchie f√ºr Scopes</h3>
<p>F√ºr die Scopes wird eine Klasse <code>Scope</code> definiert mit den Methoden <code>bind()</code> (zum
Definieren von Symbolen im Scope) und <code>resolve()</code> (zum Abrufen von Symbolen aus
dem Scope oder dem umgebenden Scope).</p>
<p>F√ºr lokale Scopes wird eine Instanz dieser Klasse angelegt, die eine Referenz auf
den einschlie√üenden Scope im Attribut <code>enclosingScope</code> h√§lt. F√ºr den globalen Scope
ist diese Referenz einfach leer (<code>None</code>).</p>
<h3 id="klassen-und-interfaces-f√ºr-symbole">Klassen und Interfaces f√ºr Symbole</h3>
<p>F√ºr die Symbole gibt es die Klasse <code>Symbol</code>, wo f√ºr jedes Symbol Name und Typ gespeichert
wird. Variablensymbole leiten direkt von dieser Klasse ab. F√ºr die eingebauten Typen wird
ein &quot;Marker-Interface&quot; <code>Type</code> erstellt, um Variablen- und Typ-Symbole unterscheiden zu
k√∂nnen.</p>
<p><a href="#R-image-4e49b3384f50ee8aa11dc1be08038b3d" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/scopes/nestedscopesuml.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4e49b3384f50ee8aa11dc1be08038b3d"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/scopes/nestedscopesuml.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p><span class='origin'>Quelle: Eigene Modellierung nach einer Idee in <a href="#id_Parr2010">[Parr2010, p. 142]</a></span></p>
<h3 id="alternative-implementierung-√ºber-einen-stack">Alternative Implementierung √ºber einen Stack</h3>
<ul>
<li>Der Parse Tree bzw. der AST enthalten an den Knoten, die jeweils einen ganzen
Scope repr√§sentieren, einen Verweis auf die Symboltabelle dieses Scopes.</li>
<li>Die Scopes werden in einem Stack verwaltet.</li>
<li>Wird ein Scope betreten beim Baumdurchlauf, wird ein Verweis auf seine
Symboltabelle auf den Stack gepackt.</li>
<li>Die Suche von Bezeichnern in umliegenden Scopes erfordert ein Durchsuchen
des Stacks von oben nach unten.</li>
<li>Beim Verlassen eines Scopes beim Baumdurchlauf wird der Scope vom Stack entfernt.</li>
</ul>
<h2 id="nested-scopes-definieren-und-aufl√∂sen-von-namen">Nested Scopes: Definieren und Aufl√∂sen von Namen</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Scope</span>:
</span></span><span style="display:flex;"><span>    Scope enclosingScope    <span style="color:#75715e"># None if global (outermost) scope</span>
</span></span><span style="display:flex;"><span>    Symbol<span style="color:#f92672">&lt;</span>String, Symbol<span style="color:#f92672">&gt;</span> symbols
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">resolve</span>(name):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># do we know &#34;name&#34; here?</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> symbols[name]: <span style="color:#66d9ef">return</span> symbols[name]
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if not here, check any enclosing scope</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span>: <span style="color:#66d9ef">return</span> enclosingScope<span style="color:#f92672">.</span>resolve(name)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">except</span>: <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>     <span style="color:#75715e"># not found</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bind</span>(symbol):
</span></span><span style="display:flex;"><span>        symbols[symbol<span style="color:#f92672">.</span>name] <span style="color:#f92672">=</span> symbol
</span></span><span style="display:flex;"><span>        symbol<span style="color:#f92672">.</span>scope <span style="color:#f92672">=</span> self     <span style="color:#75715e"># track the scope in each symbol</span></span></span></code></pre></div><p><span class='origin'>Quelle: Eigene Implementierung nach einer Idee in <a href="#id_Parr2010">[Parr2010, p. 169]</a></span></p>
<p><strong>Anmerkung</strong>: In der Klasse <code>Symbol</code> kann man ein Feld <code>scope</code> vom Typ <code>Scope</code>
implementieren. Damit &quot;weiss&quot; jedes Symbol, in welchem Scope es definiert ist und
man muss sich auf der Suche nach dem Scope eines Symbols ggf. nicht erst durch
die Baumstruktur hangeln. Aus technischer Sicht verhindert das Attribut das
Aufr√§umen eines lokalen Scopes durch den Garbage Collector, wenn man den lokalen
Scope wieder verl√§sst: Jeder Scope hat eine Referenz auf den umgebenden (Eltern-)
Scope (Feld <code>enclosingScope</code>). Wenn man den aktuellen Scope &quot;nach oben&quot; verl√§sst,
w√ºrde der eben verlassene lokale Scope bei n√§chster Gelegenheit aufger√§umt, wenn
es keine weiteren Referenzen auf diesen g√§be. Da nun aber die Symbole, die in
diesem Scope definiert wurden, auf diesen verweisen, passiert das nicht :)</p>
<h2 id="nested-scopes-listener">Nested Scopes: Listener</h2>
<p>Mit einem passenden Listener kann man damit die n√∂tigen Scopes aufbauen:</p>
<ul>
<li><code>enterStart</code>:
<ul>
<li>erzeuge neuen globalen Scope</li>
<li>definiere und pushe die eingebauten Typen</li>
</ul>
</li>
<li><code>exitVarDecl</code>:
<ul>
<li>l√∂se den Typ der Variablen im aktuellen Scope auf</li>
<li>definiere ein neues Variablensymbol im aktuellen Scope</li>
</ul>
</li>
<li><code>exitVar</code>:
<ul>
<li>l√∂se die Variable im aktuellen Scope auf</li>
</ul>
</li>
<li><code>enterBlock</code>:
<ul>
<li>erzeuge neuen lokalen Scope, wobei der aktuelle Scope der Elternscope ist</li>
<li>ersetze den aktuellen Scope durch den lokalen Scope</li>
</ul>
</li>
<li><code>exitBlock</code>:
<ul>
<li>ersetze den aktuellen Scope durch dessen Elternscope</li>
</ul>
</li>
</ul>
<div class='columns'>
<div class='column'>
<div class="wrap-code highlight"><pre tabindex="0"><code class="language-yacc" data-lang="yacc">start   :   stat+ ;

stat    : block | varDecl | expr &#39;;&#39; ;
block   : &#39;{&#39; stat* &#39;}&#39; ;

varDecl : type ID (&#39;=&#39; expr)? &#39;;&#39; ;
expr    : var &#39;=&#39; INT ;

var     : ID ;
type    : &#39;float&#39; | &#39;int&#39; ;</code></pre></div><p>Relevanter Ausschnitt aus der Grammatik</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>{ <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>; x <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>; }</span></span></code></pre></div></div>
<div class='column'>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyListener</span>(BaseListener):
</span></span><span style="display:flex;"><span>    Scope scope
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">enterStart</span>(Parser<span style="color:#f92672">.</span>FileContext ctx):
</span></span><span style="display:flex;"><span>        globals <span style="color:#f92672">=</span> Scope()
</span></span><span style="display:flex;"><span>        globals<span style="color:#f92672">.</span>bind(BuiltIn(<span style="color:#e6db74">&#34;int&#34;</span>))
</span></span><span style="display:flex;"><span>        globals<span style="color:#f92672">.</span>bind(BuiltIn(<span style="color:#e6db74">&#34;float&#34;</span>))
</span></span><span style="display:flex;"><span>        scope <span style="color:#f92672">=</span> globals
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">enterBlock</span>(Parser<span style="color:#f92672">.</span>BlockContext ctx):
</span></span><span style="display:flex;"><span>        scope <span style="color:#f92672">=</span> Scope(scope)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">exitBlock</span>(Parser<span style="color:#f92672">.</span>BlockContext ctx):
</span></span><span style="display:flex;"><span>        scope <span style="color:#f92672">=</span> scope<span style="color:#f92672">.</span>enclosingScope
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">exitVarDecl</span>(Parser<span style="color:#f92672">.</span>VarDeclContext ctx):
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">=</span> scope<span style="color:#f92672">.</span>resolve(ctx<span style="color:#f92672">.</span>type()<span style="color:#f92672">.</span>getText())
</span></span><span style="display:flex;"><span>        var <span style="color:#f92672">=</span> Variable(ctx<span style="color:#f92672">.</span>ID()<span style="color:#f92672">.</span>getText(), t)
</span></span><span style="display:flex;"><span>        scope<span style="color:#f92672">.</span>bind(var)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">exitVar</span>(Parser<span style="color:#f92672">.</span>VarContext ctx):
</span></span><span style="display:flex;"><span>        name <span style="color:#f92672">=</span> ctx<span style="color:#f92672">.</span>ID()<span style="color:#f92672">.</span>getText()
</span></span><span style="display:flex;"><span>        var <span style="color:#f92672">=</span> scope<span style="color:#f92672">.</span>resolve(name)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> var <span style="color:#f92672">==</span> <span style="color:#66d9ef">None</span>: error(<span style="color:#e6db74">&#34;no such var: &#34;</span> <span style="color:#f92672">+</span> name)</span></span></code></pre></div><p><em>Anmerkung</em>: Um den Code auf die Folie zu bekommen, ist dies ein Mix aus Java und Python geworden. Sry ;)</p>
</div>
</div>
<p>In der Methode <code>exitVar()</code> wird das Variablensymbol beim Ablaufen des AST
lediglich aufgel√∂st und ein Fehler geworfen, wenn das Variablensymbol (noch)
nicht bekannt ist. Hier k√∂nnte man weiteres Type-Checking und/oder -Propagation
ansetzen.</p>
<p>Sp√§ter im Interpreter muss an dieser Stelle dann aber auch der <strong>Wert</strong> der
Variablen abgerufen werden ...</p>
<h2 id="l√∂schen-von-symboltabellen">L√∂schen von Symboltabellen</h2>
<p>M√∂glicherweise sind die Symboltabellen nach der Identifizierungsphase der Elemente
√ºberfl√ºssig, weil die zusammengetragenen Informationen als Attribute im AST stehen.
Die Knoten enthalten dann Verweise auf definierende Knoten von Elementen, nicht mehr
auf Eintr√§ge in den Symboltabellen. In diesem Fall k√∂nnen die Symboltabellen nach der
Identifizierung gel√∂scht werden, wenn sie nicht z.B. f√ºr einen symbolischen Debugger
noch gebraucht werden.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Symboltabellen: Verwaltung von Symbolen und Typen (Informationen √ºber Bezeichner)</p>
</li>
<li>
<p>Bl√∂cke: Nested Scopes =&gt; hierarchische Organisation</p>
</li>
<li>
<p>Binden von Bezeichner gleichen Namens an ihren jeweiligen Scope =&gt; <code>bind()</code></p>
</li>
<li>
<p>Abrufen von Bezeichnern aus dem aktuellen Scope oder den Elternscopes =&gt; <code>resolve()</code></p>
</li>
</ul>


    



    



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 3</em></li> <li id='id_Parr2010'>[Parr2010] <strong>Language Implementation Patterns</strong><br>Parr, T., Pragmatic Bookshelf, 2010. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5645-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5645-6</a>.<br><em>Kapitel 6, 7 und 8</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.<br><em>Kapitel 6.4 und 8.4</em></li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Funktionen</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>Eine Funktion sind selbst ein Symbol, welches in einem Scope gilt und entsprechend
in der Symboltabelle eingetragen wird. Dar√ºber hinaus bildet sie einen neuen
verschachtelten Scope, in dem die Funktionsparameter und der Funktionsk√∂rper definiert
werden m√ºssen.</p>
<p>Entsprechend m√ºssen die Strukturen f√ºr die Symboltabellen sowie das Eintragen und das
Aufl√∂sen von Symbolen erweitert werden.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/yk2x6WGhgVg' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Funktionen</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/eddc0526dca0dd506e7f1a4ea426319fca05126ebacadb328ab8ccf68f2d0b038bc58b98ab51fdf3774db1b3a4ffe5b3d2279c7db4a37fe277ed2f3b27b9e495' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Funktionen</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K3) Aufbau von Symboltabellen f√ºr Nested Scopes inkl. Strukturen/Klassen mit einem Listener</li> <li>(K3) Attribute von Klassen und Strukturen aufl√∂sen</li></ul></div>
</div>




    <h2 id="funktionen-und-scopes">Funktionen und Scopes</h2>
<div class='columns'>
<div class='column'>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> y;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    { <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> x; }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">g</span>(<span style="color:#66d9ef">int</span> z){}</span></span></code></pre></div></div>
<div class='column'>
<p><a href="#R-image-0527fa5c195d588964ee4eb9f474524d" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/functions/functionscopes.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0527fa5c195d588964ee4eb9f474524d"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/functions/functionscopes.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
</div>
</div>
<h3 id="behandlung-von-funktionsdefinitionen">Behandlung von Funktionsdefinitionen</h3>
<ul>
<li>Jeder Symboltabelleneintrag braucht ein Feld, das angibt, ob es sich um eine
Variable, eine Funktion, ... handelt. Alternativ eine eigene Klasse ableiten ...</li>
<li>Der Name der Funktion steht als Bezeichner in der Symboltabelle des Scopes, in dem
die Funktion definiert wird.</li>
<li>Der Symboltabelleneintrag f√ºr den Funktionsnamen enth√§lt Verweise auf die Parameter.</li>
<li>Der Symboltabelleneintrag f√ºr den Funktionsnamen enth√§lt Angaben √ºber den R√ºckgabetypen.</li>
<li>Jede Funktion wird grunds√§tzlich wie ein neuer Scope behandelt.</li>
<li>Die formalen Parameter werden als Eintr√§ge in der Symboltabelle f√ºr den Scope der
Funktion angelegt and entsprechend als Parameter gekennzeichnet.</li>
</ul>
<h3 id="behandlung-von-funktionsaufrufen">Behandlung von Funktionsaufrufen</h3>
<ul>
<li>Der Name der Funktion steht als Bezeichner in der Symboltabelle des Scopes, in dem
die Funktion aufgerufen wird und wird als Aufruf gekennzeichnet.</li>
<li>Der Symboltabelleneintrag f√ºr den Funktionsnamen enth√§lt Verweise auf die aktuellen
Parameter.</li>
<li>Die Definition der Funktion wird in den zug√§nglichen Scopes gesucht (wie oben) und
ein Verweis darauf in der Symboltabelle gespeichert.</li>
</ul>
<h2 id="erweiterung-des-klassendiagramms-f√ºr-funktions-scopes">Erweiterung des Klassendiagramms f√ºr Funktions-Scopes</h2>
<p><a href="#R-image-6d21a428ecfe6a1b3912a512ae251402" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/functions/functionscopesuml.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6d21a428ecfe6a1b3912a512ae251402"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/functions/functionscopesuml.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p><span class='origin'>Quelle: Eigene Modellierung nach einer Idee in <a href="#id_Parr2010">[Parr2010, p. 147]</a></span></p>
<h2 id="funktionen-sind-symbole-und-scopes">Funktionen sind Symbole <em>und</em> Scopes</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Function</span>(Scope, Symbol):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(name, retType, enclScope):
</span></span><span style="display:flex;"><span>        Symbol<span style="color:#f92672">.</span>__init__(name, retType)      <span style="color:#75715e"># we are &#34;Symbol&#34; ...</span>
</span></span><span style="display:flex;"><span>        enclosingScope <span style="color:#f92672">=</span> enclScope          <span style="color:#75715e"># ... and &#34;Scope&#34;</span></span></span></code></pre></div><h2 id="funktionen-listener">Funktionen: Listener</h2>
<p>Den Listener zum Aufbau der Scopes k√∂nnte man entsprechend erweitern:</p>
<ul>
<li><code>enterFuncDecl</code>:
<ul>
<li>l√∂se den Typ der Funktion im aktuellen Scope auf</li>
<li>lege neues Funktionssymbol an, wobei der aktuelle Scope der Elternscope ist</li>
<li>definiere das Funktionssymbol im aktuellen Scope</li>
<li>ersetze den aktuellen Scope durch das Funktionssymbol</li>
</ul>
</li>
<li><code>exitFuncDecl</code>:
<ul>
<li>ersetze den aktuellen Scope durch dessen Elternscope</li>
</ul>
</li>
<li><code>exitParam</code>: analog zu <code>exitVarDecl</code>
<ul>
<li>l√∂se den Typ der Variablen im aktuellen Scope auf</li>
<li>definiere ein neues Variablensymbol im aktuellen Scope</li>
</ul>
</li>
<li><code>exitCall</code>: analog zu <code>exitVar</code>
<ul>
<li>l√∂se das Funktionssymbol (und die Argumente) im aktuellen Scope auf</li>
</ul>
</li>
</ul>
<div class='columns'>
<div class='column'>
<div class="wrap-code highlight"><pre tabindex="0"><code class="language-yacc" data-lang="yacc">funcDecl : type ID &#39;(&#39; params? &#39;)&#39; block ;
params   : param (&#39;,&#39; param)* ;
param    : type ID ;

call     : ID &#39;(&#39; exprList? &#39;)&#39; ;
exprList : expr (&#39;,&#39; expr)* ;</code></pre></div><p>Relevanter Ausschnitt aus der Grammatik</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#a6e22e">f</span>(x);</span></span></code></pre></div></div>
<div class='column'>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">enterFuncDecl</span>(Parser<span style="color:#f92672">.</span>FuncDeclContext ctx):
</span></span><span style="display:flex;"><span>    name <span style="color:#f92672">=</span> ctx<span style="color:#f92672">.</span>ID()<span style="color:#f92672">.</span>getText()
</span></span><span style="display:flex;"><span>    type <span style="color:#f92672">=</span> scope<span style="color:#f92672">.</span>resolve(ctx<span style="color:#f92672">.</span>type()<span style="color:#f92672">.</span>getText())
</span></span><span style="display:flex;"><span>    func <span style="color:#f92672">=</span> Function(name, type, scope)
</span></span><span style="display:flex;"><span>    scope<span style="color:#f92672">.</span>bind(func)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># change current scope to function scope</span>
</span></span><span style="display:flex;"><span>    scope <span style="color:#f92672">=</span> func
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">exitFuncDecl</span>(Parser<span style="color:#f92672">.</span>FuncDeclContext ctx):
</span></span><span style="display:flex;"><span>    scope <span style="color:#f92672">=</span> scope<span style="color:#f92672">.</span>enclosingScope
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">exitParam</span>(Parser<span style="color:#f92672">.</span>ParamContext ctx):
</span></span><span style="display:flex;"><span>    t <span style="color:#f92672">=</span> scope<span style="color:#f92672">.</span>resolve(ctx<span style="color:#f92672">.</span>type()<span style="color:#f92672">.</span>getText())
</span></span><span style="display:flex;"><span>    var <span style="color:#f92672">=</span> Variable(ctx<span style="color:#f92672">.</span>ID()<span style="color:#f92672">.</span>getText(), t)
</span></span><span style="display:flex;"><span>    scope<span style="color:#f92672">.</span>bind(var)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">exitCall</span>(Parser<span style="color:#f92672">.</span>CallContext ctx):
</span></span><span style="display:flex;"><span>    name <span style="color:#f92672">=</span> ctx<span style="color:#f92672">.</span>ID()<span style="color:#f92672">.</span>getText()
</span></span><span style="display:flex;"><span>    func <span style="color:#f92672">=</span> scope<span style="color:#f92672">.</span>resolve(name)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> func <span style="color:#f92672">==</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        error(<span style="color:#e6db74">&#34;no such function: &#34;</span> <span style="color:#f92672">+</span> name)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> func<span style="color:#f92672">.</span>type <span style="color:#f92672">==</span> Variable:
</span></span><span style="display:flex;"><span>        error(name <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; is not a function&#34;</span>)</span></span></code></pre></div><p><em>Anmerkung</em>: Um den Code auf die Folie zu bekommen, ist dies wieder ein Mix aus Java und Python geworden. Sry ;)</p>
</div>
</div>
<p>Im Vergleich zu den einfachen <em>nested scopes</em> kommt hier nur ein weiterer
Scope f√ºr den Funktionskopf dazu. Dieser spielt eine Doppelrolle: Er ist
sowohl ein Symbol (welches im Elternscope bekannt ist) als auch ein eigener
(lokaler) Scope f√ºr die Funktionsparameter.</p>
<p>Um sp√§ter im Interpreter eine Funktion tats√§chlich auswerten zu k√∂nnen, muss
im Scope der Funktion zus√§tzlich der AST-Knoten der Funktionsdefinition
gespeichert werden (weiteres Feld/Attribut in <code>Function</code>)!</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Symboltabellen: Verwaltung von Symbolen und Typen (Informationen √ºber Bezeichner)</p>
</li>
<li>
<p>Funktionen: Nested Scopes =&gt; hierarchische Organisation</p>
</li>
<li>
<p>Umgang mit dem Funktionsnamen, den Parametern und dem Funktionsk√∂rper</p>
</li>
</ul>


    



    



    

    
<div class="box notices cstyle note">
  <div class="box-label"><i class="fas fa-puzzle-piece"></i> Challenges</div>
  <div class="box-content">

<p>Diskutieren Sie folgende Fragen:</p>
<ul>
<li>Warum werden √ºberhaupt Symboltabellen eingesetzt?</li>
<li>Warum muss man zwischen Deklaration und Definition unterscheiden?</li>
<li>Erkl√§ren Sie die Verbindung einer Symboltabelle zu den einzelnen Phasen einer Compiler-Pipeline.</li>
<li>Wo liegen die Grenzen der semantischen Analyse?</li>
<li>Warum kann man im Allgemeinen nicht die Symboltabellen nutzen, um die Werte von Symbolen mit zu speichern?</li>
<li>Wieso sind Funktionen Scope und Symbol gleichzeitig?</li>
<li>Skizzieren Sie f√ºr eine Funktionsdeklaration mit Parametern die resultierende Symboltabelle.</li>
<li>Erkl√§ren Sie, wie man beim Funktionsaufruf vorgehen w√ºrde. Werden dabei Eintr√§ge in der Symboltabelle erzeugt?</li>
</ul>
</div>
</div>



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 3</em></li> <li id='id_Parr2010'>[Parr2010] <strong>Language Implementation Patterns</strong><br>Parr, T., Pragmatic Bookshelf, 2010. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5645-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5645-6</a>.<br><em>Kapitel 6, 7 und 8</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.<br><em>Kapitel 6.4 und 8.4</em></li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Strukturen und Klassen</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>Strukturen und Klassen bilden jeweils einen eigenen verschachtelten Scope, worin
die Attribute und Methoden definiert werden.</p>
<p>Bei der Namensaufl√∂sung muss man dies beachten und darf beim Zugriff auf Attribute
und Methoden nicht einfach in den √ºbergeordneten Scope schauen. Zus√§tzlich m√ºssen
hier Vererbungshierarchien in der Struktur der Symboltabelle ber√ºcksichtigt werden.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/-w9ljeFGq3k' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Strukturen und Klassen</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/61bbea5570ec17a741c3899f0822085deee317d4f5f34268eb6bcc1cc4ce6b443eb2ac397791e1fbeb5ba7a9d6c46cf08307bf3be2ccde9b7d2fc0a6ee9cfcc9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Strukturen und Klassen</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K3) Aufbau von Symboltabellen f√ºr Nested Scopes inkl. Strukturen/Klassen mit einem Listener</li> <li>(K3) Attribute von Klassen und Strukturen aufl√∂sen</li></ul></div>
</div>




    <h2 id="strukturen">Strukturen</h2>
<div class='columns'>
<div class='column'>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> A {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> B {<span style="color:#66d9ef">int</span> x;};
</span></span><span style="display:flex;"><span>    B b;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> C {<span style="color:#66d9ef">int</span> z;};
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>A a;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>() {
</span></span><span style="display:flex;"><span>    A a;
</span></span><span style="display:flex;"><span>    a.b.x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></div>
<div class='column'>
<p><a href="#R-image-314b62671411cd8912ad522dd85611b0" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/classes/structscopes.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-314b62671411cd8912ad522dd85611b0"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/classes/structscopes.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
</div>
</div>
<h2 id="strukturen-erweiterung-der-symbole-und-scopes">Strukturen: Erweiterung der Symbole und Scopes</h2>
<p><a href="#R-image-c626c076682a1190467c3c2b6bead5b4" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/classes/structscopesuml.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c626c076682a1190467c3c2b6bead5b4"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/classes/structscopesuml.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p><span class='origin'>Quelle: Eigene Modellierung nach einer Idee in <a href="#id_Parr2010">[Parr2010, p. 162]</a></span></p>
<p>Strukturen stellen wie Funktionen sowohl einen Scope als auch ein Symbol dar.</p>
<p>Zus√§tzlich stellt eine Struktur (-definition) aber auch einen neuen Typ
dar, weshalb <code>Struct</code> auch noch das Interface <code>Type</code> &quot;implementiert&quot;.</p>
<h2 id="strukturen-aufl√∂sen-von-namen">Strukturen: Aufl√∂sen von Namen</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Struct</span>(Scope, Symbol, Type):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">resolveMember</span>(name):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> symbols[name]</span></span></code></pre></div><p>=&gt; Aufl√∂sen von &quot;<code>a.b</code>&quot;¬†(im Listener in <code>exitMember()</code>):</p>
<ul>
<li><code>a</code> im &quot;normalen&quot; Modus mit <code>resolve()</code> √ºber den aktuellen Scope</li>
<li>Typ von <code>a</code> ist <code>Struct</code> mit Verweis auf den eigenen Scope</li>
<li><code>b</code> nur innerhalb des <code>Struct</code>-Scopes mit <code>resolveMember()</code></li>
</ul>
<p>In der Grammatik w√ºrde es eine Regel <code>member</code> geben, die auf eine Struktur
der Art <code>ID.ID</code> anspricht (d.h. eigentlich den Teil <code>.ID</code>), und entsprechend
zu Methoden <code>enterMember()</code> und <code>exitMember()</code> im Listener f√ºhrt.</p>
<p>Das Symbol f√ºr <code>a</code> hat als <code>type</code>-Attribut eine Referenz auf die <code>Struct</code>,
die ja einen eigenen Scope hat (<code>symbols</code>-Map). Darin muss dann <code>b</code> aufgel√∂st
werden.</p>
<h2 id="klassen">Klassen</h2>
<div class='columns'>
<div class='column'>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>() { ; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> y;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> z <span style="color:#f92672">=</span> x<span style="color:#f92672">+</span>y;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></div>
<div class='column'>
<p><a href="#R-image-6514501e788189974c47ede62db8caaf" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/classes/classscopes.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6514501e788189974c47ede62db8caaf"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/classes/classscopes.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
</div>
</div>
<h2 id="klassen-erweiterung-der-symbole-und-scopes">Klassen: Erweiterung der Symbole und Scopes</h2>
<p><a href="#R-image-790d9a63525a3a62deb650d3594f6a19" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/classes/classscopesuml.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-790d9a63525a3a62deb650d3594f6a19"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/classes/classscopesuml.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p><span class='origin'>Quelle: Eigene Modellierung nach einer Idee in <a href="#id_Parr2010">[Parr2010, p. 167]</a></span></p>
<p>Bei Klassen kommt in den Tabellen ein weiterer Pointer <code>parentClazz</code> auf die
Elternklasse hinzu (in der Superklasse ist der Wert <code>None</code>).</p>
<h2 id="klassen-aufl√∂sen-von-namen">Klassen: Aufl√∂sen von Namen</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Clazz</span>(Struct):
</span></span><span style="display:flex;"><span>    Clazz parentClazz   <span style="color:#75715e"># None if base class</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">resolve</span>(name):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># do we know &#34;name&#34; here?</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> symbols[name]: <span style="color:#66d9ef">return</span> symbols[name]
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># NEW: if not here, check any parent class ...</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> parentClazz <span style="color:#f92672">!=</span> <span style="color:#66d9ef">None</span>: <span style="color:#66d9ef">return</span> parentClazz<span style="color:#f92672">.</span>resolve(name)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># ... or enclosing scope if base class</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span>: <span style="color:#66d9ef">return</span> enclosingScope<span style="color:#f92672">.</span>resolve(name)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">except</span>: <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>     <span style="color:#75715e"># not found</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">resolveMember</span>(name):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> symbols[name]: <span style="color:#66d9ef">return</span> symbols[name]
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># NEW: check parent class</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span>: <span style="color:#66d9ef">return</span> parentClazz<span style="color:#f92672">.</span>resolveMember(name)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">except</span>: <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span></span></span></code></pre></div><p><span class='origin'>Quelle: Eigene Implementierung nach einer Idee in <a href="#id_Parr2010">[Parr2010, p. 172]</a></span></p>
<p>Beim Aufl√∂sen von Attributen oder Methoden muss zun√§chst in der Klasse selbst gesucht werden,
anschlie√üend in der Elternklasse.</p>
<p>Beispiel (mit den obigen Klassen <code>A</code> und <code>B</code>):</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>B foo;
</span></span><span style="display:flex;"><span>foo.x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;</span></span></code></pre></div><p>Hier wird analog zu den Structs zuerst <code>foo</code> mit <code>resolve()</code> im lokalen Scope aufgel√∂st. Der Typ
des Symbols <code>foo</code> ist ein <code>Clazz</code>, was zugleich ein Scope ist. In diesem Scope wird nun mit
<code>resolveMember()</code> nach dem Symbol <code>x</code> gesucht. Falls es hier nicht gefunden werden kann, wird in
der Elternklasse (sofern vorhanden) weiter mit<code>resolveMember()</code> gesucht.</p>
<p>Die normale Namensaufl√∂sung wird ebenfalls erweitert um die Aufl√∂sung in der Elternklasse.</p>
<p>Beispiel:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> wuppie;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>() { ; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> y;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> z <span style="color:#f92672">=</span> x<span style="color:#f92672">+</span>y<span style="color:#f92672">+</span>wuppie;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div><p>Hier w√ºrde <code>wuppie</code> als Symbol im globalen Scope definiert werden. Beim Verarbeiten von
<code>int z = x+y+wuppie;</code> w√ºrde mit <code>resolve()</code> nach <code>wuppie</code> gesucht: Zuerst im lokalen Scope
unterhalb der Funktion, dann im Funktions-Scope, dann im Klassen-Scope von <code>B</code>. Hier sucht
<code>resolve()</code> auch zun√§chst lokal, geht dann aber die Vererbungshierarchie entlang (sofern
wie hier vorhanden). Erst in der Superklasse (wenn der <code>parentClazz</code>-Zeiger <code>None</code> ist),
l√∂st <code>resolve()</code> wieder normal auf und sucht um umgebenden Scope. Auf diese Weise kann man
wie gezeigt in Klassen (Methoden) auf globale Variablen verweisen ...</p>
<p><em>Anmerkung</em>: Durch dieses Vorgehen wird im Prinzip in Methoden aus dem Zugriff auf ein Feld
<code>x</code> implizit ein <code>this.x</code> aufgel√∂st, wobei <code>this</code> die Klasse aufl√∂st und <code>x</code> als Attribut darin.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Symboltabellen: Verwaltung von Symbolen und Typen (Informationen √ºber Bezeichner)</p>
</li>
<li>
<p>Strukturen und Klassen bilden eigenen Scope</p>
</li>
<li>
<p>Strukturen/Klassen l√∂sen etwas anders auf: Zugriff auf Attribute und Methoden</p>
</li>
</ul>


    



    



    

    
<div class="box notices cstyle note">
  <div class="box-label"><i class="fas fa-puzzle-piece"></i> Challenges</div>
  <div class="box-content">

<p><strong>Symboltabellen praktisch</strong></p>
<p>Betrachten Sie folgenden Java-Code:</p>
<ol>
<li>Umkreisen Sie alle Symbole.</li>
<li>Zeichen Sie Pfeile von Symbol-Referenzen zur jeweiligen Definition (falls vorhanden).</li>
<li>Identifizieren Sie alle benannten Scopes.</li>
<li>Identifizieren Sie alle anonymen Scopes.</li>
<li>Geben Sie die resultierende Symboltabelle an (Strukturen wie in VL besprochen).</li>
</ol>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> a.b<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> u.Y<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">X</span> <span style="color:#66d9ef">extends</span> Y <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">f</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x<span style="color:#f92672">,</span>y<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">{</span> <span style="color:#66d9ef">int</span> x<span style="color:#f92672">;</span> x <span style="color:#f92672">-</span> y <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Z</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">W</span> <span style="color:#66d9ef">extends</span> X <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> f<span style="color:#f92672">(</span><span style="color:#ae81ff">34</span><span style="color:#f92672">);</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x<span style="color:#f92672">,</span>z<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">f</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> y<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        z <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div></div>
</div>



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 3</em></li> <li id='id_Parr2010'>[Parr2010] <strong>Language Implementation Patterns</strong><br>Parr, T., Pragmatic Bookshelf, 2010. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5645-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5645-6</a>.<br><em>Kapitel 6, 7 und 8</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.<br><em>Kapitel 6.4 und 8.4</em></li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

          </section>
<article class="default">
<h1>Typen, Type Checking und Attributierte Grammatiken</h1>



    
    




    
    
        
        
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="far fa-file-powerpoint"></i> Annotierte Folien</div>
  <div class="box-content">

<ul> <li><a href='https://raw.githubusercontent.com/Compiler-CampusMinden/AnnotatedSlides/master/semantics_attribgrammars.ann.ma.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Annotierte Folien: Typen, Type Checking und attributierte Grammatiken</a></li></ul></div>
</div>




    <h1 id="motivation">Motivation</h1>
<h2 id="ist-das-alles-erlaubt">Ist das alles erlaubt?</h2>
<p>Operation erlaubt?</p>
<p>Zuweisung erlaubt?</p>
<p>Welcher Ausdruck hat welchen Typ?</p>
<p>(Welcher Code muss daf√ºr erzeugt werden?)</p>
<ul>
<li>a = b</li>
<li>a = f(b)</li>
<li>a = b + c</li>
<li>a = b + o.nummer</li>
<li>if (f(a) == f(b))</li>
</ul>
<h2 id="taschenrechner-parsen-von-ausdr√ºcken-wie-354">Taschenrechner: Parsen von Ausdr√ºcken wie <code>3*5+4</code></h2>
<pre><code>expr : expr '+' term
     | term
     ;
term : term '*' DIGIT
     | DIGIT
     ;

DIGIT : [0-9] ;
</code></pre>
<p>=&gt; Wie den Ausdruck <strong>ausrechnen</strong>?</p>
<p><em>Anmerkung</em>: Heute geht es um die einfachste Form der semantischen Analyse: Anreichern einer Grammatik um
Attribute und Aktionen, die w√§hrend des Parsens oder bei der Traversierung des Parse-Trees ausgewertet
werden.</p>
<h1 id="semantische-analyse">Semantische Analyse</h1>
<h2 id="das-haben-wir-bis-jetzt">Das haben wir bis jetzt</h2>
<p>Wir haben den AST vorliegen.</p>
<p>Idealerweise enth√§lt er bei jedem Bezeichner einen Verweis in sogenannte Symboltabellen (siehe sp√§tere Veranstaltung).</p>
<p>Beim Parsen k√∂nnen schon einige semantische Eigenschaften des zu √ºbersetzenden Programms √ºberpr√ºft werden, falls erforderlich z. B.:</p>
<ul>
<li>Wurden alle Variablen / Objekte vor ihrer Verwendung definiert oder deklariert?</li>
<li>Wurden keine Elemente mehrfach definiert?</li>
<li>Wurden alle Funktionen / Methoden mit der richtigen Anzahl Parameter aufgerufen? (Nicht in allen F√§llen schon pr√ºfbar)</li>
<li>Haben Arrayzugriffe auch keine zu hohe Dimension?</li>
<li>Werden auch keine Namen benutzt, f√ºr die es keine Definition / Deklaration gibt?</li>
</ul>
<h2 id="was-fehlt-jetzt-noch">Was fehlt jetzt noch?</h2>
<p>Es m√ºssen kontextsensitive Analysen durchgef√ºhrt werden, allen voran Typanalysen. Damit der &quot;richtige&quot; (Zwischen-) Code entsprechend den beteiligten Datentypen erzeugt werden kann, muss mit Hilfe des Typsystems der Sprache (aus der Sprachdefinition) √ºberpr√ºft werden, ob alle Operationen nur mit den korrekten Datentypen benutzt werden. Dazu geh√∂rt auch, dass nicht nur Typen von z. B. Variablen, sondern von ganzen Ausdr√ºcken betrachtet, bzw. bestimmt werden. Damit kann dann f√ºr die Codeerzeugung festgelegt werden, welcher Operator realisiert werden muss (√úberladung).</p>
<h1 id="analyse-von-datentypen">Analyse von Datentypen</h1>
<h2 id="typisierung">Typisierung</h2>
<ul>
<li>stark oder statisch typisierte Sprachen: Alle oder fast alle Typ√ºberpr√ºfungen finden in der semantischen Analyse statt (C, C++, Java)</li>
<li>schwach oder dynamisch typisierte Sprachen: Alle oder fast alle Typ√ºberpr√ºfungen finden zur Laufzeit statt (Python, Lisp, Perl)</li>
<li>untypisierte Sprachen: keinerlei Typ√ºberpr√ºfungen (Maschinensprache)</li>
</ul>
<h2 id="ausdr√ºcke">Ausdr√ºcke</h2>
<p>Jetzt muss f√ºr jeden Ausdruck im weitesten Sinne sein Typ bestimmt werden.</p>
<p>Ausdr√ºcke k√∂nnen hier sein:</p>
<ul>
<li>rechte Seiten von Zuweisungen</li>
<li>linke Seiten von Zuweisungen</li>
<li>Funktions- und Methodenaufrufe</li>
<li>jeder einzelne aktuelle Parameter in Funktions- und Methodenaufrufen</li>
<li>Bedingungen in Kontrollstrukturen</li>
</ul>
<h2 id="typinferenz">Typinferenz</h2>
<p><strong>Def.:</strong> <em>Typinferenz</em> ist die Bestimmung des Datentyps jedes Bezeichners und jedes Ausdrucks im Code.</p>
<p>Der Typ eines Ausdrucks wird mit Hilfe der Typen seiner Unterausdr√ºcke bestimmt.</p>
<p>Dabei kann man ein Kalk√ºl mit sog. Inferenzregeln der Form</p>

<span class="math align-center">$$\frac{f:s \rightarrow t\ \ \ \ \ x:s}{f(x) : t}$$</span>
<p><em>(Wenn f den Typ</em> 
<span class="math align-center">$s \rightarrow t$</span> <em>hat und x den Typ s,
dann hat der Ausdruck f(x) den Typ t.)</em></p>
<p>benutzen. So wird dann z. B. auch √úberladung aufgel√∂st und Polymorphie zur Laufzeit.</p>
<h2 id="statische-typpr√ºfungen">Statische Typpr√ºfungen</h2>
<p><strong>Bsp.:</strong> Der + - Operator:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Typ 1. Operand</th>
<th style="text-align:center">Typ 2. Operand</th>
<th style="text-align:center">Ergebnistyp</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">int</td>
<td style="text-align:center">int</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">float</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">float</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">int</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center">string</td>
<td style="text-align:center">string</td>
</tr>
</tbody>
</table>
<h2 id="typkonvertierungen">Typkonvertierungen</h2>
<ul>
<li>
<p>Der Compiler kann implizite Typkonvertierungen vornehmen, um einen Ausdruck zu verifizieren (siehe Sprachdefiniton).</p>
</li>
<li>
<p>In der Regel sind dies Typerweiterungen, z.B. von <em>int</em> nach <em>float</em>.</p>
</li>
<li>
<p>Manchmal muss zu zwei Typen der kleinste Typ gefunden werden, der beide vorhandenen Typen umschlie√üt.</p>
</li>
<li>
<p>Explizite Typkonvertierungen hei√üen auch <em>Type Casts</em>.</p>
</li>
</ul>
<h2 id="nicht-grunds√§tzlich-statisch-m√∂gliche-typpr√ºfungen">Nicht grunds√§tzlich statisch m√∂gliche Typpr√ºfungen</h2>
<p><strong>Bsp.:</strong> Der ^ - Operator 
<span class="math align-center">$(a^b)$</span>:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Typ 1. Operand</th>
<th style="text-align:center">Typ 2. Operand</th>
<th style="text-align:center">Ergebnistyp</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">int 
<span class="math align-center">$\geq$</span> 0</td>
<td style="text-align:center">int</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">int &lt; 0</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">float</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td style="text-align:center">
<span class="math align-center">$\ldots$</span></td>
<td style="text-align:center">
<span class="math align-center">$\ldots$</span></td>
<td style="text-align:center">
<span class="math align-center">$\ldots$</span></td>
</tr>
</tbody>
</table>
<h1 id="attributierte-grammatiken">Attributierte Grammatiken</h1>
<h2 id="was-man-damit-macht">Was man damit macht</h2>
<p>Die Syntaxanalyse kann keine kontextsensitiven Analysen durchf√ºhren.</p>
<ul>
<li>
<p>Kontextsensitive Grammatiken benutzen: Laufzeitprobleme, das Parsen von cs-Grammatiken ist <em>PSPACE-complete</em>.</p>
</li>
<li>
<p>Der Parsergenerator <em>Bison</em> generiert LALR(1)-Parser, aber auch sog. <em>Generalized LR (GLR) Parser</em>, die bei nichtl√∂sbaren Konflikten in der Grammatik (Reduce/Reduce oder Shift/Reduce) parallel den Input mit jede der M√∂glichkeiten weiterparsen.</p>
</li>
<li>
<p>Ein weiterer Ansatz, kontextsensitive Abh√§ngigkeiten zu ber√ºcksichtigen, ist der Einsatz von attributierten Grammatiken, nicht nur zur Typanalyse, sondern evtl. auch zur Codegenerierung.</p>
</li>
<li>
<p>Informationen weden im Baum weitergegeben.</p>
</li>
</ul>
<h1 id="syntax-gesteuerte-√ºbersetzung-attribute-und-aktionen">Syntax-gesteuerte √úbersetzung: Attribute und Aktionen</h1>
<h2 id="berechnen-der-ausdr√ºcke">Berechnen der Ausdr√ºcke</h2>
<pre><code>expr : expr '+' term ;

translate expr ;
translate term ;
handle + ;
</code></pre>
<h2 id="attributierte-grammatiken-sdd">Attributierte Grammatiken (SDD)</h2>
<p>auch &quot;<em>syntax-directed definition</em>&quot;</p>
<p>Anreichern einer CFG:</p>
<ul>
<li>Zuordnung einer Menge von Attributen zu den Symbolen (Terminal- und Nicht-Terminal-Symbole)</li>
<li>Zuordnung einer Menge von <em>semantischen Regeln</em> (Evaluationsregeln) zu den Produktionen</li>
</ul>
<h2 id="definition-attributierte-grammatik">Definition: Attributierte Grammatik</h2>
<p>Eine <em>attributierte Grammatik</em> <em>AG = (G,A,R)</em> besteht aus folgenden Komponenten:</p>
<ul>
<li>
<p>Mengen A(X) der Attribute eines Nonterminals X</p>
</li>
<li>
<p><em>G = (N, T, P, S)</em> ist eine cf-Grammatik</p>
</li>
<li>
<p>A = 
<span class="math align-center">$\bigcup\limits_{X \in (T \cup N)} A(X)$</span> mit 
<span class="math align-center">$A(X) \cap A(Y) \neq \emptyset \Rightarrow X = Y$</span></p>
</li>
<li>
<p>R = 
<span class="math align-center">$\bigcup\limits_{p \in P} R(p)$</span> mit 
<span class="math align-center">$R(p) = \lbrace X_i.a = f(\ldots) \vert p : X_0 \rightarrow X_1 \ldots X_n \in P, X_i.a \in A(X_i), 0 \leq i \leq n\rbrace$</span></p>
</li>
</ul>
<h2 id="abgeleitete-und-ererbte-attribute">Abgeleitete und ererbte Attribute</h2>
<p>Die in einer Produktion p definierten Attribute sind</p>
<p><em>AF(p)</em> = 
<span class="math align-center">$\lbrace X_i.a \ \vert\  p : X_0 \rightarrow X_1 \ldots X_n \in P, 0 \leq i \leq n, X_i.a = f(\ldots) \in R(p)\rbrace$</span></p>
<p>Wir betrachten Grammatiken mit zwei disjunkten Teilmengen, den abgeleiteten (synthesized) Attributen <em>AS(X)</em> und den ererbten (inherited) Attributen <em>AI(X)</em>:</p>
<p><em>AS(X)</em> = 
<span class="math align-center">$\lbrace X.a\ \vert \ \exists p : X \rightarrow X_1 \ldots X_n \in P, X.a \in AF(p)\rbrace$</span></p>
<p><em>AI(X)</em> = 
<span class="math align-center">$\lbrace X.a\ \vert \ \exists q : Y \rightarrow uXv \in P, X.a\in AF(q)\rbrace$</span></p>
<p>Abgeleitete Attribute geben Informationen von unten nach oben weiter, geerbte von oben nach unten.</p>
<p>Die Abh√§ngigkeiten der Attribute lassen sich im sog. <em>Abh√§ngigkeitsgraphen</em> darstellen.</p>
<h2 id="beispiel-attributgrammatiken">Beispiel: Attributgrammatiken</h2>
<table>
<thead>
<tr>
<th style="text-align:left">Produktion</th>
<th style="text-align:left">Semantische Regel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>e : e1 '+' t ;</code></td>
<td style="text-align:left"><code>e.val = e1.val + t.val</code></td>
</tr>
<tr>
<td style="text-align:left"><code>e : t ;</code></td>
<td style="text-align:left"><code>e.val = t.val</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t : t1 '*' D ;</code></td>
<td style="text-align:left"><code>t.val = t1.val * D.lexval</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t : D ;</code></td>
<td style="text-align:left"><code>t.val = D.lexval</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">Produktion</th>
<th style="text-align:left">Semantische Regel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>t : D t' ;</code></td>
<td style="text-align:left"><code>t'.inh = D.lexval</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>t.syn = t'.syn</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t' : '*' D t'1 ;</code></td>
<td style="text-align:left"><code>t'1.inh = t'.inh * D.lexval</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>t'.syn = t'1.syn</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t' :</code> 
<span class="math align-center">$\epsilon$</span> <code>;</code></td>
<td style="text-align:left"><code>t'.syn = t'.inh</code></td>
</tr>
</tbody>
</table>
<p>Wenn ein Nichtterminal mehr als einmal in einer Produktion vorkommt, werden die Vorkommen nummeriert. (t, t1; t', t'1)</p>
<h1 id="s-attributgrammatiken-und-l-attributgrammatiken">S-Attributgrammatiken und L-Attributgrammatiken</h1>
<p><em>S-Attributgrammatiken</em>: Grammatiken mit nur abgeleiteten Attributen, lassen sich w√§hrend des Parsens mit LR-Parsern bei beim Reduzieren berechnen mittels Tiefensuche mit Postorder-Evaluation:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">visit</span>(N):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> each child C of N (<span style="color:#f92672">from</span> left to right):
</span></span><span style="display:flex;"><span>        visit(C)
</span></span><span style="display:flex;"><span>    eval(N)     <span style="color:#75715e"># evaluate attributes of N</span></span></span></code></pre></div><p><em>L-Attributgrammatiken</em>: Grammatiken, deren gerbte Atribute nur von einem Elternknoten oder einem linken Geschwisterknoten abh√§ngig sind. Sie k√∂nnen w√§hrend des Parsens mit LL-Parsern berechnet werden. Ein links-nach-rechts-Durchlauf ist ausreichend.</p>
<p>Alle Kanten im Abh√§ngigkeitsgraphen gehen nur von links nach rechts.</p>
<p>S-attributierte SDD sind eine Teilmenge von L-attributierten SDD.</p>
<h2 id="beispiel-s-attributgrammatik">Beispiel: S-Attributgrammatik</h2>
<table>
<thead>
<tr>
<th style="text-align:left">Produktion</th>
<th style="text-align:left">Semantische Regel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>e : e1 '+' t ;</code></td>
<td style="text-align:left"><code>e.val = e1.val + t.val</code></td>
</tr>
<tr>
<td style="text-align:left"><code>e : t ;</code></td>
<td style="text-align:left"><code>e.val = t.val</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t : t1 '*' D ;</code></td>
<td style="text-align:left"><code>t.val = t1.val * D.lexval</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t : D ;</code></td>
<td style="text-align:left"><code>t.val = D.lexval</code></td>
</tr>
</tbody>
</table>
<h2 id="beispiel-annotierter-syntaxbaum-f√ºr-582">Beispiel: Annotierter Syntaxbaum f√ºr <code>5*8+2</code></h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/attribgrammars/annotatedparsetree.png" alt="Annotierter Parse-Tree" width="auto" height="auto">
    <figcaption><p>Annotierter Parse-Tree</p></figcaption>
</figure>
<h2 id="erzeugung-des-ast-aus-dem-parse-tree-f√ºr-582">Erzeugung des AST aus dem Parse-Tree f√ºr <code>5*8+2</code></h2>
<table>
<thead>
<tr>
<th style="text-align:left">Produktion</th>
<th style="text-align:left">Semantische Regel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>e : e1 '+' t ;</code></td>
<td style="text-align:left"><code>e.node = new Node('+', e1.node, t.node)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>e : t ;</code></td>
<td style="text-align:left"><code>e.node = t.node</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t : t1 '*' D ;</code></td>
<td style="text-align:left"><code>t.node = new Node('*', t1.node, new Leaf(D, D.lexval));</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t : D ;</code></td>
<td style="text-align:left"><code>t.node = new Leaf(D, D.lexval);</code></td>
</tr>
</tbody>
</table>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/attribgrammars/ast.png" alt="AST" width="30%" height="auto">
    <figcaption><p>AST</p></figcaption>
</figure>
<h2 id="beispiel-l-attributgrammatik-berechnete-u-geerbte-attribute-ohne-links-rekursion">Beispiel: L-Attributgrammatik, berechnete u. geerbte Attribute, ohne Links-Rekursion</h2>
<p>Teil der vorigen SDD zum Parsen und Berechnen von Ausdr√ºcken wie <code>5*8+2</code>, hier umformuliert ohne Links-Rekursion
und mit berechneten und geerbten Attributen:</p>
<div class='center'>
<table>
<thead>
<tr>
<th style="text-align:left">Produktion</th>
<th style="text-align:left">Semantische Regel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>t : D t' ;</code></td>
<td style="text-align:left"><code>t'.inh = D.lexval</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>t.syn = t'.syn</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t' : '*' D t'1 ;</code></td>
<td style="text-align:left"><code>t'1.inh = t'.inh * D.lexval</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>t'.syn = t'1.syn</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t' :</code> 
<span class="math align-center">$\epsilon$</span> <code>;</code></td>
<td style="text-align:left"><code>t'.syn = t'.inh</code></td>
</tr>
</tbody>
</table>
</div>
<div class='center'>
<div class='columns'>
<div class='column'>
<p><strong><code>5*8</code></strong> =&gt;</p>
</div>
<div class='column'>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/attribgrammars/annotatedparsetree2.png" alt="Annotierter Parse-Tree mit berechneten und geerbten Attributen (nur Multiplikation)" width="auto" height="auto">
    <figcaption><p>Annotierter Parse-Tree mit berechneten und geerbten Attributen (nur Multiplikation)</p></figcaption>
</figure>
</div>
</div>
</div>
<p><em>Vorgriff</em>: Dies ist ein Beispiel f√ºr eine &quot;L-attributierte SDD&quot;.</p>
<h2 id="beispiel-typinferenz-f√ºr-379-oder-helloworld">Beispiel: Typinferenz f√ºr <code>3+7+9</code> oder <code>&quot;hello&quot;+&quot;world&quot;</code></h2>
<table>
<thead>
<tr>
<th style="text-align:left">Produktion</th>
<th style="text-align:left">Semantische Regel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>e : e1 '+' t ;</code></td>
<td style="text-align:left"><code>e.type = f(e1.type, t.type)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>e : t ;</code></td>
<td style="text-align:left"><code>e.type = t.type</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t : NUM ;</code></td>
<td style="text-align:left"><code>t.type = &quot;int&quot;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t : NAME ;</code></td>
<td style="text-align:left"><code>t.type = &quot;string&quot;</code></td>
</tr>
</tbody>
</table>
<h1 id="syntax-gesteuerte-√ºbersetzung-sdt">Syntax-gesteuerte √úbersetzung (SDT)</h1>
<h2 id="erweiterung-attributierter-grammatiken">Erweiterung attributierter Grammatiken</h2>
<p><em>Syntax-directed translation scheme</em>:</p>
<p>Zu den Attributen kommen <strong>Semantische Aktionen</strong>: Code-Fragmente als zus√§tzliche Knoten im Parse Tree an beliebigen Stellen in einer Produktion, die, wenn m√∂glich, w√§hrend des Parsens, ansonsten in weiteren Baumdurchl√§ufen ausgef√ºhrt werden.</p>
<pre><code>e : e1  {print e1.val;}
    '+' {print &quot;+&quot;;}
    t   {e.val = e1.val + t.val; print(e.val);}
  ;
</code></pre>
<h2 id="s-attributierte-sdd-lr-grammatik-bottom-up-parsierbar">S-attributierte SDD, LR-Grammatik: Bottom-Up-Parsierbar</h2>
<p>Die Aktionen werden am Ende jeder Produktion eingef√ºgt (&quot;postfix SDT&quot;).</p>
<table>
<thead>
<tr>
<th style="text-align:left">Produktion</th>
<th style="text-align:left">Semantische Regel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>e : e1 '+' t ;</code></td>
<td style="text-align:left"><code>e.val = e1.val + t.val</code></td>
</tr>
<tr>
<td style="text-align:left"><code>e : t ;</code></td>
<td style="text-align:left"><code>e.val = t.val</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t : t1 '*' D ;</code></td>
<td style="text-align:left"><code>t.val = t1.val * D.lexval</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t : D ;</code></td>
<td style="text-align:left"><code>t.val = D.lexval</code></td>
</tr>
</tbody>
</table>
<pre><code>e : e1 '+' t  {e.val = e1.val + t.val; print(e.val);} ;
e : t         {e.val = t.val;} ;
t : t1 '*' D  {t.val = t1.val * D.lexval;} ;
t : D         {t.val = D.lexval;} ;
</code></pre>
<h2 id="l-attributierte-sdd-ll-grammatik-top-down-parsierbar-12">L-attributierte SDD, LL-Grammatik: Top-Down-Parsierbar (1/2)</h2>
<table>
<thead>
<tr>
<th style="text-align:left">Produktion</th>
<th style="text-align:left">Semantische Regel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>t : D t' ;</code></td>
<td style="text-align:left"><code>t'.inh = D.lexval</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>t.syn = t'.syn</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t' : '*' D t'1 ;</code></td>
<td style="text-align:left"><code>t'1.inh = t'.inh * D.lexval</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>t'.syn = t'1.syn</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t' :</code> 
<span class="math align-center">$\epsilon$</span> <code>;</code></td>
<td style="text-align:left"><code>t'.syn = t'.inh</code></td>
</tr>
</tbody>
</table>
<pre><code>t  : D {t'.inh = D.lexval;} t' {t.syn = t'.syn;} ;
t' : '*' D {t'1.inh = t'.inh * D.lexval;} t'1 {t'.syn = t'1.syn;} ;
t' : e {t'.syn = t'.inh;} ;
</code></pre>
<h2 id="l-attributierte-sdd-ll-grammatik-top-down-parsierbar-22">L-attributierte SDD, LL-Grammatik: Top-Down-Parsierbar (2/2)</h2>
<ul>
<li>
<p>LL-Grammatik: Jede L-attributierte SDD direkt w√§hrend des Top-Down-Parsens implementierbar/berechenbar</p>
</li>
<li>
<p>SDT dazu:</p>
<ul>
<li>Aktionen, die ein berechnetes Attribut des Kopfes einer Produktion berechnen, an das Ende der Produktion anf√ºgen</li>
<li>Aktionen, die geerbte Attribute f√ºr ein Nicht-Terminalsymbol 
<span class="math align-center">$A$</span> berechnen, direkt vor dem Auftreten von 
<span class="math align-center">$A$</span> im K√∂rper der Produktion eingef√ºgen</li>
</ul>
</li>
<li>
<p>Implementierung im rekursiven Abstieg:</p>
<ul>
<li>Geerbte Attribute sind Parameter f√ºr die Funktionen f√ºr die Nicht-Terminalsymbole</li>
<li>berechnete Attribute sind R√ºckgabewerte dieser Funktionen.</li>
</ul>
</li>
</ul>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>T t<span style="color:#960050;background-color:#1e0010">&#39;</span>(T inh) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">match</span>(<span style="color:#e6db74">&#39;*&#39;</span>);
</span></span><span style="display:flex;"><span>    T t1inh <span style="color:#f92672">=</span> inh <span style="color:#f92672">*</span> <span style="color:#a6e22e">match</span>(D);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> t<span style="color:#960050;background-color:#1e0010">&#39;</span>(t1inh);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h1 id="bison-attribute-und-aktionen">Bison: Attribute und Aktionen</h1>
<h2 id="berechnete-synthesized-attribute">Berechnete (<em>synthesized</em>) Attribute</h2>
<pre><code>expr    : expr '+' term     { $$ = $1 + $3; }
        | term
        ;
term    : term '*' DIGIT    { $$ = $1 * $3; }
        | DIGIT
        ;
</code></pre>
<p>Berechnete Attribute sind der Defaultfall in Bison.</p>
<p>Erinnerung:
Keine Typen deklariert:</p>
<ul>
<li>Bison verwendet per Default <code>int</code> f√ºr
alle Symbole (Terminalsymbole (Token) und Regeln).</li>
</ul>
<p>Keine Aktionen an den Regeln angegeben:</p>
<ul>
<li>Bison nutzt die Default-Aktion <code>$$ = $1</code>. Diese
Aktionen werden immer dann ausgef√ºhrt, wenn die rechte Seite der zugeh√∂rigen
Regel/Alternative reduziert werden konnte.</li>
</ul>
<h2 id="geerbte-inherited-attribute-12">Geerbte (<em>inherited</em>) Attribute (1/2)</h2>
<pre><code>functiondecl : returntype fname paramlist ;

returntype  : REAL    { $$ = 1; }
            | INT     { $$ = 2; }
            ;

fname : IDENTIFIER;

paramlist : IDENTIFIER           { mksymbol($0, $-1, $1); }
          | paramlist IDENTIFIER { mksymbol($0, $-1, $2); }
          ;
</code></pre>
<h2 id="geerbte-inherited-attribute-22">Geerbte (<em>inherited</em>) Attribute (2/2)</h2>
<p>Hier:</p>
<ul>
<li>
<p><code>returntype</code> und <code>fname</code> haben normale berechnete Attribute</p>
</li>
<li>
<p><code>paramlist</code>: Funktionsaufruf mit den erzeugten Werte f√ºr <code>returntype</code> und <code>fname</code> als Parameter 
<span class="math align-center">$\Rightarrow$</span> der Wert von <code>paramlist</code> ist ein &quot;geerbtes Attribut&quot;.</p>
</li>
</ul>
<p>Zugriff auf die Werte der Symbole auf dem Stack links vom aktuellen
Symbol: <code>$0</code> ist das erste
Symbol links vom aktuellen (hier <code>type</code>), <code>$-1</code> das zweite (hier <code>class</code>)
usw. ...</p>
<h2 id="probleme-mit-geerbten-attributen">Probleme mit geerbten Attributen</h2>
<pre><code>functiondecl : returntype fname paramlist ;
functiondecl : STRING paramlist ;  /* Autsch! */

...

paramlist : IDENTIFIER           { mksymbol($0, $-1, $1); }
          | paramlist IDENTIFIER { mksymbol($0, $-1, $2); }
          ;
</code></pre>
<p>Wenn vor <code>paramlist</code> ein <code>STRING</code> steht, ist <code>$0</code> der Wert von <code>STRING</code>, nicht <code>fname</code>. Analog
f√ºr <code>$-1</code>, 
<span class="math align-center">$\ldots$</span></p>
<p>Dies ist eine Quelle f√ºr schwer zu findende Bugs!</p>
<h2 id="typen-f√ºr-geerbte-attribute">Typen f√ºr geerbte Attribute</h2>
<pre><code>functiondecl : returntype fname paramlist ;

paramlist : IDENTIFIER           { mksymbol($0, $-1, $1); }
          | paramlist IDENTIFIER { mksymbol($0, $-1, $2); }
          ;
</code></pre>
<p><strong>Achtung</strong>: F√ºr geerbte Attribute funktioniert die Deklaration von Typen
mit <code>%type</code> nicht mehr!</p>
<p>Das Symbol, auf das man sich mit <code>$0</code> bezieht, steht nicht in der Produktion,
sondern im Stack. Bison kann zur Compilezeit nicht den
Typ des referenzierten Symbols bestimmen. Falls
oben die Typen von <code>returntype</code> und <code>fname</code> jeweils <code>rval</code> und <code>fval</code>
w√§ren, m√ºsste man die Aktion manuell wie folgt anpassen:</p>
<pre><code>paramlist : IDENTIFIER           { mksymbol($&lt;fval&gt;0, $&lt;rval&gt;-1, $1); }
          | paramlist IDENTIFIER { mksymbol($&lt;fval&gt;0, $&lt;rval&gt;-1, $2); }
          ;
</code></pre>
<h2 id="bison-und-aktionen">Bison und Aktionen</h2>
<p>Regeln ohne Aktion ganz rechts: die Default-Aktion ist
<code>$$ = $1;</code> (Vorsicht: Die Typen von <code>$$</code> und <code>$1</code> m√ºssen passen!)</p>
<p>Aktionen mitten in einer Regel:</p>
<pre><code>xxx : A { dosomething(); } B ;
</code></pre>
<p>wird √ºbersetzt in:</p>
<pre><code>xxx : A dummy B ;
dummy : /* empty */ { dosomething(); }
</code></pre>
<p>Da nach dem Shiften von <code>A</code> nicht klar ist,
ob diese Regel matcht und <code>dosomething</code> ausgef√ºhrt
werden soll, √ºbersetzt Bison die Regel <code>xxx</code> in zwei Regeln, wobei <code>dosomething()</code> ganz rechts in der Dummy-Regel steht. <code>dummy</code> ist ein normales referenzierbares Symbol.</p>
<h2 id="beispiel">Beispiel:</h2>
<pre><code>xxx : A { $$ = 42; } B C { printf(&quot;%d&quot;, $2); } ;
</code></pre>
<p>=&gt; Hier wird &quot;42&quot; ausgegeben, da mit <code>$2</code> auf den Wert der
eingebetteten Aktion zugegriffen wird.</p>
<p><code>$3</code>: Der Wert von <code>B</code></p>
<p><code>$4</code>: Der Wert von <code>C</code></p>
<h2 id="bison-konflikte-durch-eingebettete-aktionen">Bison: Konflikte durch eingebettete Aktionen</h2>
<pre><code>xxx : a | b ;

a : 'a' 'b' 'a' 'a' ;
b : 'a' 'b' 'a' 'b' ;
</code></pre>
<p>Diese Grammatik ist ohne Konflikte von Bison √ºbersetzbar.</p>
<pre><code>xxx : a | b ;

a : 'a' 'b' { dosomething(); } 'a' 'a' ;
b : 'a' 'b' 'a' 'b' ;
</code></pre>
<p>Nach dem Lesen von &quot;<code>ab</code>&quot; gibt es wegen des identischen Vorschauzeichens
(<code>'a'</code>) einen Shift/Reduce-Konflikt.</p>
<h1 id="wrap-up">Wrap-Up</h1>
<h2 id="wrap-up-1">Wrap-Up</h2>
<ul>
<li>
<p>Die Typinferenz ben√∂tigt Informationen aus der Symboltabelle</p>
</li>
<li>
<p>Einfache semantische Analyse: Attribute und semantische Regeln (SDD)</p>
</li>
<li>
<p>Umsetzung mit SDT: Attribute und eingebettete Aktionen</p>
</li>
<li>
<p>Reihenfolge der Auswertung u.U. schwierig</p>
<p>Bestimmte SDT-Klassen k√∂nnen direkt beim Parsing abgearbeitet werden:</p>
<ul>
<li>S-attributierte SDD, LR-Grammatik: Bottom-Up-Parsierbar</li>
<li>L-attributierte SDD, LL-Grammatik: Top-Down-Parsierbar</li>
</ul>
<p>Ansonsten werden die Attribute und eingebetteten Aktionen in den Parse-Tree, bzw. AST,
integriert und bei einer (sp√§teren) Traversierung abgearbeitet.</p>
</li>
</ul>


    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Kapitel 2.3 und 5</em></li> <li id='id_Levine2009'>[Levine2009] <strong>flex & bison</strong><br>Levine, J., O'Reilly, 2009. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-5961-5597-1' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-5961-5597-1</a>.</li></ul></div>
</div>



    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K2) Konzept der attributierten Grammatiken: Anreicherung mit Attributen und semantischen Regeln</li> <li>(K2) Unterschied zwischen geerbten und berechneten Attributen</li> <li>(K2) Umsetzung von SDD mit Hilfe von SDT</li> <li>(K3) Einfache semantische Analyse mit Hilfe von attributierten Grammatiken</li></ul></div>
</div>



    








<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

          </section>
          </section>
        </div>
      </main>
    </div>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/clipboard.min.js?1697015446" defer></script>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/perfect-scrollbar.min.js?1697015446" defer></script>
    <script>
      function useMathJax( config ){
        if( !Object.assign ){
          
          return;
        }
        window.MathJax = Object.assign( window.MathJax || {}, {
          loader: {
            load: ['[tex]/mhchem']
          },
          startup: {
            elements: [
              '.math'
            ]
          },
          tex: {
            inlineMath: [
              ['$', '$'], 
              ['\\(', '\\)']
            ]
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/mathjax/tex-mml-chtml.js?1697015446"></script>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/theme.js?1697015446" defer></script>
  </body>
</html>
