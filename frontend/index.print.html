<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.119.0">
    <meta name="generator" content="Relearn 5.22.1">
    <meta name="description" content="">
    <meta name="author" content="cagix">
    <title>Frontend</title>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend.html" rel="canonical" type="text/html" title="Frontend">

    
    

    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/images/logo.png?1697015446" rel="icon" type="image/png">

    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fontawesome-all.min.css?1697015446" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fontawesome-all.min.css?1697015446" rel="stylesheet"></noscript>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/nucleus.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/auto-complete.css?1697015446" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/auto-complete.css?1697015446" rel="stylesheet"></noscript>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/perfect-scrollbar.min.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fonts.css?1697015446" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/fonts.css?1697015446" rel="stylesheet"></noscript>
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/theme.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/theme-auto.css?1697015446" rel="stylesheet" id="R-variant-style">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/variant.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/print.css?1697015446" rel="stylesheet" media="print">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/format-print.css?1697015446" rel="stylesheet">
    <link href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/css/ie.css?1697015446" rel="stylesheet">
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/url.js?1697015446"></script>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/variant.js?1697015446"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/index.search.js";
      var root_url="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_Reset_view = 'Reset view';
      window.T_View_reset = 'View reset!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/www.hsbi.de\/elearning\/data\/FH-Bielefeld\/lm_data\/lm_1371719/';
      window.variants && variants.init( [ 'auto', 'zen-light', 'zen-dark', 'relearn-bright', 'relearn-light', 'relearn-dark' ] );
    </script><style type="text/css">

 
.center {
    align-content: center;
    text-align: center;
    margin: auto;
}
.alert {
    color: #ff3333;
}
.bsp {
    padding: 0.05cm;
    border-width: 0.05cm;
    border-style: solid;
    border-color: #ddd;
    background-color: #ddd;
    border-radius: 25px;
    float: right;
}
.cbox {
    padding: 0.2cm;
    border-width: 0.1cm;
    border-style: solid;
    border-color: #4070a0;
    background-color: #f2f2f2;
    margin: auto;
    width: 60%;
    text-align: center;
    overflow: auto;
}
.blueArrow {
    color: #4070a0;
    font-family: "Courier New", "Courier", monospace;
    font-weight: bold;
}
.origin {
    background-color: #ededed;
    font-size: 0.8em;
}
.showme {
    background-color: #ededed;
    font-size: 0.8em;
}


 
.tldr {
    background: #dbe4ed;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.recap {
    
    
   margin: 4px 0px 26px 0px;
}
.bib {
    background: #dbe4ed;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.outcomes {
    background: #d9e9d5;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.quizzes {
    background: #d9e9d5;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.challenges {
    background: #ebe4d6;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
.assignments {
    background: #ebe4d6;
    padding: 12px;
    margin: 4px 0px 26px 0px;
}
h1.tldr, h1.recap, h1.bib, h1.outcomes, h1.quizzes, h1.challenges, h1.assignments {
    padding: 0px;
}


 
.noJsAlert {
    padding: 20px;
    background-color: #f44336;  
    color: white;
    margin-bottom: 15px;
}


 
.embed-video-player {
    position: relative;
    padding-bottom: 56%;
    height: 0;
    overflow: hidden;
}
.youtube-player {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border:0;
}


 
#header-wrapper {
    padding:0.6rem;
}


 
#shortcuts {
    padding-top: 2.0rem;
}


 
#chapter p {
    text-align: left;
}


 
figcaption h4 {
    margin-top:-2.5rem;
}
.border1 {
    border:1px solid black;
}

 
td ul, td ol {
    margin: 0 0 1rem 0.5rem;
    padding: 0 0 0 0.5rem;
}

 
h1 { font-size:2.8rem !important;}
h2 { font-size:2.2rem; margin:1.2rem 0}
h3 { font-size:1.9rem; text-align:left !important; font-weight:400 !important;}
h4 { font-size:1.6rem}
h5 { font-size:1.3rem}
h6 { font-size:1rem}

h2 {
    width:100% !important;
    border-bottom:1px solid #5e5e5e !important;
    padding-bottom: 2px;
}
.tldr h2, .recap h2, .bib h2, .outcomes h2, .quizzes h2, .challenges h2, .assignments h2 {
    margin:0.5rem 0
}

.btn-crossreference, .btn-crossreference:hover {
    cursor: initial;
}

</style>

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide">
              <button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)">
                <i class="fa-fw fas fa-bars"></i>
              </button>
            </div>
          </div>
          <span class="topbar-breadcrumbs highlightable">
            Frontend
          </span>
          <div class="topbar-area topbar-area-end" data-area="end">
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="frontend">Frontend</h1>

<p>Unter dem &quot;Frontend&quot; versteht man die ersten Stufen eines Compilers,
die mit der <strong>Analyse</strong> des Inputs beschäftigt sind. Dies sind in der
Regel der Scanner, der Parser und die semantische Analyse.</p>

<ul class="children children-li children-sort-">
	
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing.html">Lexer</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing.html">Parser</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics.html">Semantische Analyse</a></li>
</ul>

            <footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Frontend</h1>
          <article class="default">
            <header class="headline">
            </header>
<h1 id="lexer">Lexer</h1>

<p>Der Lexer (auch &quot;Scanner&quot;) soll den Zeichenstrom in eine Folge von Token
zerlegen. Zur Spezifikation der Token werden in der Regel reguläre Ausdrücke
verwendet.</p>

<ul class="children children-li children-sort-">
	
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/regular.html">Reguläre Sprachen, Ausdrucksstärke</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table.html">Lexer: Tabellenbasierte Implementierung</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/recursive.html">Lexer: Handcodierte Implementierung</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/antlr-lexing.html">Lexer mit ANTLR generieren</a></li>
</ul>

            <footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Lexer</h1>
<article class="default">
<h1>Reguläre Sprachen, Ausdrucksstärke</h1>



    
    




    
    
        
        
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="far fa-file-powerpoint"></i> Annotierte Folien</div>
  <div class="box-content">

<ul> <li><a href='https://raw.githubusercontent.com/Compiler-CampusMinden/AnnotatedSlides/master/lexing_regular.ann.ma.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Annotierte Folien: Reguläre Sprachen, Ausdrucksstärke</a></li></ul></div>
</div>




    <h1 id="motivation">Motivation</h1>
<h2 id="was-muss-ein-compiler-wohl-als-erstes-tun">Was muss ein Compiler wohl als erstes tun?</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="themen-für-heute">Themen für heute</h2>
<ul>
<li>Endliche Automaten</li>
<li>Reguläre Ausdrücke</li>
</ul>
<h1 id="endliche-automaten">Endliche Automaten</h1>
<h2 id="alphabete">Alphabete</h2>
<p><strong>Def.:</strong> Ein <em>Alphabet</em> 
<span class="math align-center">$\Sigma$</span> ist eine endliche, nicht-leere Menge von Symbolen. Die Symbole eines Alphabets heißen <em>Buchstaben</em>.</p>
<p><strong>Def.:</strong> Ein <em>Wort</em> 
<span class="math align-center">$w$</span> <em>über einem Alphabet</em> 
<span class="math align-center">$\Sigma$</span> ist eine endliche Folge von Symbolen aus 
<span class="math align-center">$\Sigma$</span>.

<span class="math align-center">$\epsilon$</span> ist das leere Wort.
Die <em>Länge</em> 
<span class="math align-center">$\vert w \vert$</span> eines Wortes 
<span class="math align-center">$w$</span> ist die Anzahl von Buchstaben, die es enthält (Kardinalität).</p>
<p><strong>Def.:</strong>

<span class="math align-center">$\Sigma^k = \lbrace w\ \text{über}\ \Sigma\ \vert\ \vert w \vert = k \rbrace$</span></p>
<p>
<span class="math align-center">$\Sigma^{\ast} = \bigcup\limits_{i \in \mathbb{N}_0} \Sigma^i$</span> (die Kleene-Hülle von 
<span class="math align-center">$\Sigma$</span>)</p>

<span class="math align-center">$\Sigma^+ = \bigcup\limits_{i \in \mathbb{N}} \Sigma^i$</span>
<h2 id="sprachen-über-alphabete">Sprachen über Alphabete</h2>
<p><strong>Def.:</strong> Seien 
<span class="math align-center">$x = a_1 a_2 \ \ldots \ a_n$</span> und 
<span class="math align-center">$y = b_1b_2 \  \ldots \  b_m$</span> Wörter. Wir nennen 
<span class="math align-center">$xy = x \circ y = a_1 \  \ldots \  a_nb_1 \ \ldots \ b_m$</span> die <em>Konkatenation</em> von 
<span class="math align-center">$x$</span> und 
<span class="math align-center">$y$</span>.</p>
<p><strong>Def.:</strong> <em>Eine Sprache</em> 
<span class="math align-center">$L$</span> <em>über einem Alphabet</em> 
<span class="math align-center">$\Sigma$</span> ist eine Teilmenge von 
<span class="math align-center">$\Sigma^{\ast} :\ L \subseteq\Sigma^{\ast}$</span></p>
<h2 id="deterministische-endliche-automaten">Deterministische endliche Automaten</h2>
<p><strong>Def.:</strong> Ein <em>deterministischer endlicher Automat</em> (DFA) ist ein 5-Tupel

<span class="math align-center">$A = (Q, \Sigma, \delta, q_0, F)$</span> mit</p>
<ul>
<li>
<span class="math align-center">$Q$</span> : eine endliche Menge von Zuständen</li>
<li>
<span class="math align-center">$\Sigma$</span> : ein Alphabet von Eingabesymbolen</li>
<li>
<span class="math align-center">$\delta$</span> : die Übergangsfunktion 
<span class="math align-center">$(Q \times \Sigma) \rightarrow Q, \delta$</span> kann partiell sein</li>
<li>
<span class="math align-center">$q_0 \in Q$</span> : der Startzustand</li>
<li>
<span class="math align-center">$F \subseteq Q$</span> : die Menge der Endzustände</li>
</ul>
<h2 id="die-übergangsfunktion">Die Übergangsfunktion</h2>
<p><strong>Def.:</strong> Wir definieren 
<span class="math align-center">$\delta^{\ast}: (Q \times \Sigma^{\ast}) \rightarrow Q$</span>: induktiv wie folgt:</p>
<ul>
<li>Basis: 
<span class="math align-center">$\delta^{\ast}(q, \epsilon) = q\ \forall q \in Q$</span></li>
<li>Induktion: 
<span class="math align-center">$\delta^{\ast}(q, a_1, \ldots, a_n) = \delta(\delta^{\ast}(q, a_1, \ldots , a_{n-1}), a_n)$</span></li>
</ul>
<p><strong>Def.:</strong> Ein DFA akzeptiert ein Wort 
<span class="math align-center">$w \in \Sigma^{\ast}$</span> genau dann, wenn 
<span class="math align-center">$\delta^{\ast}(q_0, w) \in F.$</span></p>
<p><strong>Def.:</strong> Die Sprache eines DFA 
<span class="math align-center">$A\ L(A)$</span> ist definiert durch:</p>

<span class="math align-center">$L(A) =\lbrace w\ \vert \delta^{\ast}(q_0, w) \in F \rbrace$</span>
<h2 id="beispiel">Beispiel</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="nichtdeterministische-endliche-automaten">Nichtdeterministische endliche Automaten</h2>
<p><strong>Def.:</strong> Ein <em>nichtdeterministischer endlicher Automat</em> (NFA) ist ein 5-Tupel

<span class="math align-center">$A = (Q, \Sigma, \delta, q_0, F)$</span> mit</p>
<ul>
<li>
<span class="math align-center">$Q$</span>: eine endliche Menge von Zuständen</li>
<li>
<span class="math align-center">$\Sigma$</span>: ein Alphabet von Eingabesymbolen</li>
<li>
<span class="math align-center">$\delta$</span>: die Übergangsfunktion 
<span class="math align-center">$(Q \times \Sigma) \rightarrow \mathcal{P}(Q)$</span></li>
<li>
<span class="math align-center">$q_0 \in Q$</span>: der Startzustand</li>
<li>
<span class="math align-center">$F \subseteq Q$</span>: die Menge der Endzustände</li>
</ul>
<h2 id="die-übergangsfunktion-eines-nfas">Die Übergangsfunktion eines NFAs</h2>
<p><strong>Def.:</strong> Wir definieren 
<span class="math align-center">$\delta^{\ast}: (Q \times \Sigma) \rightarrow \mathcal{P}(Q):$</span>
induktiv wie folgt:</p>
<ul>
<li>
<p>Basis: 
<span class="math align-center">$\delta^{\ast}(q, \epsilon) = q\ \forall q \in Q$</span></p>
</li>
<li>
<p>Induktion: Sei 
<span class="math align-center">$w \in \Sigma^{\ast}, w = xa, x \in \Sigma^{\ast}, a \in \Sigma$</span> mit</p>
<p>
<span class="math align-center">$\delta^{\ast}(q, x) = \lbrace p_1,\ \ldots,\  p_k \rbrace, p_i \in Q$</span>, sei</p>
<p>
<span class="math align-center">$A = \bigcup\limits_{i = 1}^k \delta(p_i, a) = \lbrace r_1, \ldots r_m \rbrace, r_j \in Q$</span>.</p>
<p>Dann ist 
<span class="math align-center">$\delta^{\ast}(q, w) = \lbrace r_1,\  \ldots\ , r_m\rbrace$</span>.</p>
</li>
</ul>
<h2 id="wozu-nfas-im-compilerbau">Wozu NFAs im Compilerbau?</h2>
<p>Pattern Matching geht mit NFAs.</p>
<p>NFAs sind so nicht zu programmieren, aber:</p>
<p><strong>Satz:</strong> Eine Sprache 
<span class="math align-center">$L$</span> wird von einem NFA akzeptiert 
<span class="math align-center">$\Leftrightarrow L$</span> wird von einem DFA akzeptiert.</p>
<h2 id="konvertierung-eines-nfas-in-einen-dfa">Konvertierung eines NFAs in einen DFA</h2>
<p>Gegeben: Ein NFA 
<span class="math align-center">$A = (Q, \Sigma, \delta, q_0, F)$</span></p>
<p>Wir konstruieren einen DFA 
<span class="math align-center">$A' = (Q', \Sigma, \delta ', q_0, F')$</span> wie folgt:</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/regular/nfa2dfa.png" alt="Konvertierung NFA in DFA" width="45%" height="auto">
    <figcaption><p>Konvertierung NFA in DFA</p></figcaption>
</figure>
<h2 id="beispiel-1">Beispiel</h2>
<table>
<thead>
<tr>
<th style="text-align:right">
<span class="math align-center">$\delta$</span></th>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">
<span class="math align-center">$\rightarrow q_0$</span></td>
<td style="text-align:center">
<span class="math align-center">$\lbrace q_0\rbrace$</span></td>
<td style="text-align:center">
<span class="math align-center">$\lbrace q_1, q_2\rbrace$</span></td>
</tr>
<tr>
<td style="text-align:right">
<span class="math align-center">$q_1$</span></td>
<td style="text-align:center">
<span class="math align-center">$\lbrace q_2\rbrace$</span></td>
<td style="text-align:center">
<span class="math align-center">$\lbrace q_1\rbrace$</span></td>
</tr>
<tr>
<td style="text-align:right">*
<span class="math align-center">$q_2$</span></td>
<td style="text-align:center">-</td>
<td style="text-align:center">
<span class="math align-center">$\lbrace q_0, q_2\rbrace$</span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">
<span class="math align-center">$\delta$</span>'</th>
<th style="text-align:left">a</th>
<th style="text-align:left">b</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">
<span class="math align-center">$\rightarrow$</span> 
<span class="math align-center">$\lbrace q_0\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_1,q_2\rbrace$</span></td>
</tr>
<tr>
<td style="text-align:left">*
<span class="math align-center">$\lbrace q_1 q_2\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_2\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0, q_1, q_2\rbrace$</span></td>
</tr>
<tr>
<td style="text-align:left">*
<span class="math align-center">$\lbrace q_2\rbrace$</span></td>
<td style="text-align:left">-</td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0,q_2\rbrace$</span></td>
</tr>
<tr>
<td style="text-align:left">*
<span class="math align-center">$\lbrace q_0, q_2\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0, q_1, q_2\rbrace$</span></td>
</tr>
<tr>
<td style="text-align:left">*
<span class="math align-center">$\lbrace q_0, q_1, q_2\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0, q_2\rbrace$</span></td>
<td style="text-align:left">
<span class="math align-center">$\lbrace q_0, q_1, q_2\rbrace$</span></td>
</tr>
</tbody>
</table>
<h2 id="minimierung-eines-dfas">Minimierung eines DFAs</h2>
<p>Ist ist der DFA 
<span class="math align-center">$A$</span> nicht vollständig, wird ein Fehlerzustand 
<span class="math align-center">$q_e$</span>, der kein Endzustand ist, hinzugefügt und in alle leeren Tabellenfelder eingetragen.</p>
<p>Dann wird eine Matrix generiert, die für alle Zustandspaare sagt, ob die beiden Zustände zu einem verschmelzen können.</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/regular/minimize_dfa.png" alt="DFA Minimierung" width="50%" height="auto">
    <figcaption><p>DFA Minimierung</p></figcaption>
</figure>
<h1 id="reguläre-ausdrücke">Reguläre Ausdrücke</h1>
<h2 id="operatoren-auf-sprachen">Operatoren auf Sprachen</h2>
<p><strong>Def.:</strong> Seien <em>L</em> und <em>M</em> Sprachen.</p>
<ul>
<li>
<span class="math align-center">$L \cup M = \lbrace w \mid w \in L \vee w \in M \rbrace$</span></li>
<li>
<span class="math align-center">$LM = L \cdot M = L \circ M = \lbrace vw \mid v \in L \land w \in M\rbrace$</span></li>
<li>Die Kleene-Hülle einer Sprache:
<ul>
<li>Basis: 
<span class="math align-center">$L^0 = \lbrace \epsilon\rbrace$</span></li>
<li>Induktion: 
<span class="math align-center">$L^i = \lbrace xw\mid x \in L^{i-1}, w \in L, i > 0\rbrace$</span>, 
<span class="math align-center">$L^{\ast} = \bigcup\limits_{i \ge 0}L^i$</span>, 
<span class="math align-center">$L^+ = \bigcup\limits_{i > 0}L^i$</span></li>
</ul>
</li>
</ul>
<h2 id="reguläre-ausdrücke-1">Reguläre Ausdrücke</h2>
<p><strong>Def.:</strong> Induktive Definition von regulären Ausdrücken (<em>regex</em>) und der von ihnen repräsentierten Sprache:</p>
<ul>
<li>Basis:
<ul>
<li>
<span class="math align-center">$\epsilon$</span> und 
<span class="math align-center">$\emptyset$</span> sind reguläre Ausdrücke mit 
<span class="math align-center">$L(\epsilon) =  \lbrace \epsilon\rbrace$</span>, 
<span class="math align-center">$L(\emptyset)=\emptyset$</span></li>
<li>Sei 
<span class="math align-center">$a$</span> ein Symbol 
<span class="math align-center">$\Rightarrow$</span> 
<span class="math align-center">$a$</span> ist ein regex mit 
<span class="math align-center">$L(a) = \lbrace a\rbrace$</span></li>
</ul>
</li>
<li>Induktion: Seien 
<span class="math align-center">$E,\ F$</span> reguläre Ausdrücke. Dann gilt:
<ul>
<li>
<span class="math align-center">$E+F$</span> ist ein regex und bezeichnet die Vereinigung 
<span class="math align-center">$L(E + F) = L(E)\cup L(F)$</span></li>
<li>
<span class="math align-center">$EF$</span> ist ein regex und bezeichnet die Konkatenation 
<span class="math align-center">$L(EF) = L(E)L(F)$</span></li>
<li>
<span class="math align-center">$E^{\ast}$</span> ist ein regex und bezeichnet die Kleene-Hülle 
<span class="math align-center">$L(E^{\ast})=(L(E))^{\ast}$</span></li>
<li>
<span class="math align-center">$(E)$</span> ist ein regex mit 
<span class="math align-center">$L((E)) = L(E)$</span></li>
</ul>
</li>
</ul>
<p>Vorrangregeln der Operatoren für reguläre Ausdrücke: *, Konkatenation, +</p>
<h2 id="wichtige-identitäten">Wichtige Identitäten</h2>
<p><strong>Satz:</strong> Sei 
<span class="math align-center">$A$</span> ein DFA 
<span class="math align-center">$\Rightarrow \exists$</span> regex 
<span class="math align-center">$R$</span> mit 
<span class="math align-center">$L(A) = L(R)$</span>.</p>
<p><strong>Satz:</strong> Sei 
<span class="math align-center">$E$</span> ein regex 
<span class="math align-center">$\Rightarrow \exists$</span> DFA 
<span class="math align-center">$A$</span> mit 
<span class="math align-center">$L(E) = L(A)$</span>.</p>
<h2 id="beispiel-umwandlung-eines-regex-in-einen-nfa">Beispiel: Umwandlung eines regex in einen NFA</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="formale-grammatiken">Formale Grammatiken</h2>
<p><strong>Def.:</strong> Eine <em>formale Grammatik</em> ist ein 4-Tupel 
<span class="math align-center">$G=(N,T,P,S)$</span> aus</p>
<ul>
<li>
<span class="math align-center">$N$</span>: einer endlichen Menge von 
<span class="math align-center">$Nichtterminalen$</span></li>
<li><em>T</em>: einer endlichen Menge von <em>Terminalen</em>, 
<span class="math align-center">$N \cap T = \emptyset$</span></li>
<li>
<span class="math align-center">$S \in N$</span>: dem <em>Startsymbol</em></li>
<li><em>P</em>: einer endlichen Menge von <em>Produktionen</em> der Form: 
<span class="math align-center">$X \rightarrow Y$</span> mit 
<span class="math align-center">$X \in (N \cup T)^{\ast} N (N \cup T)^{\ast}, Y \in (N \cup T)^{\ast}$</span></li>
</ul>
<h2 id="ableitungen">Ableitungen</h2>
<p><strong>Def.:</strong> Sei 
<span class="math align-center">$G = (N, T, P, S)$</span> eine Grammatik, sei 
<span class="math align-center">$\alpha A \beta$</span> eine Zeichenkette über

<span class="math align-center">$(N \cup T)^{\ast}$</span> und sei 
<span class="math align-center">$A$</span> 
<span class="math align-center">$\rightarrow \gamma$</span> eine Produktion von 
<span class="math align-center">$G$</span>.</p>
<p>Wir sagen:

<span class="math align-center">$\alpha A \beta \Rightarrow \alpha \gamma \beta$</span> (
<span class="math align-center">$\alpha A \beta$</span> leitet 
<span class="math align-center">$\alpha \gamma \beta$</span> ab).</p>
<p><strong>Def.:</strong> Wir definieren die Relation 
<span class="math align-center">$\overset{\ast}{\Rightarrow}$</span> induktiv wie folgt:</p>
<ul>
<li>Basis: 
<span class="math align-center">$\forall \alpha \in (N \cup T)^{\ast} \alpha \overset{\ast}{\Rightarrow} \alpha$</span> (Jede Zeichenkette leitet sich selbst ab.)</li>
<li>Induktion: Wenn 
<span class="math align-center">$\alpha \overset{\ast}{\Rightarrow} \beta$</span> und

<span class="math align-center">$\beta\Rightarrow \gamma$</span> dann 
<span class="math align-center">$\alpha \overset{\ast}{\Rightarrow} \gamma$</span></li>
</ul>
<p><strong>Def.:</strong> Sei 
<span class="math align-center">$G = (N, T ,P, S)$</span> eine formale Grammatik.
Dann ist 
<span class="math align-center">$L(G) = \lbrace w \in T^{\ast} \mid S \overset{\ast}{\Rightarrow} w\rbrace$</span> die von 
<span class="math align-center">$G$</span> erzeugte Sprache.</p>
<h2 id="reguläre-grammatiken">Reguläre Grammatiken</h2>
<p><strong>Def.:</strong> Eine <em>reguläre (oder type-3-) Grammatik</em> ist eine formale Grammatik mit den folgenden Einschränkungen:</p>
<ul>
<li>
<p>Alle Produktionen sind entweder von der Form</p>
<ul>
<li>
<span class="math align-center">$X \to aY$</span> mit 
<span class="math align-center">$X \in N, a \in T, Y \in N$</span> (<em>rechtsreguläre</em> Grammatik) oder</li>
<li>
<span class="math align-center">$X \to Ya$</span> mit 
<span class="math align-center">$X \in N, a \in T, Y \in N$</span> (<em>linksreguläre</em> Grammatik)</li>
</ul>
</li>
<li>
<p>
<span class="math align-center">$X\rightarrow\epsilon$</span> ist in beiden Fällen erlaubt.</p>
</li>
</ul>
<h2 id="reguläre-sprachen">Reguläre Sprachen</h2>
<p><strong>Satz:</strong> Die von rechtsregulären Grammatiken erzeugten Sprachen sind genau die von linksregulären Grammatiken erzeugten Sprachen. Beide werden <em>reguläre</em> Sprachen genannt.</p>
<p><strong>Satz:</strong> Die von regulären Ausdrücken beschriebenen Sprachen sind die regulären Sprachen.</p>
<h2 id="das-pumping-lemma-für-reguläre-sprachen">Das Pumping Lemma für reguläre Sprachen</h2>
<p><strong>Satz:</strong> Das <em>Pumping Lemma für reguläre Sprachen</em>:</p>
<p>Sei 
<span class="math align-center">$L$</span> eine reguläre Sprache.</p>
<p>
<span class="math align-center">$\Rightarrow \exists$</span> Konstante 
<span class="math align-center">$n \in \mathbb{N}$</span>:</p>
<p>
<span class="math align-center">$\underset{\underset{|w| \geq n} {w \in L}}\forall \exists x, y, z \in \Sigma^{*}$</span> mit 
<span class="math align-center">$w = xyz, y \neq \epsilon, |xy| \leq n:$</span></p>

<span class="math align-center">$\underset{k \geq 0} \forall xy^{k}z \in L$</span>
<h2 id="abschlusseigenschaften-regulärer-sprachen">Abschlusseigenschaften regulärer Sprachen</h2>
<p>Die Klasse der regulären Sprachen ist abgeschlossen unter</p>
<ul>
<li>Vereinigung</li>
<li>Konkatenation</li>
<li>Kleene-Stern</li>
<li>Komplementbildung</li>
<li>Durchschnitt</li>
</ul>
<h2 id="entscheidbarkeit-für-reguläre-sprachen">Entscheidbarkeit für reguläre Sprachen</h2>
<p><strong>Satz:</strong> Es ist entscheidbar,</p>
<ul>
<li>ob eine gegebene reguläre Sprache leer ist</li>
<li>ob 
<span class="math align-center">$w \in \Sigma^{\ast}$</span> in einer gegebenen regulären Sprache enthalten ist (Das &quot;Wort-Problem&quot;)</li>
<li>ob zwei reguläre Sprachen äquivalent sind</li>
</ul>
<h2 id="grenzen-der-regulären-sprachen">Grenzen der regulären Sprachen</h2>
<p>Reguläre Sprachen sind von ihrer Struktur her einfach. Schon Sprachen, in denen etwas &quot;gematcht&quot; werden muss, lassen sich nicht mehr regulär beschreiben, weil z. B. die fixe Anzahl von Zuständen eines DFAs die Erkennung solcher Sprachen verhindert.</p>
<h2 id="wozu-das-ganze">Wozu das Ganze?</h2>
<p>Im Compilerbau werden reguläre Ausdrücke benutzt, um die Schlüsselwörter und weitere Symbole der zu erkennenden Sprache anzugeben. Daraus wird mit Hilfe eines Generators, der aus den regulären Ausdrücken DFAs (oder einen großen DFA) macht, der sog. Scanner oder Lexer genannt, generiert. Seine Aufgabe ist es, die Folge von Zeichen in der Quelldatei in eine Folge von sog. Token umzuwandeln. Z. B. wird so aus den Zeichen des Schlüsselwortes <em>while</em> im Programmtext das Token für <em>while</em> gemacht, das in der Syntaxanalyse weiterverarbeitet wird. Die Tokenfolge eines Programms ist ein Wort einer Sprache, die der Parser erkennt. Jedes vom Lexer erkannte Token ist dort also ein terminales Symbol.</p>
<h2 id="ein-lexer-ist-mehr-als-ein-dfa">Ein Lexer ist mehr als ein DFA</h2>
<p>Was ist zu beachten:</p>
<ul>
<li>Man braucht mindestens eine Liste von Paaren aus regulären Ausdrücken und Tokennamen.</li>
<li>Neben den Schlüsselwörtern und Symbolen wie (,), *, 
<span class="math align-center">$\ldots$</span> müssen auch Namen für Variablen, Funktionen, Klassen, Methoden, 
<span class="math align-center">$\ldots$</span> (sog. Identifier) erkannt werden</li>
<li>Namen haben meist eine gewisse Struktur, die sich mit regulären Ausdrücken beschreiben lassen.</li>
<li>Erlaubte Token sind in der Grammatik des Parsers beschrieben, d. h. für literale Namen, Strings, Zahlen liefert der Scanner zwei Werte:
<ul>
<li>z.  B. <code>&lt;ID, &quot;radius&quot;&gt;</code>, <code>&lt;Integerzahl, 558&gt;</code></li>
</ul>
</li>
<li>Kommentare und Strings müssen richtig erkannt werden. (Schachtelungen)</li>
</ul>
<p>Man kann natürlich auch einen Lexer selbst programmieren, d. h. die DFAs für die regulären Ausdrücke implementieren.</p>
<h2 id="automatisch-oder-händisch">Automatisch oder händisch</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h1 id="wrap-up">Wrap-Up</h1>
<h2 id="wrap-up-1">Wrap-Up</h2>
<ul>
<li>Definition und Aufgaben von Lexern</li>
<li>DFAs und NFAs</li>
<li>Reguläre Ausdrücke</li>
<li>Reguläre Grammatiken</li>
<li>Zusammenhänge zwischen diesen Mechanismen und Lexern, bzw. Lexergeneratoren</li>
</ul>


    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_aho2013compilers'>[aho2013compilers] <strong>Compilers: Pearson New International Edition: Principles, Techniques, and Tools</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Education Limited, 2013. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-2920-3723-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-2920-3723-3</a>.<br><em>Abschnitt 2.6 und Kapitel 3</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li> <li id='id_Torczon2012'>[Torczon2012] <strong>Engineering a Compiler</strong><br>Torczon, L. und Cooper, K., Elsevier MK, 2012. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-1208-8478-0' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-1208-8478-0</a>.<br><em>Kapitel 2</em></li></ul></div>
</div>



    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) DFAs</li> <li>(K1) NFAs</li> <li>(K1) Reguläre Ausdrücke</li> <li>(K1) Reguläre Grammatiken</li> <li>(K2) Zusammenhänge und Gesetzmäßigkeiten bzgl. der oben genannten Konstrukte</li> <li>(K3) DFAs, NFAs, reguläre Ausdrücke, reguläre Grammatiken entwickeln</li> <li>(K3) Herausfinden, ob eine Sprache regulär ist</li> <li>(K3) Einen DFA entwickeln, der alle Schlüsselwörter, Namen und weitere Symbole einer Programmiersprache akzeptiert</li></ul></div>
</div>



    








<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Lexer: Tabellenbasierte Implementierung</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p><a href="#R-image-e2a9b91052dcc8e8aae5a97d143716b9" class="lightbox-link"><img src="images/architektur_cb_lexer.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e2a9b91052dcc8e8aae5a97d143716b9"><img src="images/architektur_cb_lexer.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Der Lexer (auch &quot;Scanner&quot;) soll den Zeichenstrom in eine Folge von Token
zerlegen. Zur Spezifikation der Token werden reguläre Ausdrücke verwendet.
Diese können über verschiedene Schritte in einen zugehörigen DFA transformiert
werden, der wiederum über Tabellen dargestellt werden kann (vgl. auch
<a href="regular.md">Reguläre Sprachen, Ausdrucksstärke</a>).</p>
<p>Mit Hilfe der (üblicherweise von Scanner-Generatoren generierten) Tabellen kann
ein Lexer implementiert werden (&quot;tabellenbasierte Implementierung&quot;). Zur Steigerung
der Effizienz kann die Tabelle in den Code integriert werden (etwa mit Sprungbefehlen,
&quot;direkt codierte Implementierung&quot;). Diese Lexer sind nur schwer nachvollziehbar und
werden üblicherweise generiert (vgl. <a href="flex.md">Flex</a>
und <a href="antlr.md">ANTLR</a>).</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/2GeEaU3qB6c' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Tabellenbasierte Scanner</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/36f62768351b19aa6453c819afa64cf2cc9ac698d3cf29137f3c7a5aeb5229de7c1102b8cf87981c27cbc1b250f03f1572e690dc96fb69e89a982f8200d54eb2' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Tabellenbasierte Scanner</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) Aufgaben eines Lexers</li> <li>(K2) Erkennen von Lexemen mit RE und DFA</li> <li>(K2) DFA-nahe Implementierung: Tabellenbasiert und direkt codiert</li></ul></div>
</div>




    <h2 id="lexer-erzeugen-eines-token-stroms-aus-einem-zeichenstrom">Lexer: Erzeugen eines Token-Stroms aus einem Zeichenstrom</h2>
<p>Aus dem Eingabe(-quell-)text</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* demo */</span>
</span></span><span style="display:flex;"><span>a<span style="color:#f92672">=</span> [<span style="color:#ae81ff">5</span>  , <span style="color:#ae81ff">6</span>]     ;</span></span></code></pre></div><p>erstellt der Lexer (oder auch Scanner genannt) eine Sequenz von Token:</p>
<pre><code>&lt;ID, &quot;a&quot;&gt; &lt;ASSIGN&gt; &lt;LBRACK&gt; &lt;NUM, 5&gt; &lt;COMMA&gt; &lt;NUM, 6&gt; &lt;RBRACK&gt; &lt;SEMICOL&gt;
</code></pre>
<ul>
<li>Input: Zeichenstrom (Eingabedatei o.ä.)</li>
<li>Verarbeitung: Finden sinnvoller Sequenzen im Zeichenstrom (&quot;Lexeme&quot;),
Einteilung in Kategorien und Erzeugen von Token (Paare: Typ/Name, Wert)</li>
<li>Ausgabe: Tokenstrom</li>
</ul>
<p>Normalerweise werden für spätere Phasen unwichtige Elemente wie White-Space
oder Kommentare entfernt.</p>
<p>Durch diese Vorverarbeitung wird eine höhere Abstraktionsstufe erreicht und es
können erste grobe Fehler gefunden werden. Dadurch kann der Parser auf einer
abstrakteren Stufe arbeiten und muss nicht mehr den gesamten ursprünglichen
Zeichenstrom verarbeiten.</p>
<p><em>Anmerkung</em>: In dieser Phase steht die Geschwindigkeit stark im Vordergrund:
Der Lexer &quot;sieht&quot; <em>alle</em> Zeichen im Input. Deshalb findet man häufig von
Hand kodierte Lexer, obwohl die Erstellung der Lexer auch durch Generatoren
erledigt werden könnte ...</p>
<p><em>Anmerkung</em>: Die Token sind die Terminalsymbole in den Parserregeln (Grammatik).</p>
<h2 id="definition-wichtiger-begriffe">Definition wichtiger Begriffe</h2>
<ul>
<li>
<p><strong>Token</strong>: Tupel (Tokenname, optional: Wert)</p>
<p>Der Tokenname ist ein abstraktes Symbol, welches eine lexikalische
Einheit repräsentiert (Kategorie). Die Tokennamen sind die Eingabesymbole
für den Parser.</p>
<p>Token werden i.d.R. einfach über ihren Namen referenziert. Token werden
häufig zur Unterscheidung von anderen Symbolen in der Grammatik in
Fettschrift oder mit großen Anfangsbuchstaben geschrieben.</p>
<p>Ein Token kann einen Wert haben, etwa eine Zahl oder einen Bezeichner, der
auf das zum Token gehörende Pattern gematcht hatte (also das Lexem). Wenn
der Wert des Tokens eindeutig über den Namen bestimmt ist (im Beispiel oben
beim Komma oder den Klammern), dann wird häufig auf den Wert verzichtet.</p>
</li>
<li>
<p><strong>Lexeme</strong>: Sequenz von Zeichen im Eingabestrom, die auf ein Tokenpattern
matcht und vom Lexer als Instanz dieses Tokens identifiziert wird.</p>
</li>
<li>
<p><strong>Pattern</strong>: Beschreibung der Form eines Lexems</p>
<p>Bei Schlüsselwörtern oder Klammern etc. sind dies die Schlüsselwörter oder
Klammern selbst. Bei Zahlen oder Bezeichnern (Namen) werden i.d.R.
reguläre Ausdrücke zur Beschreibung der Form des Lexems formuliert.</p>
</li>
</ul>
<h2 id="erkennung-mit-re-und-dfa">Erkennung mit RE und DFA</h2>
<p><a href="#R-image-1db52d4f058a4ce1ca850c1b226f554a" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table/lexer.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1db52d4f058a4ce1ca850c1b226f554a"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table/lexer.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Die obige Skizze ist eine Kurzzusammenfassung der Theorie-Vorlesung in der
letzten Woche und stellt die Verbindung zur heutigen Vorlesung her:</p>
<p>Die Lexeme werden mit Hilfe von <em>DFA</em> bestimmt. Die Formulierung der DFA ist
eher komplex (zumindest sehr umständlich), weshalb man die Pattern für die
Lexeme ersatzweise mit Hilfe von <em>Regulären Ausdrücken</em> (&quot;<em>RE</em>&quot;) formuliert.</p>
<p>Mit Hilfe der <em>Thompson's Construction</em> kann man diese in äquivalente <em>NFA</em>
umformen. Über die <em>Subset Construction</em> kann man daraus <em>DFA</em> erzeugen, die
wiederum mit Hilfe des <em>Hopcroft's Algorithm</em> minimiert werden.</p>
<p>Diese DFA erkennen die selbe Sprache wie die ursprünglichen REs. Man könnte
also durch Simulation der DFA die Lexeme erkennen und die Token bilden. Dabei
würde pro Eingabezeichen ein Übergang im DFA stattfinden und bei Erreichen
eines akzeptierenden Zustandes hätte man das durch diesen DFA (bzw. dessen
ursprünglichen RE) beschriebene Lexem identifiziert.</p>
<p>Falls mehrere REs matchen, muss man in geeigneter Weise entscheiden. I.d.R.
nimmt man den längsten Match. Zusätzlich wird eine Reihenfolge unter den REs
festgelegt, um bei mehreren gleich langen Matches ein Token bestimmen zu
können.</p>
<p>In der Praxis werden die DFA als Ausgangspunkt für die Implementierung des
Lexers genutzt (ob nun bei einer &quot;handgeklöppelten&quot; Implementierung oder beim
Einsatz eines Lexer-Generators). Als typische Implementierungsansätze sollen
nachfolgend die <em>tabellenbasierte Implementierung</em> sowie als etwas schnellere
Variante die <em>direkt codierte Implementierung</em> betrachtet werden. Während diese
beiden Varianten noch sehr nah an der Simulation eines DFA sind, ist die
<em>manuelle Implementierung</em>
(vgl. <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/recursive.html">Handcodierte Implementierung</a>)
noch einfacher in bestehenden Code zu integrieren (zum Preis einer erschwerten
Änderbarkeit).</p>
<p>Über die <em>Kleene's Construction</em> könnte man aus den DFA wieder <em>RE</em> erzeugen
und damit den Kreis schließen :-)</p>
<h2 id="erkennen-von-zeichenketten-für-strickmuster-10lrl">Erkennen von Zeichenketten für Strickmuster: &quot;10LRL&quot;</h2>
<p><a href="#R-image-be7471b035ffd747f99f5544e0027856" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table/dfa.png?width=45%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 45%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-be7471b035ffd747f99f5544e0027856"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table/dfa.png?width=45%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>DFA zur Erkennung von Strickanweisungen: Das erste Zeichen muss ein
Digit im Bereich 1..9 sein, gefolgt von weiteren Digits, gefolgt von
einer Anweisung für linke Maschen (&quot;L&quot;) oder rechte Maschen (&quot;R&quot;).</p>
<p>Ein passender regulärer Ausdruck dafür wäre &quot;<code>[1-9][0-9]*[LR]+</code>&quot;.</p>
<p>Die Eingabezeichen werden in relevante Kategorien sortiert. Dabei
werden nur die für die Aufgabe interessanten Zeichen (&quot;R&quot; bzw. &quot;L&quot;
und die Ziffern) einer konkreten Kategorie zugewiesen, der Rest wird
als &quot;<code>*</code>&quot; zusammengefasst.</p>
<p><a href="#R-image-15ea178d11834126f705c0d03f47faac" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table/delta.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-15ea178d11834126f705c0d03f47faac"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/table/delta.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Für jeden Zustand wird in der Tabelle vermerkt, in welchen Folgezustand beim
Auftreten eines Zeichens einer bestimmten Kategorie gewechselt werden soll.
Dies ist eine alternative Darstellung des DFA in der obigen Darstellung.</p>
<p>Die Zustände des DFA werden den Tokentypen zugeordnet. Alle Zustände außer
&quot;<code>s2</code>&quot; entsprechen keinem gültigen Token, dies könnte man etwa als Token-Typ
&quot;<code>invalid</code>&quot; realisieren.</p>
<p><em>Anmerkung</em>: &quot;<code>se</code>&quot; ist ein Fehlerzustand, der im Automaten oben nicht
dargestellt ist und der dazu dient, falsche Zeichen zu erkennen und
entsprechend zu antworten.</p>
<h2 id="tabellenbasierte-implementierung">Tabellenbasierte Implementierung</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">nextToken</span>():
</span></span><span style="display:flex;"><span>    state <span style="color:#f92672">=</span> s0; lexeme <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>; stack <span style="color:#f92672">=</span> Stack()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (state <span style="color:#f92672">!=</span> se):
</span></span><span style="display:flex;"><span>        consume()       <span style="color:#75715e"># hole nächstes Zeichen (peek)</span>
</span></span><span style="display:flex;"><span>        lexeme <span style="color:#f92672">+=</span> peek
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">.</span>push(state)
</span></span><span style="display:flex;"><span>        state <span style="color:#f92672">=</span> TransitionTable[state, peek]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (state <span style="color:#f92672">!=</span> s2 <span style="color:#f92672">and</span> stack<span style="color:#f92672">.</span>notEmpty()):
</span></span><span style="display:flex;"><span>        state <span style="color:#f92672">=</span> stack<span style="color:#f92672">.</span>pop(); putBack(lexeme<span style="color:#f92672">.</span>truncate())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> state <span style="color:#f92672">==</span> s2: <span style="color:#66d9ef">return</span> s2(lexeme)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: <span style="color:#66d9ef">return</span> invalid()</span></span></code></pre></div><p>Der dargestellte Code implementiert direkt den DFA zur Erkennung von
Register-Namen unter Nutzung der Tabellen aus dem letzten Abschnitt.</p>
<p>Die Funktion <code>consume()</code> &quot;verbraucht&quot; das aktuelle Zeichen &quot;<code>peek</code>&quot; und
holt das nächste Zeichen aus dem Eingabestrom:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">consume</span>():
</span></span><span style="display:flex;"><span>    peek <span style="color:#f92672">=</span> nextChar()</span></span></code></pre></div><p>Nach einer Initialisierung wird in der Hauptschleife nach dem nächsten
Zeichen im Eingabestrom gefragt und das Lexem erweitert. Anschließend
wird der aktuelle Zustand auf dem Stack gesichert und mit Hilfe der
Transitionstabelle und des aktuellen Zustands sowie des aktuellen Zeichens
<code>peek</code> der Folgezustand bestimmt. Sobald der Fehlerzustand &quot;<code>se</code>&quot; erreicht
wird, bricht die Schleife ab.</p>
<p><em>Anmerkung</em>: Wenn wir in &quot;<code>s2</code>&quot; sind, wird so lange nach weiteren Buchstaben
&quot;L&quot; oder &quot;R&quot; gesucht, bis im Strom irgendetwas anderes auftaucht und wir
entsprechend in &quot;<code>se</code>&quot; landen.</p>
<p>In der zweiten Schleife wird der Stack aufgerollt, um zu schauen, ob wir
früher bereits in &quot;<code>s2</code>&quot; waren oder nicht. Das erste Element wird vom Stack
genommen, das Lexem wird um das letzte Zeichen gekürzt und dieses letzte
Zeichen wird mit <code>putBack()</code> in den Eingabestrom zurückgelegt. Falls wir
früher bereits in &quot;<code>s2</code>&quot; waren, wird dieser Zustand irgendwann vom Stack
genommen. Anderenfalls ist der Stack irgendwann leer.</p>
<p>Falls &quot;<code>s2</code>&quot; erreicht wurde, wird ein neues &quot;<code>s2</code>&quot;-Token generiert und das
Lexem wird als Attribut direkt gesetzt. Anderenfalls lag ein Fehler vor.</p>
<p><em>Anmerkung</em>: Diese Implementierung ist generisch: Wenn man im Code die
direkte Nennung des akzeptierenden Zustands &quot;<code>s2</code>&quot; durch einen Vergleich
mit einer Menge aller akzeptierender Zustände ersetzt (&quot;<code>state == s2</code>&quot;
=&gt; &quot;<code>state in acceptedStates</code>&quot;), bestimmen nur die Tabellen die
konkrete Funktionsweise.</p>
<p>Die Tabellen können allerdings schnell sehr groß werden, insbesondere
die Zustandsübergangstabelle!</p>
<h2 id="direkt-codierte-implementierung">Direkt codierte Implementierung</h2>
<p>Die Implementierung über die Tabellen ist sowohl generisch als auch effizient.
Allerdings kostet jeder Zugriff auf die Tabelle konstanten Aufwand (Erinnerung:
Zugriff auf Arrays, Pointerarithmetik), der sich in der Praxis deutlich
summieren kann. Außerdem müssen der Stack gepflegt (erweitert und später wieder
reduziert) werden und Objekte für die Zustände angelegt werden.</p>
<p>Die Lösung: Aufrollen der <code>while</code>-Schleife und direkt Umsetzung der Tabelle im
Code mit Sprungbefehlen (&quot;<code>goto</code>&quot;):</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">nextToken</span>():
</span></span><span style="display:flex;"><span>    lexeme <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>; stack <span style="color:#f92672">=</span> Stack()
</span></span><span style="display:flex;"><span>    goto s0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>s0:
</span></span><span style="display:flex;"><span>    consume()       <span style="color:#75715e"># hole nächstes Zeichen (peek)</span>
</span></span><span style="display:flex;"><span>    lexeme <span style="color:#f92672">+=</span> peek
</span></span><span style="display:flex;"><span>    stack<span style="color:#f92672">.</span>push(s0)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> peek <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span> <span style="color:#f92672">||</span> <span style="color:#f92672">...</span> <span style="color:#f92672">||</span> peek <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;9&#34;</span>:
</span></span><span style="display:flex;"><span>        goto s1
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        goto se
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span></span></span></code></pre></div><p>Durch die direkte Kodierung der Tabellen in Form von Sprungzielen für
<code>goto</code>-Befehle spart man sich die Formulierung der Tabellen und den Zugriff
auf die Inhalte. Allerdings ist der Code deutlich schwerer lesbar und auch
deutlich schwerer an eine andere Sprache anpassbar. Dies stellt aber keinen
echten Nachteil dar, wenn er durch einen Generator aus einer Grammatik o.ä.
erzeugt wird.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Zusammenhang DFA, RE und Lexer</p>
</li>
<li>
<p>Implementierungsansatz: Tabellenbasiert (DFA-Tabellen)</p>
</li>
</ul>


    



    



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Abschnitt 2.6 und Kapitel 3</em></li> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 1 (insbesondere Abschnitt 1.8)</em></li> <li id='id_Torczon2012'>[Torczon2012] <strong>Engineering a Compiler</strong><br>Torczon, L. und Cooper, K., Elsevier MK, 2012. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-1208-8478-0' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-1208-8478-0</a>.<br><em>Kapitel 2</em></li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Lexer: Handcodierte Implementierung</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p><a href="#R-image-20ce9c51402d8e5152a21b9a12d2b154" class="lightbox-link"><img src="images/architektur_cb_lexer.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-20ce9c51402d8e5152a21b9a12d2b154"><img src="images/architektur_cb_lexer.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Der Lexer (auch &quot;Scanner&quot;) soll den Zeichenstrom in eine Folge von Token zerlegen. Zur
Spezifikation der Token werden reguläre Ausdrücke verwendet.</p>
<p>Von Hand implementierte Lexer arbeiten üblicherweise rekursiv und verarbeiten immer
das nächste Zeichen im Eingabestrom. Die Arbeitsweise erinnert an LL-Parser (vgl.
<a href="../parsing/ll-parser-impl.md">LL-Parser</a>).</p>
<p>Lexer müssen sehr effizient sein, da sie noch direkt auf der niedrigsten Abstraktionsstufe
arbeiten und u.U. oft durchlaufen werden. Deshalb setzt man hier gern spezielle Techniken
wie Puffern von Zeichen über einen Doppel-Puffer ein.</p>
<p>Die Palette an Fehlerbehandlungsstrategien im Lexer reichen von &quot;aufgeben&quot; über den &quot;Panic
Mode&quot; (&quot;gobbeln&quot; von Zeichen, bis wieder eines passt) und Ein-Schritt-Transformationen bis
hin zu speziellen Lexer-Regeln, die beispielsweise besonders häufige Typos abfangen.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/N0WJQ4UkXkM' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Handcodierte Lexer</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/17a4958b1d4c0cf3488a7df02743806a33951d49f1cc22bccbdab7ad873738f0a24d0ad83f13c6d00ad48a669758659fde7a7e2ce19e793fe6f412e35ea0ee6d' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Handcodierte Lexer</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) Aufgaben eines Lexers</li> <li>(K2) Manuelle Implementierung: Rekursiver Abstieg</li> <li>(K2) Umgang mit dem Doppel-Puffer</li> <li>(K2) Varianten bei der Erkennung von Schlüsselwörtern</li> <li>(K2) Fehler und Lösungsansätze in der lexikalischen Analyse</li> <li>(K3) Typische Einteilung von Token</li> <li>(K3) Implementierung eines Top-Down-Lexers mit Read-Ahead und intelligenter Pufferung</li></ul></div>
</div>




    <h2 id="lexer-erzeugen-eines-token-stroms-aus-einem-zeichenstrom">Lexer: Erzeugen eines Token-Stroms aus einem Zeichenstrom</h2>
<p>Aus dem Eingabe(-quell-)text</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* demo */</span>
</span></span><span style="display:flex;"><span>a<span style="color:#f92672">=</span> [<span style="color:#ae81ff">5</span>  , <span style="color:#ae81ff">6</span>]     ;</span></span></code></pre></div><p>erstellt der Lexer (oder auch Scanner genannt) eine Sequenz von Token:</p>
<pre><code>&lt;ID, &quot;a&quot;&gt; &lt;ASSIGN&gt; &lt;LBRACK&gt; &lt;NUM, 5&gt; &lt;COMMA&gt; &lt;NUM, 6&gt; &lt;RBRACK&gt; &lt;SEMICOL&gt;
</code></pre>
<h2 id="manuelle-implementierung-rekursiver-abstieg">Manuelle Implementierung: Rekursiver Abstieg</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">nextToken</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (peek <span style="color:#f92672">!=</span> EOF):  <span style="color:#75715e"># globale Variable, über consume()</span>
</span></span><span style="display:flex;"><span>        switch (peek):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39; &#39;</span>: <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#39;</span>: <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>: WS(); <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;[&#39;</span>: consume(); <span style="color:#66d9ef">return</span> Token(LBRACK, <span style="color:#e6db74">&#39;[&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>            default:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> isLetter(peek): <span style="color:#66d9ef">return</span> NAME()
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">raise</span> Error(<span style="color:#e6db74">&#34;invalid character: &#34;</span><span style="color:#f92672">+</span>peek)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Token(EOF_Type, <span style="color:#e6db74">&#34;&lt;EOF&gt;&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">WS</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (peek <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">||</span> peek <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">||</span> <span style="color:#f92672">...</span>): consume()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">NAME</span>():
</span></span><span style="display:flex;"><span>    buf <span style="color:#f92672">=</span> StringBuilder()
</span></span><span style="display:flex;"><span>    do { buf<span style="color:#f92672">.</span>append(peek); consume(); } <span style="color:#66d9ef">while</span> (isLetter(peek))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Token(NAME, buf<span style="color:#f92672">.</span>toString())</span></span></code></pre></div><p>Die manuelle Implementierung &quot;denkt&quot; nicht in den Zuständen des DFA, sondern
orientiert sich immer am aktuellen Zeichen &quot;<code>peek</code>&quot;. Abhängig von dessen
Ausprägung wird entweder direkt ein Token erzeugt und das Zeichen aus dem
Eingabestrom entfernt sowie das nächste Zeichen eingelesen (mittels der
Funktion <code>consume()</code>, nicht dargestellt im Beispiel), oder man ruft weitere
Funktionen auf, die das Gewünschte erledigen, beispielsweise um White-Spaces
zu entfernen oder um einen Namen einzulesen: Nach einem Buchstaben werden
alle folgenden Buchstaben dem Namen (Bezeichner) hinzugefügt. Sobald ein
anderes Zeichen im Eingabestrom erscheint, wird das Namen-Token erzeugt.</p>
<p>Die Funktion <code>consume()</code> &quot;verbraucht&quot; das aktuelle Zeichen &quot;<code>peek</code>&quot; und holt
das nächste Zeichen aus dem Eingabestrom.</p>
<p><em>Anmerkung</em>: Häufig findet man im Lexer keinen &quot;schönen&quot; objektorientierten
Ansatz. Dies ist i.d.R. Geschwindigkeitsgründen geschuldet ...</p>
<h2 id="read-ahead-unterscheiden-von--und-">Read-Ahead: Unterscheiden von &quot;<em>&lt;</em>&quot; und &quot;<em>&lt;=</em>&quot;</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">nextToken</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (peek <span style="color:#f92672">!=</span> EOF):  <span style="color:#75715e"># globale Variable</span>
</span></span><span style="display:flex;"><span>        switch (peek):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;&lt;&#39;</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">match</span>(<span style="color:#e6db74">&#39;=&#39;</span>): consume(); <span style="color:#66d9ef">return</span> Token(LE, <span style="color:#e6db74">&#34;&lt;=&#34;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>: consume(); <span style="color:#66d9ef">return</span> Token(LESS, <span style="color:#e6db74">&#39;&lt;&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Token(EOF_Type, <span style="color:#e6db74">&#34;&lt;EOF&gt;&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">match</span>(c):   <span style="color:#75715e"># Lookahead: Ein Zeichen</span>
</span></span><span style="display:flex;"><span>    consume()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (peek <span style="color:#f92672">==</span> c): <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: rollBack(); <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span></span></span></code></pre></div><p>Um die Token &quot;<code>&lt;</code>&quot; und &quot;<code>&lt;=</code>&quot; unterscheiden zu können, müssen wir ein Zeichen
vorausschauen: Wenn nach dem &quot;<code>&lt;</code>&quot; noch ein &quot;<code>=</code>&quot; kommt, ist es &quot;<code>&lt;=</code>&quot;, sonst
&quot;<code>&lt;</code>&quot;.</p>
<p>Erinnerung: Die Funktion <code>consume()</code> liest das nächste Zeichen aus dem
Eingabestrom und speichert den Wert in der globalen Variable <code>peek</code>.</p>
<p>Für das Read-Ahead wird die Funktion <code>match()</code> definiert, die zunächst das
bereits bekannte Zeichen, in diesem Fall das &quot;<code>&lt;</code>&quot; durch das nächste Zeichen
im Eingabestrom ersetzt (Aufruf von <code>consume()</code>). Falls der Vergleich des
Lookahead-Zeichens mit dem gesuchten Zeichen erfolgreich ist, liegt das
&quot;größere&quot; Token vor, also &quot;<code>&lt;=</code>&quot;. Dann wird noch das &quot;<code>=</code>&quot; durch das nächste
Zeichen ersetzt und das Token <code>LE</code> gebildet. Anderenfalls muss das zuviel
gelesene Zeichen wieder in den Eingabestrom zurückgelegt werden (<code>rollBack()</code>).</p>
<h2 id="puffern-des-input-stroms-double-buffering">Puffern des Input-Stroms: Double Buffering</h2>
<p>Das Einlesen einzelner Zeichen führt zwar zu eleganten algorithmischen
Lösungen, ist aber zur Laufzeit deutlich &quot;teurer&quot; als das Einlesen mit
gepufferten I/O-Operationen, die eine ganze Folge von Zeichen einlesen
(typischerweise einen ganzen Disk-Block, beispielsweise 4096 Zeichen).</p>
<p>Dazu kann man einen Ringpuffer nutzen, den man mit Hilfe von zwei gleich
großen <code>char</code>-Puffern mit jeweils der Länge 
<span class="math align-center">$N$</span> simulieren kann. (
<span class="math align-center">$N$</span>
sollte dann der Länge eines Disk-Blocks entsprechen.)</p>
<p>Vergleiche auch <a href="https://en.wikipedia.org/wiki/Circular_buffer" target="_blank">Wikipedia: &quot;Circular Buffer&quot;</a>.</p>
<p><a href="#R-image-c3a965fe57bd118c17a6cac8b403c507" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/recursive/doublebuffer.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c3a965fe57bd118c17a6cac8b403c507"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/lexing/recursive/doublebuffer.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; end <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; fill(buffer[<span style="color:#ae81ff">0</span>:n])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">consume</span>():
</span></span><span style="display:flex;"><span>    peek <span style="color:#f92672">=</span> buffer[start]
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> (start<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) mod <span style="color:#ae81ff">2</span>n
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (start mod n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>        fill(buffer[start:start<span style="color:#f92672">+</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>        end <span style="color:#f92672">=</span> (start<span style="color:#f92672">+</span>n) mod <span style="color:#ae81ff">2</span>n
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rollBack</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (start <span style="color:#f92672">==</span> end): <span style="color:#66d9ef">raise</span> Error(<span style="color:#e6db74">&#34;roll back error&#34;</span>)
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> (start<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) mod <span style="color:#ae81ff">2</span>n</span></span></code></pre></div><p>Zunächst wird nur der vordere Pufferteil durch einen passenden Systemaufruf
gefüllt.</p>
<p>Beim Weiterschalten im simulierten DFA oder im manuell kodierten Lexer
(Funktionsaufruf von <code>consume()</code>) wird das nächste Zeichen aus dem vorderen
Pufferteil zurückgeliefert. Über die Modulo-Operation bleibt der Pointer
<code>start</code> immer im Speicherbereich der beiden Puffer.</p>
<p>Wenn man das Ende des vorderen Puffers erreicht, wird der hintere Puffer mit
einem Systemaufruf gefüllt. Gleichzeitig wird ein Hilfspointer <code>end</code> auf
den Anfang des vorderen Puffers gesetzt, um Fehler beim Roll-Back zu erkennen.</p>
<p>Wenn man das Ende des hinteren Puffers erreicht, wird der vordere Puffer
nachgeladen und der Hilfspointer auf den Anfang des hinteren Puffers gesetzt.</p>
<p>Im Grunde ist also immer ein Puffer der &quot;Arbeitspuffer&quot; und der andere enthält
die bereits gelesene (verarbeitete) Zeichenkette. Wenn beim Nachladen weniger
als 
<span class="math align-center">$N$</span> Zeichen gelesen werden, liefert der Systemaufruf als letztes &quot;Zeichen&quot;
ein <code>EOF</code>. Beim Verarbeiten wird <code>peek</code> entsprechend diesen Wert bekommen und
der Lexer muss diesen Wert abfragen und berücksichtigen.</p>
<p>Für das Roll-Back wird der <code>start</code>-Pointer einfach dekrementiert (und mit einer
Modulo-Operation auf den Speicherbereich der beiden Puffer begrenzt). Falls
dabei der <code>end</code>-Pointer &quot;eingeholt&quot; wird, ist der <code>start</code>-Pointer durch beide
Puffer zurückgelaufen und es gibt keinen früheren Input mehr. In diesem Fall
wird entsprechend ein Fehler gemeldet.</p>
<p><em>Anmerkung</em>: In der Regel sind die Lexeme kurz und man muss man nur ein bis
zwei Zeichen im Voraus lesen. Dann ist eine Puffergröße von 4096 Zeichen mehr
als ausreichend groß und man sollte nicht in Probleme laufen. Wenn der nötige
Look-Ahead aber beliebig groß werden kann, etwa bei Sprachen ohne reservierte
Schlüsselwörtern oder bei Kontext-sensitiven Lexer-Grammatiken (denken Sie etwa
an die Einrücktiefe bei Python), muss man andere Strategien verwenden. ANTLR
beispielsweise vergrößert in diesem Fall den Puffer dynamisch, alternativ könnte
man die Auflösung zwischen Schlüsselwörtern und Bezeichnern dem Parser überlassen.</p>
<h2 id="typische-muster-für-erstellung-von-token">Typische Muster für Erstellung von Token</h2>
<ol>
<li>
<p>Schlüsselwörter</p>
<ul>
<li>Ein eigenes Token (RE/DFA) für jedes Schlüsselwort, oder</li>
<li>Erkennung als Name und Vergleich mit Wörterbuch
und nachträgliche Korrektur des Tokentyps</li>
</ul>
<p>Wenn Schlüsselwörter über je ein eigenes Token abgebildet werden, benötigt
man für jedes Schlüsselwort einen eigenen RE bzw. DFA. Die Erkennung als
Bezeichner und das Nachschlagen in einem Wörterbuch (geeignete Hashtabelle)
sowie die entsprechende nachträgliche Korrektur des Tokentyps kann die
Anzahl der Zustände im Lexer signifikant reduzieren!</p>
</li>
<li>
<p>Operatoren</p>
<ul>
<li>Ein eigenes Token für jeden Operator, oder</li>
<li>Gemeinsames Token für jede Operatoren-Klasse</li>
</ul>
</li>
<li>
<p>Bezeichner: Ein gemeinsames Token für alle Namen</p>
</li>
<li>
<p>Zahlen: Ein gemeinsames Token für alle numerischen Konstante
(ggf. Integer und Float unterscheiden)</p>
<p>Für Zahlen führt man oft ein Token &quot;<code>NUM</code>&quot; ein. Als Attribut speichert man
das Lexem i.d.R. als String. Alternativ kann man (zusätzlich) das Lexem in
eine Zahl konvertieren und als (zusätzliches) Attribut speichern. Dies kann
in späteren Stufen viel Arbeit sparen.</p>
</li>
<li>
<p>String-Literale: Ein gemeinsames Token</p>
</li>
<li>
<p>Komma, Semikolon, Klammern, ...: Je ein eigenes Token</p>
</li>
<li>
<p>Regeln für White-Space und Kommentare etc. ...</p>
<p>Normalerweise benötigt man Kommentare und White-Spaces in den folgenden
Stufen nicht und entfernt diese deshalb aus dem Eingabestrom. Dabei könnte
man etwa White-Spaces in den Pattern der restlichen Token berücksichtigen,
was die Pattern aber sehr komplex macht. Die Alternative sind zusätzliche
Pattern, die auf die White-Space und anderen nicht benötigten Inhalt
matchen und diesen &quot;geräuschlos&quot; entfernen. Mit diesen Pattern werden
keine Token erzeugt, d.h. der Parser und die anderen Stufen bemerken nichts
von diesem Inhalt.</p>
<p>Gelegentlich benötigt man aber auch Informationen über White-Spaces,
beispielsweise in Python. Dann müssen diese Token wie normale Token
an den Parser weitergereicht werden.</p>
</li>
</ol>
<p>Jedes Token hat i.d.R. ein Attribut, in dem das Lexem gespeichert wird. Bei
eindeutigen Token (etwa bei eigenen Token je Schlüsselwort oder bei den
Interpunktions-Token) kann man sich das Attribut auch sparen, da das Lexem
durch den Tokennamen eindeutig rekonstruierbar ist.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Token</th>
<th style="text-align:left">Beschreibung</th>
<th style="text-align:left">Beispiel-Lexeme</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>if</code></td>
<td style="text-align:left">Zeichen <code>i</code> und <code>f</code></td>
<td style="text-align:left"><code>if</code></td>
</tr>
<tr>
<td style="text-align:left"><code>relop</code></td>
<td style="text-align:left"><code>&lt;</code> oder <code>&gt;</code> oder <code>&lt;=</code> oder <code>&gt;=</code> oder <code>==</code> oder <code>!=</code></td>
<td style="text-align:left"><code>&lt;</code>, <code>&lt;=</code></td>
</tr>
<tr>
<td style="text-align:left"><code>id</code></td>
<td style="text-align:left">Buchstabe, gefolgt von Buchstaben oder Ziffern</td>
<td style="text-align:left"><code>pi</code>, <code>count</code>, <code>x3</code></td>
</tr>
<tr>
<td style="text-align:left"><code>num</code></td>
<td style="text-align:left">Numerische Konstante</td>
<td style="text-align:left"><code>42</code>, <code>3.14159</code>, <code>0</code></td>
</tr>
<tr>
<td style="text-align:left"><code>literal</code></td>
<td style="text-align:left">Alle Zeichen außer <code>&quot;</code>, in <code>&quot;</code> eingeschlossen</td>
<td style="text-align:left"><code>&quot;core dumped&quot;</code></td>
</tr>
</tbody>
</table>
<p><em>Anmerkung</em>: Wenn es mehrere matchende REs gibt, wird in der Regel das längste
Lexem bevorzugt. Wenn es mehrere gleich lange Alternativen gibt, muss man mit
Vorrangregeln bzgl. der Token arbeiten.</p>
<h2 id="fehler-bei-der-lexikalischen-analyse">Fehler bei der Lexikalischen Analyse</h2>
<p>Problem: Eingabestrom sieht so aus: <code>fi (a==42) { ... }</code></p>
<p>Der Lexer kann nicht erkennen, ob es sich bei <code>fi</code> um ein vertipptes
Schlüsselwort handelt oder um einen Bezeichner: Es könnte sich um einen
Funktionsaufruf der Funktion <code>fi()</code> handeln ...
Dieses Problem kann erst in der nächsten Stufe sinnvoll erkannt und behoben
werden.</p>
<p>=&gt; Was tun, wenn keines der Pattern auf den Anfang des Eingabestroms passt?</p>
<p>Optionen:</p>
<ul>
<li>
<p>Aufgeben ...</p>
<p>Eventuell vielleicht sogar die beste und einfachste Variante :-)</p>
</li>
<li>
<p>&quot;Panic Mode&quot;: Entferne so lange Zeichen, bis ein Pattern passt.</p>
<p>Das verwirrt u.U. den Parser, kann aber insbesondere in interaktiven
Umgebungen hilfreich sein. Ggf. kann man dem Parser auch signalisieren,
dass hier ein Problem vorlag.</p>
</li>
<li>
<p>Ein-Schritt-Transformationen:</p>
<ul>
<li>Füge fehlendes Zeichen in Eingabestrom ein.</li>
<li>Entferne ein Zeichen aus Eingabestrom.</li>
<li>Vertausche ein Zeichen:
<ul>
<li>Ersetze ein Zeichen durch ein anderes.</li>
<li>Vertausche zwei benachbarte Zeichen.</li>
</ul>
</li>
</ul>
<p>Diese Transformationen versuchen, den Input in einem Schritt zu reparieren.
Das ist durchaus sinnvoll, da in der Praxis die meisten Fehler in dieser
Stufe durch ein einzelnes Zeichen hervorgerufen werden: Es fehlt ein
Zeichen oder es ist eines zuviel im Input. Es liegt ein falsches Zeichen
vor (Tippfehler) oder zwei benachbarte Zeichen wurden verdreht ...</p>
<p>Im Prinzip könnte man auch eine allgemeinere Strategie versuchen, indem man
diejenige Transformation mit der <em>kleinsten Anzahl von Schritten</em> zur
Fehlerbehebung bestimmt. Beispiele dafür finden sich im Bereich Natural
Language Processing (<em>NLP</em>), etwa die Levenshtein-Distanz oder der
SoundEx-Algorithmus oder sogar Hidden-Markov-Modelle. Allerdings muss
man sich in Erinnerung rufen, dass gerade in dieser ersten Phase eines
Compilers die Geschwindigkeit stark im Fokus steht und eine ausgefeilte
Fehlerkorrekturstrategie die vielen kleinen Optimierungen schnell wieder
zunichte machen kann.</p>
</li>
<li>
<p>Fehler-Regeln: Matche typische Typos</p>
<p>Gelegentlich findet man in den Grammatiken für den Lexer extra Regeln, die
häufige bzw. typische Typos matchen und dann passend darauf reagieren.</p>
</li>
</ul>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Zusammenhang DFA, RE und Lexer</p>
</li>
<li>
<p>Implementierungsansatz: Manuell codiert (rekursiver Abstieg)</p>
</li>
<li>
<p>Read-Ahead</p>
</li>
<li>
<p>Puffern mit Doppel-Puffer-Strategie</p>
</li>
<li>
<p>Typische Fehler beim Scannen</p>
</li>
</ul>


    



    



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Abschnitt 2.6 und Kapitel 3</em></li> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 1 (insbesondere Abschnitt 1.8)</em></li> <li id='id_Torczon2012'>[Torczon2012] <strong>Engineering a Compiler</strong><br>Torczon, L. und Cooper, K., Elsevier MK, 2012. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-1208-8478-0' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-1208-8478-0</a>.<br><em>Kapitel 2</em></li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Lexer mit ANTLR generieren</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>ANTLR ist ein Parser-Generator, der aus einer Grammatik einen Parser in verschiedenen
Zielsprachen (Java, Python, C++, ...) generieren kann.</p>
<p>In der ANTLR-Grammatik werden die Parser-Regeln klein geschrieben, die Lexer-Regeln werden
mit <strong>Großbuchstaben</strong> geschrieben. Jede Lexer-Regel liefert ein Token zurück, dabei
ist der Tokenname die linke Seite der Regel. Wie bei Flex gewinnt der längste Match,
und bei Gleichstand (mehrere längste Regeln matchen) gewinnt die zuerst definierte Regel.</p>
<p>Die Lexer-Regeln können mit Aktionen annotiert werden, die beim Matchen der jeweiligen Regel
abgearbeitet werden. Diese Aktionen müssen in der Zielprogrammiersprache formuliert werden,
da sie in die generierte Lexerklasse in die jeweiligen Methoden eingebettet werden.</p>
<p>ANTLR kennt Lexer-Kommandos wie <code>skip</code> (entferne das aktuelle Zeichen), <code>more</code> (lese mehr
Input, um ein Token zu generieren) und andere. Mit &quot;Fragmenten&quot; kann man Hilfsregeln definieren,
die keine Token darstellen.</p>
<p>ANTLR kennt &quot;Modes&quot;, mit denen man zustandsbehaftete Lexer erzeugen kann. Dies ist nützlich
für &quot;Insel-Grammatiken&quot;, etwa für das Bearbeiten von XML oder HTML. Zusätzlich gibt es &quot;Channels&quot;
zum Vorsortieren von Tokens in verschiedene parallele Tokenstreams.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
        
        
            
        
    
        
        
            
        
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/I119N04WIYA' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Lexer mit ANTLR</a></li> <li><a href='https://youtu.be/pbjGThqVLkU' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Demo ANTLR Basics</a></li> <li><a href='https://youtu.be/vnJIm6S-898' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Demo Verhalten Lexer-Regeln</a></li> <li><a href='https://youtu.be/bNpgqctiQM8' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Demo Lexer-Regeln mit Aktionen</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/10e0ed907bb767e8304c0cf197293588f9497a217e0dee792c458887ec73299a415da96fd2ea12e0f054ba478772239ec2581db5cedadb3aba14203c590493d1' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Lexer mit ANTLR</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K3) Lexer-Regeln in ANTLR formulieren und einsetzen</li> <li>(K2) Verhalten des Lexers: längste Matches, Reihenfolge</li> <li>(K3) Nutzung von Lexer-Aktionen</li> <li>(K3) Einsatz von Fragmenten</li> <li>(K3) Nutzung von Lexer-Kommandos</li> <li>(K3) Zustandsbehaftete Lexer (Modes)</li> <li>(K3) Nutzung von Channels</li> <li>(K2) Importieren von Grammatiken</li></ul></div>
</div>




    <h2 id="hello-world">Hello World</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span><span style="color:#66d9ef">grammar</span> <span style="color:#a6e22e">Hello</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>start       : <span style="color:#e6db74">&#39;hello&#39;</span> <span style="color:#66d9ef">GREETING</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>GREETING    : [a-zA-Z]<span style="color:#f92672">+</span> ;
</span></span><span style="display:flex;"><span>WHITESPACE  : [ \t\n]<span style="color:#f92672">+</span> <span style="color:#f92672">-&gt;</span> skip ;</span></span></code></pre></div><div style="text-align: right;">
<span class="btn cstyle default">
  <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/lecture/frontend/lexing/src/Hello.g4" target="_blank">
    Konsole: Hello (Classpath, Aliase, grun, Main, Dateien, Ausgabe)
  </a>
</span></div>
<h3 id="hinweis-zur-grammatik-regeln">Hinweis zur Grammatik (Regeln)</h3>
<ul>
<li><code>start</code> ist eine <span class='alert'>Parser-Regel</span>
=&gt; Eine Parser-Regel pro Grammatik wird benötigt, damit man den generierten
Parser am Ende auch starten kann ...</li>
<li>Die anderen beiden Regeln (mit großem Anfangsbuchstaben) aus der obigen Grammatik
zählen zum Lexer</li>
</ul>
<h3 id="antlr-einrichten">ANTLR einrichten</h3>
<ul>
<li>Aktuelle Version herunterladen: <a href="https://www.antlr.org/download.html" target="_blank">antlr.org</a>,
für Java als Zielsprache: <a href="https://www.antlr.org/download/antlr-4.11.1-complete.jar" target="_blank">&quot;Complete ANTLR 4.x Java binaries jar&quot;</a></li>
<li>CLASSPATH setzen: <code>export CLASSPATH=&quot;.:/&lt;pathToJar&gt;/antlr-4.11.1-complete.jar:$CLASSPATH&quot;</code></li>
<li>Aliase einrichten (<code>.bashrc</code>):
<ul>
<li><code>alias antlr='java org.antlr.v4.Tool'</code></li>
<li><code>alias grun='java org.antlr.v4.gui.TestRig'</code></li>
</ul>
</li>
<li>Alternativ über den Python-Installer: <code>pip install antlr4-tools</code></li>
<li>Im Web ohne lokale Installation: <a href="http://lab.antlr.org/" target="_blank">ANTLR Lab</a></li>
</ul>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/getting-started.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/getting-started.md</a>)</p>
<h3 id="hello-world-übersetzen-und-ausführen">&quot;Hello World&quot; übersetzen und ausführen</h3>
<ol>
<li>Grammatik übersetzen und Code generieren: <code>antlr Hello.g4</code></li>
<li>Java-Code kompilieren: <code>javac *.java</code></li>
<li>Lexer ausführen:
<ul>
<li>
<p><code>grun Hello start -tokens</code> (Grammatik &quot;Hello&quot;, Startregel &quot;start&quot;)</p>
</li>
<li>
<p>Alternativ mit kleinem Java-Programm:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> org.antlr.v4.runtime.*<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        Lexer l <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HelloLexer<span style="color:#f92672">(</span>CharStreams<span style="color:#f92672">.</span><span style="color:#a6e22e">fromStream</span><span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        Token t <span style="color:#f92672">=</span> l<span style="color:#f92672">.</span><span style="color:#a6e22e">nextToken</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>t<span style="color:#f92672">.</span><span style="color:#a6e22e">getType</span><span style="color:#f92672">()</span> <span style="color:#f92672">!=</span> Token<span style="color:#f92672">.</span><span style="color:#a6e22e">EOF</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>t<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            t <span style="color:#f92672">=</span> l<span style="color:#f92672">.</span><span style="color:#a6e22e">nextToken</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div></li>
</ul>
</li>
</ol>
<h3 id="generierte-dateien-und-klassen">Generierte Dateien und Klassen</h3>
<p>Nach dem Übersetzen finden sich folgende Dateien und Klassen vor:</p>
<pre><code>.
├── bin
│   ├── HelloBaseListener.class
│   ├── HelloBaseVisitor.class
│   ├── HelloLexer.class
│   ├── HelloListener.class
│   ├── HelloParser.class
│   ├── HelloParser$RContext.class
│   ├── HelloVisitor.class
│   └── Main.class
├── Hello.g4
└── src
    ├── HelloBaseListener.java
    ├── HelloBaseVisitor.java
    ├── HelloLexer.java
    ├── HelloLexer.tokens
    ├── HelloListener.java
    ├── HelloParser.java
    ├── Hello.tokens
    ├── HelloVisitor.java
    └── Main.java
</code></pre>
<p><em>Anmerkung</em>: Die Ordnerstruktur wurde durch ein ANTLR-Plugin für Eclipse
erzeugt. Bei Ausführung in der Konsole liegen alle Dateien in einem Ordner.</p>
<p><em>Anmerkung</em>: Per Default werden nur die Listener angelegt, für die Visitoren
muss eine extra Option mitgegeben werden.</p>
<p>Die Dateien <code>Hello.tokens</code> und <code>HelloLexer.tokens</code> enthalten die Token samt
einer internen Nummer. (Der Inhalt beider Dateien ist identisch.)</p>
<p>Die Datei <code>HelloLexer.java</code> enthält den generierten Lexer, der eine
Spezialisierung der abstrakten Basisklasse <code>Lexer</code> darstellt. Über den
Konstruktor wird der zu scannende <code>CharStream</code> gesetzt. Über die Methode
<code>Lexer#nextToken()</code> kann man sich die erkannten Token der Reihe nach
zurückgeben lassen. (Diese Methode wird letztlich vom Parser benutzt.)</p>
<p>Die restlichen Dateien werden für den Parser und verschiedene Arten der
Traversierung des AST generiert (vgl.
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/astdriven-part1.html">AST-basierte Interpreter</a>).</p>
<h3 id="bedeutung-der-ausgabe">Bedeutung der Ausgabe</h3>
<p>Wenn man dem Hello-Lexer die Eingabe</p>
<pre><code>hello world
&lt;EOF&gt;
</code></pre>
<p>(das <code>&lt;EOF&gt;</code> wird durch die Tastenkombination <code>STRG-D</code> erreicht) gibt, dann
lautet die Ausgabe</p>
<pre><code>$ grun Hello start -tokens
hello world
&lt;EOF&gt;
[@0,0:4='hello',&lt;'hello'&gt;,1:0]
[@1,6:10='world',&lt;GREETING&gt;,1:6]
[@2,12:11='&lt;EOF&gt;',&lt;EOF&gt;,2:0]
</code></pre>
<p>Die erkannten Token werden jeweils auf einer eigenen Zeile ausgegeben.</p>
<ul>
<li><code>@0</code>: Das erste Token (fortlaufend nummeriert, beginnend mit 0)</li>
<li><code>0:4</code>: Das Token umfasst die Zeichen 0 bis 4 im Eingabestrom</li>
<li><code>='hello'</code>: Das gefundene Lexem (Wert des Tokens)</li>
<li><code>&lt;'hello'&gt;</code>: Das Token (Name/Typ des Tokens)</li>
<li><code>1:0</code>: Das Token wurde in Zeile 1 gefunden (Start der Nummerierung mit
Zeile 1), und startet in dieser Zeile an Position 0</li>
</ul>
<p>Entsprechend bekommt man mit</p>
<pre><code>$ grun Hello start -tokens
hello
  world

&lt;EOF&gt;
[@0,0:4='hello',&lt;'hello'&gt;,1:0]
[@1,8:12='world',&lt;GREETING&gt;,2:2]
[@2,15:14='&lt;EOF&gt;',&lt;EOF&gt;,4:0]
</code></pre>
<h3 id="antlr-grammatik-für-die-lexer-generierung">ANTLR-Grammatik für die Lexer-Generierung</h3>
<ul>
<li>
<p>Start der Grammatik mit dem Namen &quot;<code>XYZ</code>&quot; mit</p>
<pre><code>grammar XYZ;
</code></pre>
<p>oder (nur Lexer)</p>
<pre><code>lexer grammar XYZ;
</code></pre>
</li>
<li>
<p>Token und Lexer-Regeln starten mit <em>großen Anfangsbuchstaben</em>
(Ausblick: Parser-Regeln starten mit kleinen Anfangsbuchstaben)</p>
<p>Format: <code>TokenName : Alternative1 | ... | AlternativeN ;</code></p>
<p>Rekursive Lexer-Regeln sind erlaubt. <strong>Achtung</strong>: Es dürfen keine
<em>links-rekursiven</em> Regeln genutzt werden, etwa wie <code>ID : ID '*' ID ;</code> ...
(Eine genauere Definition und die Transformation in nicht-linksrekursive
Regeln siehe <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory.html">LL-Parser</a>).</p>
</li>
<li>
<p>Alle Literale werden in <em>einfache</em> Anführungszeichen eingeschlossen
(es erfolgt keine Unterscheidung zwischen einzelnen Zeichen und Strings
wie in anderen Sprachen)</p>
</li>
<li>
<p>Zeichenmengen: <code>[a-z\n]</code> umfasst alle Zeichen von <code>'a'</code> bis <code>'z'</code> sowie
<code>'\n'</code></p>
<p><code>'a'..'z'</code> ist identisch zu <code>[a-z]</code></p>
</li>
<li>
<p>Schlüsselwörter: Die folgenden Strings stellen reservierte Schlüsselwörter
dar und dürfen nicht als Token, Regel oder Label genutzt werden:</p>
<pre><code>import, fragment, lexer, parser, grammar, returns, locals, throws, catch, finally, mode, options, tokens
</code></pre>
<p><em>Anmerkung</em>: <code>rule</code> ist zwar kein Schlüsselwort, wird aber als Methodenname
bei der Codegenerierung verwendet. =&gt; Wie ein Schlüsselwort behandeln!</p>
</li>
</ul>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/lexicon.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/lexicon.md</a>)</p>
<h3 id="greedy-und-non-greedy-lexer-regeln">Greedy und Non-greedy Lexer-Regeln</h3>
<p>Die regulären Ausdrücke <code>(...)?</code>, <code>(...)*</code> und <code>(...)+</code> sind <em>greedy</em> und
versuchen soviel Input wie möglich zu matchen.</p>
<p>Falls dies nicht sinnvoll sein sollte, kann man mit einem weiteren <code>?</code> das
Verhalten auf <em>non-greedy</em> umschalten. Allerdings können non-greedy Regeln
das Verhalten des Lexers u.U. schwer vorhersehbar machen!</p>
<p>Die Empfehlung ist, non-greedy Lexer-Regeln nur sparsam einzusetzen
(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/wildcard.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/wildcard.md</a>).</p>
<h2 id="verhalten-des-lexers-1-längster-match">Verhalten des Lexers: 1. Längster Match</h2>
<p>Primäres Ziel: Erkennen der längsten Zeichenkette</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>CHARS   : [a-z]<span style="color:#f92672">+</span> ;
</span></span><span style="display:flex;"><span>DIGITS  : [0-9]<span style="color:#f92672">+</span> ;
</span></span><span style="display:flex;"><span>FOO     : [a-z]<span style="color:#f92672">+</span> [0-9]<span style="color:#f92672">+</span> ;</span></span></code></pre></div><p>Die Regel, die den längsten Match für die aktuelle Eingabesequenz produziert,
&quot;gewinnt&quot;.</p>
<p>Im Beispiel würde ein &quot;foo42&quot; als <code>FOO</code> erkannt und nicht als <code>CHARS DIGITS</code>.</p>
<h2 id="verhalten-des-lexers-2-reihenfolge">Verhalten des Lexers: 2. Reihenfolge</h2>
<p>Reihenfolge in Grammatik definiert Priorität</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>FOO     : <span style="color:#e6db74">&#39;f&#39;</span> <span style="color:#f92672">.*?</span> <span style="color:#e6db74">&#39;r&#39;</span> ;
</span></span><span style="display:flex;"><span>BAR     : <span style="color:#e6db74">&#39;foo&#39;</span> <span style="color:#f92672">.*?</span> <span style="color:#e6db74">&#39;bar&#39;</span> ;</span></span></code></pre></div><p>Falls mehr als eine Lexer-Regel die selbe Inputsequenz matcht, dann
hat die in der Grammatik zuerst genannte Regel Priorität.</p>
<p>Im Beispiel würden für die Eingabe &quot;foo42bar&quot; beide Regeln den selben längsten
Match liefern - die Regel <code>FOO</code> ist in der Grammatik früher definiert und
&quot;gewinnt&quot;.</p>
<h2 id="verhalten-des-lexers-3-non-greedy-regeln">Verhalten des Lexers: 3. Non-greedy Regeln</h2>
<p>Non-greedy Regeln versuchen <em>so wenig</em> Zeichen wie möglich zu matchen</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>FOO     : <span style="color:#e6db74">&#39;foo&#39;</span> <span style="color:#f92672">.*?</span> <span style="color:#e6db74">&#39;bar&#39;</span> ;
</span></span><span style="display:flex;"><span>BAR     : <span style="color:#e6db74">&#39;bar&#39;</span> ;</span></span></code></pre></div><p>Hier würde ein &quot;foo42barbar&quot; zu <code>FOO</code> gefolgt von <code>BAR</code> erkannt werden.</p>
<p><span class='alert'>Achtung</span>: Nach dem Abarbeiten einer non-greedy Sub-Regel in einer Lexer-Regel
gilt &quot;<em>first match wins</em>&quot;</p>
<p><code>.*? ('4' | '42')</code></p>
<p>=&gt; Der Teil <code>'42'</code> auf der rechten Seite ist
&quot;toter Code&quot; (wegen der non-greedy Sub-Regel <code>.*?</code>)!</p>
<p>Die Eingabe &quot;x4&quot; würde korrekt erkannt, währende &quot;x42&quot; nur als &quot;x4&quot; erkannt wird und für
die verbleibende &quot;2&quot; würde ein <em>token recognition error</em> geworfen.</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/wildcard.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/wildcard.md</a>)</p>
<h2 id="attribute-und-aktionen">Attribute und Aktionen</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span><span style="color:#66d9ef">grammar</span> <span style="color:#a6e22e">Demo</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@header {
</span></span><span style="display:flex;"><span>import java.util.*;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@members {
</span></span><span style="display:flex;"><span>String s = &#34;&#34;;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>start   : <span style="color:#66d9ef">TYPE</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> <span style="color:#66d9ef">INT</span> <span style="color:#e6db74">&#39;;&#39;</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>TYPE    : <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;float&#39;</span><span style="color:#f92672">)</span> {s = getText();} ;
</span></span><span style="display:flex;"><span>INT     : [0-9]<span style="color:#f92672">+</span>            {System.out.println(s+&#34;:&#34;+Integer.valueOf(getText()));};
</span></span><span style="display:flex;"><span>ID      : [a-z]<span style="color:#f92672">+</span>            {setText(String.valueOf(getText().charAt(0)));} ;
</span></span><span style="display:flex;"><span>WS      : [ \t\n]<span style="color:#f92672">+</span> <span style="color:#f92672">-&gt;</span> skip ;</span></span></code></pre></div><h3 id="attribute-bei-token-auswahl">Attribute bei Token (Auswahl)</h3>
<p>Token haben Attribute, die man abfragen kann. Dies umfasst u.a. folgende Felder:</p>
<ul>
<li><code>text</code>: Das gefundene Lexem als String</li>
<li><code>type</code>: Der Token-Typ als Integer</li>
<li><code>index</code>: Das wievielte Token (als Integer)</li>
</ul>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/actions.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/actions.md</a>)</p>
<p>Zur Auswertung in den Lexer-Regeln muss man anders vorgehen als in
Parser-Regeln: Nach der Erstellung eines Tokens kann man die zum Attribut
gehörenden <code>getX()</code> und <code>setX()</code>-Methoden aufrufen, um die Werte abzufragen
oder zu ändern.</p>
<p>Dies passiert im obigen Beispiel für das Attribut <code>text</code>: Abfrage mit
<code>getText()</code>, Ändern/Setzen mit <code>setText()</code>.</p>
<p>Die Methodenaufrufe wirken sich immer auf das gerade erstellte Token aus.</p>
<p><em>Achtung</em>: Bei Aktionen in Parser-Regeln gelten andere Spielregeln!</p>
<h3 id="aktionen-mit-den-lexer-regeln">Aktionen mit den Lexer-Regeln</h3>
<p>Aktionen für Lexer-Regeln sind Code-Blöcke in der Zielsprache, eingeschlossen
in geschweifte Klammern. Die Code-Blöcke werden direkt in die generierten
Lexer-Methoden kopiert.</p>
<p>Zusätzlich:</p>
<ul>
<li><code>@header</code>: Package-Deklarationen und/oder Importe (wird vor der
Klassendefinition eingefügt)</li>
<li><code>@members</code>: zusätzliche Attribute für die generierten Lexer- (und
Parser-) Klassen.</li>
</ul>
<p>Mit <code>@lexer::header</code> bzw. <code>@lexer::members</code> werden diese Codeblöcke nur in den
generierten Lexer eingefügt.</p>
<p><em>Anmerkung</em>: Lexer-Aktionen müssen am Ende der äußersten Alternative erscheinen.
Wenn eine Lexer-Regel mehr als eine Alternative hat, müssen diese in runde
Klammern eingeschlossen werden.</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/grammars.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/grammars.md</a>)</p>
<h2 id="hilfsregeln-mit-fragmenten">Hilfsregeln mit Fragmenten</h2>
<p>Fragmente sind Lexer-Regeln, die keine Token darstellen/erzeugen, aber
bei der Formulierung von Regeln für mehr Übersicht oder Wiederverwendung
sorgen. Fragmente werden mit dem Schlüsselwort <code>fragment</code> eingeleitet.</p>
<p><strong>Beispiel</strong>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>NUM         : <span style="color:#66d9ef">DIGIT</span><span style="color:#f92672">+</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fragment</span>
</span></span><span style="display:flex;"><span>DIGIT       : [0-9] ;</span></span></code></pre></div><p>=&gt; Keine Token (für den Parser)!</p>
<p>Hier würde der Parser nur <code>NUM</code> &quot;bekommen&quot;, aber keine <code>DIGIT</code>-Token.</p>
<h2 id="lexer-kommandos-auswahl">Lexer Kommandos (Auswahl)</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>TokenName : <span style="color:#66d9ef">Alternative</span> <span style="color:#f92672">-&gt;</span> command<span style="color:#960050;background-color:#1e0010">-</span>name</span></span></code></pre></div><ul>
<li>
<p><code>skip</code></p>
<p>Verwerfe den aktuellen Text: <code>WS : [ \t]+ -&gt; skip ;</code>
(liefert kein Token)</p>
</li>
<li>
<p><code>more</code></p>
<p>Lese weiter ...</p>
<p>Die Regel matcht zwar, aber es wird kein Token erzeugt. Die nächste
matchende Regel wird den hier gematchten Text mit in ihr Token einbauen.
Der Token-Typ ist der der zuletzt matchenden Regel.</p>
<p><em>Anmerkung</em>: Wird typischerweise zusammen mit Modes verwendet.</p>
</li>
<li>
<p><code>mode</code> (siehe unten)</p>
</li>
<li>
<p><code>channel</code> (siehe unten)</p>
</li>
</ul>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/lexer-rules.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/lexer-rules.md</a>)</p>
<h2 id="modes-und-insel-grammatiken">Modes und Insel-Grammatiken</h2>
<p>Umschalten zwischen verschiedenen Lexer-Modes: Wie verschiedene Sub-Lexer -
einen für jeden Kontext.</p>
<p>=&gt; Parsen von &quot;<em>Insel-Grammatiken</em>&quot; (beispielsweise XML).</p>
<p><em>Anmerkung</em>: <code>mode</code>-Spezifikation sind nur im Lexer-Teil der Grammatik erlaubt.</p>
<h3 id="allgemeines-schema">Allgemeines Schema</h3>
<pre><code>rules in default mode
...

mode MODE_1;
rules in MODE_1
...

mode MODE_N;
rules in MODE_N
...
</code></pre>
<h3 id="beispiel">Beispiel</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span><span style="color:#66d9ef">lexer</span> <span style="color:#66d9ef">grammar</span> <span style="color:#a6e22e">ModeLexer</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LCOMMENT    : <span style="color:#e6db74">&#39;/*&#39;</span> <span style="color:#f92672">-&gt;</span> more, mode<span style="color:#f92672">(</span><span style="color:#66d9ef">CMNT</span><span style="color:#f92672">)</span> ;
</span></span><span style="display:flex;"><span>WS          : [ \t\n]<span style="color:#f92672">+</span> <span style="color:#f92672">-&gt;</span> skip ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mode <span style="color:#960050;background-color:#1e0010">CMNT;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">COMMENT</span>     : <span style="color:#e6db74">&#39;*/&#39;</span> <span style="color:#f92672">-&gt;</span> mode<span style="color:#f92672">(</span><span style="color:#66d9ef">DEFAULT_MODE</span><span style="color:#f92672">)</span> ;
</span></span><span style="display:flex;"><span>CHAR        : <span style="color:#f92672">.</span> <span style="color:#f92672">-&gt;</span> more ;</span></span></code></pre></div><p>Nach dem Matchen des Tokens wird mit <code>mode(X)</code> in den Mode <code>X</code> umgeschaltet.
Der Lexer beachtet dann nur die Lexer-Regeln unter Mode <code>X</code>.</p>
<p>Mit <code>pushMode(X)</code> erreicht man das selbe Verhalten wie mit <code>mode(X)</code>,
allerdings wird vor dem Umschalten der aktuelle Mode auf einem Stack abgelegt.
Mit <code>popMode</code> kann der oberste Mode vom Stack wieder herunter genommen werden
und als aktueller Lexer-Mode gesetzt werden.</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/lexer-rules.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/lexer-rules.md</a>)</p>
<h2 id="channels">Channels</h2>
<p>Man kann die Token in verschiedene Kanäle (&quot;Channels&quot;) schicken. Beispielsweise
werden beim Parsen von Python-Programmen die White-Spaces evtl. noch benötigt.</p>
<p>Anstatt diese mit <code>skip</code> komplett zu verwerfen, kann man sie in einen anderen
Channel schicken, wo man sie im Parser bei Bedarf wieder abfragen kann. Der
Token-Index bleibt dabei erhalten, auch wenn die Token in verschiedene Kanäle
verteilt werden.</p>
<p><strong>Anmerkung</strong>: Channel-Spezifikationen sind nur im Lexer-Teil der Grammatik
erlaubt.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>channels { WHITESPACE, COMMENTS }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">BLOCK_COMMENT</span> : <span style="color:#e6db74">&#39;/*&#39;</span> <span style="color:#f92672">.*?</span> <span style="color:#e6db74">&#39;*/&#39;</span> <span style="color:#f92672">-&gt;</span> channel<span style="color:#f92672">(</span><span style="color:#66d9ef">COMMENTS</span><span style="color:#f92672">)</span> ;
</span></span><span style="display:flex;"><span>LINE_COMMENT  : <span style="color:#e6db74">&#39;//&#39;</span> <span style="color:#f92672">~</span>[\n]<span style="color:#f92672">*</span>   <span style="color:#f92672">-&gt;</span> channel<span style="color:#f92672">(</span><span style="color:#66d9ef">COMMENTS</span><span style="color:#f92672">)</span> ;
</span></span><span style="display:flex;"><span>WS            : [ \t\n]<span style="color:#f92672">+</span>      <span style="color:#f92672">-&gt;</span> channel<span style="color:#f92672">(</span><span style="color:#66d9ef">WHITESPACE</span><span style="color:#f92672">)</span> ;</span></span></code></pre></div><h2 id="grammatiken-importieren">Grammatiken importieren</h2>
<p>Mit <code>import XZY;</code> bindet man eine andere Grammatik <code>XYZ</code> ein. Dabei werden nur
Regeln eingebunden, die bisher noch nicht definiert wurden.</p>
<p>Aus einer anderen Perspektive kann man diesen Mechanismus mit dem Überschreiben
von Methoden in einer abgeleiteten Klasse vergleichen: Dann bekommt man beim
Aufruf einer überschriebenen Methode ebenfalls nur die &quot;neueste&quot;
Implementierung ...</p>
<p>Wenn mehrere verschachtelte Grammatiken eingebunden werden (wie im Beispiel),
dann wird per <em>Tiefensuche</em> der Einbindungsbaum durchlaufen.</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/grammars.md#grammar-imports" target="_blank">github.com/antlr/antlr4/blob/master/doc/grammars.md</a>)</p>
<h2 id="wrap-up">Wrap-Up</h2>
<p>Lexer mit ANTLR generieren: Lexer-Regeln werden mit <strong>Großbuchstaben</strong> geschrieben</p>
<ul>
<li>Längster Match gewinnt, Gleichstand: zuerst definierte Regel</li>
<li><em>non greedy</em>-Regeln: versuche so <em>wenig</em> Zeichen zu matchen wie möglich</li>
<li>Aktionen beim Matchen</li>
<li>Hilfsregeln mit &quot;Fragments&quot;</li>
<li>Lexer Kommandos: <code>skip</code>, <code>more</code>, ...</li>
<li>Modes für Insel-Grammatiken</li>
<li>Channels als parallele Tokenstreams (Vorsortieren)</li>
<li>Teilgrammatiken importieren</li>
</ul>


    



    



    

    
<div class="box notices cstyle note">
  <div class="box-label"><i class="fas fa-puzzle-piece"></i> Challenges</div>
  <div class="box-content">

<p><strong>Token und Lexer-Regeln mit ANTLR</strong></p>
<p>Formulieren Sie für ANTLR Lexer-Regeln, mit denen folgende Token erkannt werden:</p>
<ul>
<li>White-Space: Leerzeichen, Tabs, Zeilenumbrüche</li>
<li>Vergleichsoperatoren: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>&lt;&gt;</code></li>
<li>If: <code>if</code></li>
<li>Then: <code>then</code></li>
<li>Else: <code>else</code></li>
<li>Namen: Ein Buchstabe, gefolgt von beliebig vielen weiteren Buchstaben und/oder Ziffern</li>
<li>Numerische Konstanten: Mindestens eine Ziffer, gefolgt von maximal einem Paar bestehend aus einem Punkt und mindestens einer Ziffer, gefolgt von maximal einem Paar bestehend aus dem Buchstaben &quot;E&quot; gefolgt von einem &quot;+&quot; oder &quot;-&quot; und mindestens einer Ziffer.</li>
</ul>
<p>Formulieren Sie Hilfskonstrukte zur Verwendung in mehreren Lexer-Regeln als ANTLR-Fragmente.</p>
<p>White-Spaces sollen entfernt werden und nicht als Token weitergereicht werden.</p>
<p><strong>Real-World-Lexer mit ANTLR: Programmiersprache Lox</strong></p>
<p>Betrachten Sie folgenden Code-Schnipsel in der Sprache <a href="https://www.craftinginterpreters.com/the-lox-language.html" target="_blank">&quot;Lox&quot;</a>:</p>
<pre><code>fun fib(x) {
    if (x == 0) {
        return 0;
    } else {
        if (x == 1) {
            return 1;
        } else {
            fib(x - 1) + fib(x - 2);
        }
    }
}

var wuppie = fib(4);
</code></pre>
<p>Erstellen Sie für diese fiktive Sprache einen Lexer mit ANTLR. Die genauere Sprachdefinition finden Sie unter <a href="https://www.craftinginterpreters.com/the-lox-language.html" target="_blank">craftinginterpreters.com/the-lox-language.html</a>.</p>
<p><strong>Pig-Latin mit ANTLR-Lexer</strong></p>
<p>Schreiben Sie eine Lexer-Grammatik mit eingebetteten Aktionen für ANTLR sowie ein passendes Programm zur Einbindung des generierten Lexers, welches einen Text nach <a href="https://de.wikipedia.org/wiki/Pig_Latin" target="_blank">Pig Latin</a> übersetzt:</p>
<ul>
<li>Ist der erste Buchstabe eines Wortes ein Konsonant, schiebe ihn ans Ende des Wortes und füge &quot;ay&quot; an.</li>
<li>Ist der erste Buchstabe eines Wortes ein Vokal, hänge an das Wort ein &quot;ay&quot; an.</li>
</ul>
<p><strong>Lexing mit ANTLR</strong></p>
<p>In einem Telefonbuch sind zeilenweise Namen und Telefonnummern gespeichert.</p>
<p>Definieren Sie eine Lexer-Grammatik für ANTLR, mit der Sie die Zeilen einlesen können. Können Sie dabei verschiedene Formate der Telefonnummern berücksichtigen?</p>
<pre><code>Heinz 030 5346 983
Kalle +49 30 1234 567
Lina +49.571.8385-255
Rosi (0571) 8385-268
</code></pre>
<p>Können Sie die Grammatik so anpassen, dass Sie nur möglichst wenige verschiedene Token an den Parser weitergeben?</p>
<p>Ergänzen Sie Ihre Grammatik um Lexer-Aktionen, so dass Sie die Zeilen, die Zeichen (in den Namen) und die Ziffern (in den Telefonnummern) zählen können.</p>
</div>
</div>



    





    




    
    
        
        

        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

          </section>
          <article class="default">
            <header class="headline">
            </header>
<h1 id="parser">Parser</h1>

<p>Der Parser arbeitet mit dem Tokenstrom, der vom Lexer kommt. Mit Hilfe einer Grammatik wird
geprüft, ob hier gültige Sätze im Sinne der Sprache/Grammatik gebildet wurden. Der Parser
erzeugt dabei den Parse-Tree.</p>

<ul class="children children-li children-sort-">
	
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/cfg.html">CFG</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory.html">LL-Parser (Theorie)</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-impl.html">LL-Parser selbst implementiert</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html">LL-Parser: Fortgeschrittene Techniken</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing.html">Parser mit ANTLR generieren</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/finalwords.html">Grenze Lexer und Parser</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser1.html">Syntaxanalyse: LR-Parser (Teil 1)</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2.html">Syntaxanalyse: LR-Parser (Teil 2)</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery.html">Error-Recovery</a></li>
</ul>

            <footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Parser</h1>
<article class="default">
<h1>CFG</h1>



    
    




    
    
        
        
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="far fa-file-powerpoint"></i> Annotierte Folien</div>
  <div class="box-content">

<ul> <li><a href='https://raw.githubusercontent.com/Compiler-CampusMinden/AnnotatedSlides/master/frontend_parsing_cfg.ann.ma.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Annotierte Folien: CFG, LL-Parser</a></li></ul></div>
</div>




    <h1 id="wiederholung">Wiederholung</h1>
<h2 id="endliche-automaten-reguläre-ausdrücke-reguläre-grammatiken-reguläre-sprachen">Endliche Automaten, reguläre Ausdrücke, reguläre Grammatiken, reguläre Sprachen</h2>
<ul>
<li>Wie sind DFAs und NFAs definiert?</li>
<li>Was sind reguläre Ausdrücke?</li>
<li>Was sind formale und reguläre Grammatiken?</li>
<li>In welchem Zusammenhang stehen all diese Begriffe?</li>
<li>Wie werden DFAs und reguläre Ausdrücke im Compilerbau eingesetzt?</li>
</ul>
<h1 id="motivation">Motivation</h1>
<h2 id="wofür-reichen-reguläre-sprachen-nicht">Wofür reichen reguläre Sprachen nicht?</h2>
<p>Für z. B. alle Sprachen, in deren Wörtern Zeichen über eine Konstante hinaus gezählt werden müssen. Diese Sprachen lassen sich oft mit Variablen im Exponenten beschreiben, die unendlich viele Werte annehmen können.</p>
<ul>
<li>
<p>
<span class="math align-center">$a^ib^{2*i}$</span> ist nicht regulär</p>
</li>
<li>
<p>
<span class="math align-center">$a^ib^{2*i}$</span> für 
<span class="math align-center">$0 \leq i \leq 3$</span> ist regulär</p>
</li>
<li>
<p>Wo finden sich die oben genannten VAriablen bei einem DFA wieder?</p>
</li>
<li>
<p>Warum ist die erste Sprache oben nicht regulär, die zweite aber?</p>
</li>
</ul>
<h2 id="themen-für-heute">Themen für heute</h2>
<ul>
<li>PDAs: mächtiger als DFAs, NFAs</li>
<li>kontextfreie Grammatiken und Sprachen: mächtiger als reguläre Grammatiken und Sprachen</li>
<li>DPDAs und deterministisch kontextfreie Grammatiken: die Grundlage der Syntaxanalyse im Compilerbau</li>
</ul>
<h2 id="einordnung-erweiterung-der-automatenklasse-dfa-um-komplexere-sprachen-als-die-regulären-akzeptieren-zu-können">Einordnung: Erweiterung der Automatenklasse DFA, um komplexere Sprachen als die regulären akzeptieren zu können</h2>
<p>Wir spendieren den DFAs einen möglichst einfachen, aber beliebig großen, Speicher, um zählen und matchen zu können. Wir suchen dabei konzeptionell die &quot;kleinstmögliche&quot; Erweiterung, die die akzeptierte Sprachklasse gegenüber DFAs vergrößert.</p>
<ul>
<li>Der konzeptionell einfachste Speicher ist ein Stack. Wir haben keinen wahlfreien Zugriff auf die gespeicherten Werte.</li>
<li>Es soll eine deterministische und eine indeterministische Variante der neuen Automatenklasse geben.</li>
<li>In diesem Zusammenhang wird der Stack auch Keller genannt.</li>
</ul>
<h2 id="kellerautomaten-push-down-automata-pdas">Kellerautomaten (Push-Down-Automata, PDAs)</h2>
<p><strong>Def.:</strong> Ein Kellerautomat (PDA) 
<span class="math align-center">$P = (Q,\ \Sigma,\ \Gamma,\  \delta,\ q_0,\ \perp,\ F)$</span>
ist ein Septupel mit:</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/cfg/Def_PDA.png" alt="Definition eines PDAs" width="60%" height="auto">
    <figcaption><p>Definition eines PDAs</p></figcaption>
</figure>
<p>Ein PDA ist per Definition nichtdeterministisch und kann spontane Zustandsübergänge durchführen.</p>
<h2 id="was-kann-man-damit-akzeptieren">Was kann man damit akzeptieren?</h2>
<p>Strukturen mit paarweise zu matchenden Symbolen.</p>
<p>Bei jedem Zustandsübergang wird ein Zeichen (oder 
<span class="math align-center">$\epsilon$</span>) aus der Eingabe gelesen, ein Symbol von Keller genommen. Diese und das Eingabezeichen bestimmen den Folgezustand und eine Zeichenfolge, die auf den Stack gepackt wird. Dabei wird ein Symbol, das später mit einem Eingabesymbol zu matchen ist, auf den Stack gepackt.</p>
<p>Soll das automatisch vom Stack genommene Symbol auf dem Stack bleiben, muss es wieder gepusht werden.</p>
<h2 id="beispiel">Beispiel</h2>
<p>Ein PDA für 
<span class="math align-center">$L=\lbrace ww^{R}\mid w\in \lbrace a,b\rbrace^{\ast}\rbrace$</span>:</p>
<p><a href="#R-image-a729d67a963e5be38ca5a1c576fd1c5e" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/cfg/pda2.png?width=45%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 45%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a729d67a963e5be38ca5a1c576fd1c5e"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/cfg/pda2.png?width=45%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<h2 id="konfigurationen-von-pdas">Konfigurationen von PDAs</h2>
<p><strong>Def.:</strong> Eine Konfiguration (ID) eines PDAs 3-Tupel 
<span class="math align-center">$(q, w, \gamma)$</span>
mit</p>
<ul>
<li>
<span class="math align-center">$q$</span> ist ein Zustand</li>
<li>
<span class="math align-center">$w$</span> ist der verbleibende Input, 
<span class="math align-center">$w\in\Sigma^{\ast}$</span></li>
<li>
<span class="math align-center">$\gamma$</span> ist der Kellerinhalt 
<span class="math align-center">$\gamma\in \Gamma^{\ast}$</span></li>
</ul>
<p>eines PDAs zu einem gegebenen Zeitpunkt.</p>
<h2 id="die-übergangsrelation-eines-pdas">Die Übergangsrelation eines PDAs</h2>
<p><strong>Def.:</strong> Die Relation 
<span class="math align-center">$\vdash$</span> definiert Übergänge von einer Konfiguration zu einer anderen:</p>
<p>Sei 
<span class="math align-center">$(p, \alpha) \in \delta(q, a, X)$</span>, dann gilt 
<span class="math align-center">$\forall w\ \epsilon \ \Sigma^{\ast}$</span> und

<span class="math align-center">$\beta \in \Gamma^{\ast}$</span>:</p>
<p>
<span class="math align-center">$(q, aw, X\beta)\vdash(p, w, \alpha\beta)$</span>.</p>
<p><strong>Def.:</strong> Wir definieren mit 
<span class="math align-center">$\overset{\ast}{\vdash}$</span> 0 oder endlich viele Schritte des PDAs
induktiv wie folgt:</p>
<ul>
<li>Basis: 
<span class="math align-center">$I\overset{\ast}{\vdash} I$</span> für eine ID 
<span class="math align-center">$I$</span>.</li>
<li>Induktion: 
<span class="math align-center">$I\overset{\ast}{\vdash}J$</span>, wenn 
<span class="math align-center">$\exists$</span> ID 
<span class="math align-center">$K$</span> mit 
<span class="math align-center">$I\vdash K$</span> und 
<span class="math align-center">$K \overset{\ast}{\vdash}J$</span>.</li>
</ul>
<h2 id="eigenschaften-der-konfigurationsübergänge">Eigenschaften der Konfigurationsübergänge</h2>
<p><strong>Satz:</strong> Sei 
<span class="math align-center">$P=(Q, \Sigma, \Gamma, \delta, q_{0}, \perp, F)$</span> ein PDA und 
<span class="math align-center">$(q, x,\alpha)\overset{\ast}{\vdash} (p, y, \beta)$</span>. Dann gilt für beliebige Strings 
<span class="math align-center">$w\in\Sigma^{\ast}$</span>, 
<span class="math align-center">$\gamma$</span> in 
<span class="math align-center">$\Gamma^{\ast}$</span>:</p>

<span class="math align-center">$(q, xw, \alpha \gamma) \overset{\ast}{\vdash}(p, yw, \beta\gamma)$</span>
<p><strong>Satz:</strong> Sei 
<span class="math align-center">$P = (Q, \Sigma, \Gamma, \gamma, q_0, \perp, F)$</span> ein PDA und 
<span class="math align-center">$(q,xw,\alpha) \overset{\ast}{\vdash} (p,y w, \beta)$</span>.</p>
<p>Dann gilt: 
<span class="math align-center">$(q, x, a) \overset{\ast}{\vdash} (p, y, \beta)$</span></p>
<h2 id="akzeptierte-sprachen">Akzeptierte Sprachen</h2>
<p><strong>Def.:</strong> Sei 
<span class="math align-center">$P=(Q, \Sigma, \Gamma, \delta, q_0, \perp, F)$</span> ein PDA. Dann ist die <em>über einen Endzustand</em>
akzeptierte Sprache 
<span class="math align-center">$L(P) = \lbrace w \mid (q_0, w, \perp) \overset{\ast}{\vdash} (q, \epsilon, \alpha)\rbrace$</span>
für einen Zustand 
<span class="math align-center">$q \in F, \alpha \in \Gamma^{\ast}$</span>.</p>
<p><strong>Def.:</strong> Für einen PDA 
<span class="math align-center">$P=(Q, \Sigma, \Gamma, \delta, q_{0}, \perp, F)$</span>
definieren wir die über den <em>leeren Keller</em> akzeptierte Sprache

<span class="math align-center">$N(P) = \lbrace (w \mid (q_0, w, \perp) \overset{\ast}{\vdash} (q, \epsilon, \epsilon)\rbrace$</span>.</p>
<h2 id="akzeptanzäquivalenzen">Akzeptanzäquivalenzen</h2>
<p><strong>Satz:</strong> Wenn 
<span class="math align-center">$L = N(P_N)$</span> für einen PDA 
<span class="math align-center">$P_N$</span>, dann gibt es einen PDA 
<span class="math align-center">$P_L$</span> mit

<span class="math align-center">$L = L(P_L)$</span>.</p>
<p><strong>Satz:</strong> Für einen PDA 
<span class="math align-center">$P$</span> mit 
<span class="math align-center">$\epsilon$</span>-Transitionen existiert ein PDA 
<span class="math align-center">$Q$</span> ohne

<span class="math align-center">$\epsilon$</span>-Transitionen mit 
<span class="math align-center">$L(P) = N(P) = L(Q) = N(Q)$</span>.</p>
<p>Die Transitionsfunktion 
<span class="math align-center">$\delta$</span> ist dann von der Form

<span class="math align-center">$\delta: Q \times \Sigma \times \Gamma \to2^{Q \times \Gamma^{\ast}}$</span>.</p>
<h2 id="deterministische-pdas">Deterministische PDAs</h2>
<p><strong>Def.</strong> Ein PDA 
<span class="math align-center">$P = (Q, \Sigma, \Gamma, \delta, q_0, \perp, F)$</span> ist <em>deterministisch</em>

<span class="math align-center">$: \Leftrightarrow$</span></p>
<ul>
<li>
<span class="math align-center">$\delta(q, a, X)$</span> hat höchstens ein Element für jedes 
<span class="math align-center">$q \in Q, a \in\Sigma$</span> oder 
<span class="math align-center">$(a = \epsilon$</span> und 
<span class="math align-center">$X \in \Gamma)$</span>.</li>
<li>Wenn 
<span class="math align-center">$\delta (q, a, x)$</span> nicht leer ist für ein 
<span class="math align-center">$a \in \Sigma$</span>, dann muss 
<span class="math align-center">$\delta (q, \epsilon, x)$</span> leer sein.</li>
</ul>
<p>Deterministische PDAs werden auch <em>DPDAs</em> genannt.</p>
<h2 id="der-kleine-unterschied">Der kleine Unterschied</h2>
<p><strong>Satz:</strong> Die von DPDAs akzeptierten Sprachen sind eine echte Teilmenge der von
PDAs akzeptierten Sprachen.</p>
<p>Die Sprachen, die von <em>regex</em> beschrieben werden, sind eine echte Teilmenge der von
DPDAs akzeptierten Sprachen.</p>
<h1 id="kontextfreie-grammatiken-und-sprachen">Kontextfreie Grammatiken und Sprachen</h1>
<h2 id="kontextfreie-grammatiken">Kontextfreie Grammatiken</h2>
<p><strong>Def.</strong> Eine <em>kontextfreie (cf-)</em> Grammatik ist ein 4-Tupel 
<span class="math align-center">$G = (N, T, P, S)$</span> mit <em>N, T, S</em> wie in
(formalen) Grammatiken und <em>P</em> ist eine endliche Menge von Produktionen der Form:</p>
<p>
<span class="math align-center">$X \rightarrow Y$</span> mit 
<span class="math align-center">$X \in N, Y \in {(N \cup T)}^{\ast}$</span>.</p>
<p>
<span class="math align-center">$\Rightarrow, \overset{\ast}{\Rightarrow}$</span> sind definiert wie bei regulären Sprachen. Bei cf-Grammatiken nennt man die Ableitungsbäume oft <em>Parse trees</em>.</p>
<h2 id="beispiel-1">Beispiel</h2>

<span class="math align-center">$S \rightarrow a \mid S\ +\  S\ |\  S \ast S$</span>
<p>Ableitungsbäume für 
<span class="math align-center">$a + a \ast a$</span>:</p>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="mehrdeutige-grammatiken">Mehrdeutige Grammatiken</h2>
<p><strong>Def.:</strong> Gibt es in einer von einer kontextfreien Grammatik erzeugten Sprache ein
Wort, für das mehr als ein Ableitungsbaum existiert, so heißt diese Grammatik
<em>mehrdeutig</em>. Anderenfalls heißt sie <em>eindeutig</em>.</p>
<p><strong>Satz:</strong> Es gibt kontextfreie Sprachen, für die keine eindeutige Grammatik existiert.</p>
<h2 id="kontextfreie-grammatiken-und-pdas">Kontextfreie Grammatiken und PDAs</h2>
<p><strong>Satz:</strong> Die kontextfreien Sprachen und die Sprachen, die von PDAs akzeptiert werden, sind dieselbe
Sprachklasse.</p>
<p><strong>Satz:</strong> Sei 
<span class="math align-center">$L = N(P)$</span> für einen DPDA <em>P</em>, dann hat <em>L</em> eine eindeutige Grammatik.</p>
<p><strong>Def.:</strong> Die Klasse der Sprachen, die von einem DPDA akzeptiert werden, heißt
Klasse der <em>deterministisch kontextfreien (oder LR(k)-) Sprachen</em>.</p>
<h2 id="das-pumping-lemma-für-kontextfreie-sprachen">Das Pumping Lemma für kontextfreie Sprachen</h2>
<p>Wenn wir beweisen müssen, dass eine Sprache nicht cf ist, hilft das Pumping Lemma für cf-Sprachen:</p>
<p><strong>Satz:</strong> Sei <em>L</em> eine kontextfreie Sprache</p>
<p>
<span class="math align-center">$\Rightarrow \exists$</span> eine Konstante 
<span class="math align-center">$p \in \mathbb{N}$</span>:</p>
<p>
<span class="math align-center">$\underset{\underset{|z| \geq p} {z \in L}}\forall \exists$</span> 
<span class="math align-center">$u, v, w, x, y \in \Sigma ^{\ast}$</span> mit 
<span class="math align-center">$z = uvwxy$</span> und</p>
<ul>
<li>
<span class="math align-center">$\mid vwx\mid \leq p$</span></li>
<li>
<span class="math align-center">$vx \neq \epsilon$</span></li>
<li>
<span class="math align-center">$\forall i \geq 0 : uv^i wx^i y \in L$</span></li>
</ul>
<h2 id="abschlusseigenschaften-von-kontextfreien-sprachen">Abschlusseigenschaften von kontextfreien Sprachen</h2>
<p><strong>Satz:</strong> Die kontextfreien Sprachen sind abgeschlossen unter:</p>
<ul>
<li>Vereinigung</li>
<li>Konkatenation</li>
<li>Kleene-Hüllen 
<span class="math align-center">$L^{\ast}$</span> und 
<span class="math align-center">$L^+$</span></li>
</ul>
<p><strong>Satz:</strong> Wenn <em>L</em> kontextfrei ist, dann ist 
<span class="math align-center">$L^R$</span> kontextfrei.</p>
<h2 id="entscheidbarkeit-von-kontextfreien-grammatiken-und-sprachen">Entscheidbarkeit von kontextfreien Grammatiken und Sprachen</h2>
<p><strong>Satz:</strong> Es ist entscheidbar für eine kontextfreie Grammatik <em>G</em>,</p>
<ul>
<li>ob 
<span class="math align-center">$L(G) = \emptyset$</span></li>
<li>welche Symbole nach 
<span class="math align-center">$\epsilon$</span> abgeleitet werden können</li>
<li>welche Symbole erreichbar sind</li>
<li>ob 
<span class="math align-center">$w \in L(G)$</span> für ein gegebenes 
<span class="math align-center">$w \in {\Sigma}^{\ast}$</span></li>
</ul>
<p><strong>Satz:</strong> Es ist nicht entscheidbar,</p>
<ul>
<li>ob eine gegebene kontextfreie Grammatik eindeutig ist</li>
<li>ob der Durchschnitt zweier kontextfreier Sprachen leer ist</li>
<li>ob zwei kontextfreie Sprachen identisch sind</li>
<li>ob eine gegebene kontextfreie Sprache gleich 
<span class="math align-center">$\Sigma^{\ast}$</span> ist</li>
</ul>
<h2 id="abschlusseigenschaften-deterministisch-kontextfreier-sprachen">Abschlusseigenschaften deterministisch kontextfreier Sprachen</h2>
<p><strong>Satz:</strong> Deterministisch kontextfreie Sprachen sind abgeschlossen unter</p>
<ul>
<li>Durchschnitt mit regulären Sprachen</li>
<li>Komplement</li>
</ul>
<p>Sie sind nicht abgeschlossen unter</p>
<ul>
<li>Umkehrung</li>
<li>Vereinigung</li>
<li>Konkatenation</li>
</ul>
<h1 id="wrap-up">Wrap-Up</h1>
<h2 id="das-sollen-sie-mitnehmen">Das sollen Sie mitnehmen</h2>
<ul>
<li>Die Struktur von gängigen Programmiersprachen lässt sich nicht mit regulären Ausdrücken beschreiben und damit nicht mit DFAs akzeptieren.</li>
<li>Das Automatenmodell der DFAs wird um einen endlosen Stack erweitert, das ergibt PDAs.</li>
<li>Kontextfreie Grammatiken (CFGs) erweitern die regulären Grammatiken.</li>
<li>Deterministisch parsebare Sprachen haben eine eindeutige kontextfreie Grammatik.</li>
<li>Es ist nicht entscheidbar, ob eine gegebene kontextfreie Grammatik eindeutig ist.</li>
</ul>


    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_aho2013compilers'>[aho2013compilers] <strong>Compilers: Pearson New International Edition: Principles, Techniques, and Tools</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Education Limited, 2013. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-2920-3723-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-2920-3723-3</a>.</li> <li id='id_hopcroft2003'>[hopcroft2003] <strong>Einführung in die Automatentheorie, formale Sprachen und Komplexitätstheorie</strong><br>Hopcroft, J. E. und Motwani, R. und Ullman, J. D., Pearson Education Deutschland GmbH, 2003. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7020-4' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7020-4</a>.</li></ul></div>
</div>



    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) PDAs</li> <li>(K1) Deterministische PDAs</li> <li>(K1) Kontextfreie Grammatiken</li> <li>(K1) Deterministisch kontextfreie Grammatiken</li> <li>(K2) Zusammenhang zwischen PDAs und kontextfreien Grammatiken</li></ul></div>
</div>



    








<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>LL-Parser (Theorie)</h1>



    
    




    
    
        
        
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="far fa-file-powerpoint"></i> Annotierte Folien</div>
  <div class="box-content">

<ul> <li><a href='https://raw.githubusercontent.com/Compiler-CampusMinden/AnnotatedSlides/master/ll-parser-theory.ann.ma.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Annotierte Folien: LL-Parser (Theorie)</a></li></ul></div>
</div>




    <h1 id="wiederholung">Wiederholung</h1>
<h2 id="pdas-und-kontextfreie-grammatiken">PDAs und kontextfreie Grammatiken</h2>
<ul>
<li>Warum reichen uns DFAs nicht zum Matchen von Eingabezeichen?</li>
<li>Wie könnnen wir sie minimal erweitern?</li>
<li>Sind PDAs deterministisch?</li>
<li>Wie sind kontextfreie Grammatiken definiert?</li>
<li>Sind kontextfreie Grammatiken eindeutig?</li>
</ul>
<h1 id="motivation">Motivation</h1>
<h2 id="was-brauchen-wir-für-die-syntaxanalyse-von-programmen">Was brauchen wir für die Syntaxanalyse von Programmen?</h2>
<ul>
<li>einen Grammatiktypen, aus dem sich manuell oder automatisiert ein Programm zur deterministischen Syntaxanalyse erstellen lässt</li>
<li>einen Algorithmus zum sog. Parsen von Programmen mit Hilfe einer solchen Grammatik</li>
</ul>
<h2 id="themen-für-heute">Themen für heute</h2>
<ul>
<li>Arten der Syntaxanlyse</li>
<li>mehrdeutige Sprachen</li>
<li>Top-down-Analyse</li>
<li>LL(k)-Grammtiken</li>
</ul>
<h1 id="syntaxanalyse">Syntaxanalyse</h1>
<h2 id="syntax">Syntax</h2>
<p>Wir verstehen unter Syntax eine Menge von Regeln, die die Struktur von Daten (z. B. Programmen) bestimmen.</p>
<p>Syntaxanalyse ist die Bestimmung, ob Eingabedaten einer vorgegebenen Syntax entsprechen.</p>
<p>Diese vorgegebene Syntax wird im Compilerbau mit einer Grammatik beschrieben.</p>
<h2 id="ziele-der-syntaxanalyse">Ziele der Syntaxanalyse</h2>
<ul>
<li>aussagekräftige Fehlermeldungen, wenn ein Eingabeprogramm syntaktisch nicht korrekt ist</li>
<li>evtl. Fehlerkorrektur</li>
<li>Bestimmung der syntaktischen Struktur eines Programms</li>
<li>Erstellung des AST (abstrakter Syntaxbaum): Der Parse Tree ohne Symbole, die nach der Syntaxanalyse inhaltlich irrelevant sind (z. B. Semikolons, manche Schlüsselwörter)</li>
<li>die Symboltablelle(n) mit Informationen bzgl. Bezeichner (Variable, Funktionen und Methoden, Klassen, benutzerdefinierte Typen, Parameter, ...), aber auch die Gültigkeitsbereiche.</li>
</ul>
<h2 id="arten-der-syntaxanalyse">Arten der Syntaxanalyse</h2>
<p>Die Syntax bezieht sich auf die Struktur der zu analysierenden Eingabe, z. B. einem Computerprogramm in einer Hochsprache. Diese Struktur wird mit formalen Grammatiken beschrieben. Einsetzbar sind Grammatiken, die deterministisch kontextfreie Sprachen erzeugen.</p>
<ul>
<li>Top-Down-Analyse: Aufbau des Parse trees von oben
<ul>
<li>Parsen durch rekursiven Abstieg</li>
<li>LL-Parsing</li>
</ul>
</li>
<li>Bottom-Up-Analyse: LR-Parsing</li>
</ul>
<h2 id="mehrdeutigkeiten">Mehrdeutigkeiten</h2>
<p>Wir können nur mit eindeutigen Grammatiken arbeiten, aber:</p>
<p><strong>Def.:</strong> Eine formale Sprache L heißt <em>inhärent mehrdeutige Sprache</em>, wenn jede formale Grammatik <em>G</em> mit 
<span class="math align-center">$L(G) = L$</span> mehrdeutig ist.</p>
<p>Das heißt, solche Grammatiken existieren.</p>
<p>
<span class="math align-center">$\Rightarrow$</span> Es gibt keinen generellen Algorithmus, um Grammatiken eindeutig zu machen.</p>
<h2 id="bevor-wir-richtig-anfangen">Bevor wir richtig anfangen...</h2>
<p><strong>Def.:</strong> Ein Nichtterminal <em>A</em> einer kontextfreien Grammatik <em>G</em> heißt <em>unerreichbar</em>, falls es kein 
<span class="math align-center">$a,b \in {(N \cup T)}^{\ast}$</span> gibt mit 
<span class="math align-center">$S \overset{\ast}{\Rightarrow} aAb$</span>. Ein Nichtterminal <em>A</em> einer Grammatik <em>G</em> heißt <em>nutzlos</em>, wenn es kein Wort 
<span class="math align-center">$w \in T^{\ast}$</span> gibt mit 
<span class="math align-center">$A \overset{\ast}{\Rightarrow} w$</span>.</p>
<p><strong>Def.:</strong> Eine kontextfreie Grammatik 
<span class="math align-center">$G=(N, T, P, S)$</span> heißt <em>reduziert</em>, wenn es keine nutzlosen oder unerreichbaren Nichtterminale in <em>N</em> gibt.</p>
<p>Bevor mit einer Grammatik weitergearbeitet wird, müssen erst alle nutzlosen und dann alle unerreichbaren Symbole eliminiert werden. Wir betrachten ab jetzt nur reduzierte Grammatiken.</p>
<h1 id="top-down-analyse">Top-Down-Analyse</h1>
<h2 id="wie-würden-sie-manuell-parsen">Wie würden Sie manuell parsen?</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="algorithmus-rekursiver-abstieg">Algorithmus: Rekursiver Abstieg</h2>
<p>Hier ist ein einfacher Algorithmus, der (indeterministisch) einen Ableitungsbaum vom Nonterminal <em>X</em> von oben nach unten aufbaut:</p>
<p><strong>Eingabe:</strong> Ein Nichtterminal 
<span class="math align-center">$X$</span> und das nächste zu verarbeitende Eingabezeichen 
<span class="math align-center">$a$</span>.</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory/recursive_descent.png" alt="Recursive Descent-Algorithmus" width="55%" height="auto">
    <figcaption><p>Recursive Descent-Algorithmus</p></figcaption>
</figure>
<h2 id="grenzen-des-algorithmus">Grenzen des Algorithmus</h2>
<p>Was ist mit</p>
<ol>
<li>
<span class="math align-center">$X \rightarrow a \alpha \mid b \beta$</span></li>
<li>
<span class="math align-center">$X \rightarrow B\alpha \mid C \beta$</span></li>
<li>
<span class="math align-center">$X \rightarrow B \alpha \mid B \beta$</span></li>
<li>
<span class="math align-center">$X \rightarrow B \alpha \mid C \beta$</span> und 
<span class="math align-center">$C\rightarrow B$</span></li>
<li>
<span class="math align-center">$X \rightarrow X \beta$</span></li>
<li>
<span class="math align-center">$X \rightarrow B \alpha$</span> und 
<span class="math align-center">$B \rightarrow X \beta$</span></li>
</ol>
<p>
<span class="math align-center">$X, B, C, D \in N^{\ast}; a, b, c, d \in T^{\ast}; \beta$</span>, 
<span class="math align-center">$\alpha, \beta \in (N \cup T)^{\ast}$</span></p>
<h2 id="linksfaktorisierung">Linksfaktorisierung</h2>

<span class="math align-center">$X \rightarrow BC\  \vert \  BD$</span>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="algorithmus-linksfaktorisierung">Algorithmus: Linksfaktorisierung</h2>
<p><strong>Eingabe:</strong> Eine Grammatik G = (N, T, P, S)</p>
<p><strong>Ausgabe:</strong> Eine äquivalente links-faktorisierte Grammatik 
<span class="math align-center">$G'$</span></p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory/Linksfaktorisierung.png" alt="Algorithmus zur Linksfaktorisierung" width="85%" height="auto">
    <figcaption><p>Algorithmus zur Linksfaktorisierung</p></figcaption>
</figure>
<h2 id="linksrekursion">Linksrekursion</h2>
<p><strong>Def.:</strong> Eine Grammatik 
<span class="math align-center">$G=(N, T, P, S)$</span> heißt <em>linksrekursiv</em>, wenn sie ein Nichtterminal <em>X</em> hat, für das es eine Ableitung 
<span class="math align-center">$X \overset{+}{\Rightarrow} X\ \alpha$</span> für ein 
<span class="math align-center">$\alpha \in (N \cup T)^{\ast}$</span> gibt.</p>
<p>Linksrekursion gibt es</p>
<p><em>direkt</em>: 
<span class="math align-center">$X \rightarrow X \alpha$</span></p>
<p>und</p>
<p><em>indirekt</em>: 
<span class="math align-center">$X \rightarrow \ldots \rightarrow \ldots \rightarrow X \alpha$</span></p>
<h2 id="algorithmus-entfernung-von-direkter-linksrekursion" class="fragile">Algorithmus: Entfernung von direkter Linksrekursion</h2>
<p><strong>Eingabe:</strong> Eine Grammatik G = (N, T, P, S)</p>
<p><strong>Ausgabe:</strong> Eine äquivalente Grammatik 
<span class="math align-center">$G'$</span> ohne direkte Linksrekursion</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory/direkte_Linksrekursion_Elim.png" alt="Algorithmus zur Entfernung direkter Linksrekursion" width="55%" height="auto">
    <figcaption><p>Algorithmus zur Entfernung direkter Linksrekursion</p></figcaption>
</figure>
<h2 id="algorithmus-entfernung-von-indirekter-linksrekursion" class="fragile">Algorithmus: Entfernung von indirekter Linksrekursion</h2>
<p><strong>Eingabe:</strong> Eine Grammatik G = (N, T, P, S) mit 
<span class="math align-center">$N= \lbrace X_1, X_2, \ldots X_n\rbrace$</span> ohne 
<span class="math align-center">$\epsilon$</span>-Regeln oder Zyklen der Form 
<span class="math align-center">$X_1 \rightarrow X_2, X_2 \rightarrow X_3, \ldots X_{m-1} \rightarrow X_m, X_m \rightarrow X_1$</span></p>
<p><strong>Ausgabe:</strong> Eine äquivalente Grammatik 
<span class="math align-center">$G'$</span> ohne Linksrekursion</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory/indirekte_Linksrekursion_Elim.png" alt="Algorithmus zur Entfernung indirekter Linksrekursion" width="60%" height="auto">
    <figcaption><p>Algorithmus zur Entfernung indirekter Linksrekursion</p></figcaption>
</figure>
<h1 id="arbeiten-mit-generierten-parsern-llk-grammatiken">Arbeiten mit generierten Parsern: LL(k)-Grammatiken</h1>
<h2 id="first-mengen">First-Mengen</h2>

<span class="math align-center">$S \rightarrow A \ \vert \ B \ \vert \ C$</span>
<p>Welche Produktion nehmen?</p>
<p>Wir brauchen die &quot;terminalen k-Anfänge&quot; von Ableitungen von Nichtterminalen, um eindeutig die nächste zu benutzende Produktion festzulegen. 
<span class="math align-center">$k$</span> ist dabei die Anzahl der Vorschautoken.</p>
<p><strong>Def.:</strong> Wir definieren 
<span class="math align-center">$First$</span> - Mengen einer Grammatik wie folgt:</p>
<ul>
<li>
<span class="math align-center">$a \in T^\ast, |a| \leq k: {First}_k (a) = \lbrace a\rbrace$</span></li>
<li>
<span class="math align-center">$a \in T^\ast, |a| > k: {First}_k (a) = \lbrace v \in T^\ast \mid a = vw, |v| = k\rbrace$</span></li>
<li>
<span class="math align-center">$\alpha \in (N \cup T)^\ast \backslash T^\ast: {First}_k (\alpha) = \lbrace v \in T^\ast \mid \alpha \overset{\ast}{\Rightarrow} w,\text{mit}\ w \in T^\ast, First_k(w) = \lbrace v \rbrace \rbrace$</span></li>
</ul>
<h2 id="linksableitungen">Linksableitungen</h2>
<p><strong>Def.:</strong> Bei einer kontextfreien Grammatik 
<span class="math align-center">$G$</span> ist die <em>Linksableitung</em> von 
<span class="math align-center">$\alpha \in (N \cup T)^{\ast}$</span> die Ableitung, die man erhält, wenn in jedem Schritt das am weitesten links stehende Nichtterminal in 
<span class="math align-center">$\alpha$</span> abgeleitet wird.</p>
<p>Man schreibt 
<span class="math align-center">$\alpha \overset{\ast}{\Rightarrow}_l \beta.$</span></p>
<h2 id="follow-mengen">Follow-Mengen</h2>
<p>Manchmal müssen wir wissen, welche terminalen Zeichen hinter einem Nichtterminal stehen können.</p>
<p><strong>Def.</strong> Wir definieren <em>Follow</em> - Mengen einer Grammatik wie folgt:</p>

<span class="math align-center">$\forall \beta \in (N \cup T)^*:$</span>

<span class="math align-center">$$Follow_k(\beta) = \lbrace w \in T^\ast \mid \exists \alpha, \gamma \in  (N \cup T)^\ast\ \text{ mit }\ S \overset{\ast}{\Rightarrow}_l \alpha \beta \gamma\ \text{ und }\ w \in First_k(\gamma) \rbrace$$</span>
<h2 id="llk-grammatiken">LL(k)-Grammatiken</h2>
<p><strong>Def.:</strong> Eine kontextfreie Grammatik <em>G = (N, T, P, S)</em> ist genau dann eine <em>LL(k)</em>-Grammatik, wenn für alle Linksableitungen der Form:</p>

<span class="math align-center">$S \overset{\ast}{\Rightarrow}_l\ wA \gamma\ {\Rightarrow}_l\ w\alpha\gamma \overset{\ast}{\Rightarrow}_l wx$</span>
<p>und</p>

<span class="math align-center">$S \overset{\ast}{\Rightarrow}_l wA \gamma {\Rightarrow}_l w\beta\gamma \overset{\ast}{\Rightarrow}_l wy$</span>
<p>mit 
<span class="math align-center">$(w, x, y \in T^\ast, \alpha, \beta, \gamma \in (N \cup T)^\ast, A \in N)$</span> und 
<span class="math align-center">$First_k(x) = First_k(y)$</span>
gilt:</p>

<span class="math align-center">$\alpha = \beta$</span>
<h2 id="llk-grammatiken-1">LL(k)-Grammatiken</h2>
<p>Das hilft manchmal:</p>
<p>Für 
<span class="math align-center">$k = 1$</span>:
G ist 
<span class="math align-center">$LL(1): \forall A \rightarrow \alpha, A \rightarrow \beta \in P, \alpha \neq \beta$</span> gilt:</p>
<ol>
<li>
<span class="math align-center">$\lnot \exists a \in T: \alpha \overset{\ast}{\Rightarrow}_l a\alpha_1$</span> und 
<span class="math align-center">$\beta \overset{\ast}{\Rightarrow}_l a\beta_1$</span></li>
<li>
<span class="math align-center">$((\alpha \overset{\ast}{\Rightarrow}_l \epsilon) \Rightarrow (\lnot (\beta \overset{\ast}{\Rightarrow}_l \epsilon)))$</span> und 
<span class="math align-center">$((\beta \overset{\ast}{\Rightarrow}_l \epsilon) \Rightarrow (\lnot (\alpha\overset{\ast}{\Rightarrow}_l \epsilon)))$</span></li>
<li>
<span class="math align-center">$((\beta \overset{\ast}{\Rightarrow}_l \epsilon)$</span> und 
<span class="math align-center">$(\alpha \overset{\ast}{\Rightarrow}_l a\alpha_1)) \Rightarrow a \notin Follow(A)$</span></li>
<li>
<span class="math align-center">$((\alpha \overset{\ast}{\Rightarrow}_l \epsilon)$</span> und 
<span class="math align-center">$(\beta \overset{\ast}{\Rightarrow}_l a\beta_1)) \Rightarrow a \notin Follow(A)$</span></li>
</ol>
<p>Die ersten beiden Zeilen bedeuten:</p>
<p>
<span class="math align-center">$\alpha$</span> und 
<span class="math align-center">$\beta$</span> können nicht beide 
<span class="math align-center">$\epsilon$</span> ableiten, 
<span class="math align-center">$First_1(\alpha) \cap First_1(\beta) = \emptyset$</span></p>
<p>Die dritte und vierte Zeile bedeuten:</p>

<span class="math align-center">$(\epsilon \in First_1(\beta)) \Rightarrow (First_1(\alpha) \cap Follow_1(A) = \emptyset)$</span>

<span class="math align-center">$(\epsilon \in First_1(\alpha)) \Rightarrow (First_1(\beta) \cap Follow_1(A) = \emptyset)$</span>
<h2 id="ll1-grammatiken">LL(1)-Grammatiken</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="llk-sprachen">LL(k)-Sprachen</h2>
<p>Die von <em>LL(k)</em>-Grammatiken erzeugten Sprachen sind eine echte Teilmenge der deterministisch parsbaren Sprachen.</p>
<p>Die von <em>LL(k)</em>-Grammatiken erzeugten Sprachen sind eine echte Teilmenge der von <em>LL(k+1)</em>-Grammatiken erzeugten Sprachen.</p>
<p>Für eine kontextfreie Grammatik <em>G</em> ist nicht entscheidbar, ob es eine <em>LL(1)</em> - Grammatik <em>G'</em> gibt mit 
<span class="math align-center">$L(G) = L(G')$</span>.</p>
<p>In der Praxis reichen 
<span class="math align-center">$LL(1)$</span> - Grammatiken oft. Hier gibt es effiziente Parsergeneratoren, deren Eingabe eine LL(k)- (meist LL(1)-) Grammatik ist, und die als Ausgabe den Quellcode eines (effizienten) tabellengesteuerten Parsers generieren.</p>
<h2 id="algorithmus-konstruktion-einer-ll-parsertabelle" class="fragile">Algorithmus: Konstruktion einer LL-Parsertabelle</h2>
<p><strong>Eingabe:</strong> Eine Grammatik G = (N, T, P, S)</p>
<p><strong>Ausgabe:</strong> Eine Parsertabelle <em>P</em></p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory/LL-Parsertabelle.png" alt="Algorithmus zur Generierung einer LL-Parsertabelle" width="60%" height="auto">
    <figcaption><p>Algorithmus zur Generierung einer LL-Parsertabelle</p></figcaption>
</figure>
<p>Hier ist 
<span class="math align-center">$\perp$</span> das Endezeichen des Inputs.
Statt 
<span class="math align-center">$First_1(\alpha)$</span> und 
<span class="math align-center">$Follow_1(\alpha)$</span> wird oft nur 
<span class="math align-center">$First(\alpha)$</span> und 
<span class="math align-center">$Follow(\alpha)$</span> geschrieben.</p>
<h2 id="ll-parsertabellen">LL-Parsertabellen</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="ll-parsertabellen-1">LL-Parsertabellen</h2>
<p>Rekursive Programmierung bedeutet, dass das Laufzeitsystem einen Stack benutzt (bei einem Recursive-Descent-Parser, aber auch bei der Parsertabelle). Diesen Stack kann man auch &quot;selbst programmieren&quot;, d. h. einen PDA implementieren. Dabei wird ebenfalls die oben genannte Tabelle zur Bestimmung der nächsten anzuwendenden Produktion benutzt. Der Stack enthält die zu erwartenden Eingabezeichen, wenn immer eine Linksableitung gebildet wird. Diese Zeichen im Stack werden mit dem Input gematcht.</p>
<h2 id="algorithmus-tabellengesteuertes-ll-parsen-mit-einem-pda" class="fragile">Algorithmus: Tabellengesteuertes LL-Parsen mit einem PDA</h2>
<p><strong>Eingabe:</strong> Eine Grammatik G = (N, T, P, S), eine Parsertabelle <em>P</em> mit 
<span class="math align-center">$w\perp$</span> als initialem Kellerinhalt</p>
<p><strong>Ausgabe:</strong> Wenn 
<span class="math align-center">$w \in L(G)$</span>, eine Linksableitung von 
<span class="math align-center">$w$</span>, Fehler sonst</p>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-parser-theory/LL-Parser.png" alt="Algorithmus zum tabellengesteuerten LL-Parsen" width="50%" height="auto">
    <figcaption><p>Algorithmus zum tabellengesteuerten LL-Parsen</p></figcaption>
</figure>
<p>Der Eingabestring sei 
<span class="math align-center">$w\perp$</span>, der initiale Kellerinhalt sei 
<span class="math align-center">$\perp$</span>.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>Syntaxanalyse wird mit deterministisch kontextfreien Grammatiken durchgeführt.</li>
<li>Eine Teilmenge der dazu gehörigen Sprachen lässt sich top-down parsen.</li>
<li>Ein einfacher Recursive-Descent-Parser arbeitet mit Backtracking.</li>
<li>Ein effizienter LL(k)-Parser realisiert einen DPDA und kann automatisch aus einer LL(k)-Grammatik generiert werden.</li>
<li>Der Parser liefert in der Regel einen abstrakten Syntaxbaum.</li>
</ul>


    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_aho2013compilers'>[aho2013compilers] <strong>Compilers: Pearson New International Edition: Principles, Techniques, and Tools</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Education Limited, 2013. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-2920-3723-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-2920-3723-3</a>.</li> <li id='id_hopcroft2003'>[hopcroft2003] <strong>Einführung in die Automatentheorie, formale Sprachen und Komplexitätstheorie</strong><br>Hopcroft, J. E. und Motwani, R. und Ullman, J. D., Pearson Education Deutschland GmbH, 2003. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7020-4' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7020-4</a>.</li></ul></div>
</div>



    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) Top-Down-Analyse</li> <li>(K1) Recursive-Descent-Parser</li> <li>(K1) First- und Follow-Mengen</li> <li>(K1) LL-Parser</li> <li>(K2) Zusammenhang zwischen PDAs und kontextfreien Grammatiken</li> <li>(K2) Schreiben von LL-Parsern</li> <li>(K3) Top-Down Analyse programmieren</li></ul></div>
</div>



    








<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>LL-Parser selbst implementiert</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p><a href="#R-image-50771504926c371efe57cccd005207e1" class="lightbox-link"><img src="images/architektur_cb_parser.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-50771504926c371efe57cccd005207e1"><img src="images/architektur_cb_parser.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>LL-Parser können über einen &quot;rekursiven Abstieg&quot; direkt aus einer Grammatik implementiert werden:</p>
<ul>
<li>Zu jeder Produktionsregel erstellt man eine gleichnamige Funktion.</li>
<li>Wenn in der Produktionsregel andere Regeln &quot;aufgerufen&quot; werden, erfolgt in der Funktion an
dieser Stelle der entsprechende Funktionsaufruf.</li>
<li>Bei Terminalsymbolen wird das erwartete Token geprüft.</li>
</ul>
<p>Dabei findet man wie bereits im Lexer die Funktionen <code>match</code> und <code>consume</code>, die sich hier aber
auf den Tokenstrom beziehen. LL(1)-Parser schauen dabei immer das nächste Token an, LL(k) haben
ein entsprechendes Look-Ahead von 
<span class="math align-center">$k$</span> Token. Dies kann man mit einem Ringpuffer für die Token
realisieren.</p>
<p>Zur Beachtung der Vorrang- und Assoziativitätsregeln muss die Grammatik entsprechend umgebaut
werden. LL-Parser haben durch die Betrachtung des aktuellen Vorschau-Tokens ein Problem mit
Linksrekursion in der Grammatik, diese muss zunächst beseitigt werden. (ANTLR bietet hier gewisse
Vereinfachungen an, kann aber mit indirekter Linksrekursion auch nicht umgehen.)</p>
<p>Eine gute Darstellung finden Sie in <a href="#id_Parr2010">[Parr2010]</a> (Kapitel 2).</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/3djLtMtW82k' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL LL-Parser selbst implementiert</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/fc75fe2bfb0c45447689e386f3e0c227bb30a0d081374134c60e20392a1f8c54536a749aefec5c5825c4d8c9e9aa77c30b37acb56e9b3c314da17691d9c5eee8' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL LL-Parser selbst implementiert</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K2) Prinzipieller Aufbau von LL-Parsern</li> <li>(K3) Implementierung von LL(1)- und LL(k)-Parsern</li> <li>(K3) Implementierung von Vorrang und Assoziativität</li> <li>(K3) Umgang mit Linksrekursion, insbesondere bei ANTLR</li></ul></div>
</div>




    <h2 id="erinnerung-lexer-zeichenstrom--tokenstrom">Erinnerung Lexer: Zeichenstrom =&gt; Tokenstrom</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">nextToken</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (peek <span style="color:#f92672">!=</span> EOF):  <span style="color:#75715e"># globale Variable, über consume()</span>
</span></span><span style="display:flex;"><span>        switch (peek):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39; &#39;</span>: <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#39;</span>: <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>: WS(); <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;[&#39;</span>: consume(); <span style="color:#66d9ef">return</span> Token(LBRACK, <span style="color:#e6db74">&#39;[&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>            default: <span style="color:#66d9ef">raise</span> Error(<span style="color:#e6db74">&#34;invalid character: &#34;</span><span style="color:#f92672">+</span>peek)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Token(EOF_Type, <span style="color:#e6db74">&#34;&lt;EOF&gt;&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">match</span>(c):   <span style="color:#75715e"># Lookahead: Ein Zeichen</span>
</span></span><span style="display:flex;"><span>    consume()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (peek <span style="color:#f92672">==</span> c): <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: rollBack(); <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">consume</span>():
</span></span><span style="display:flex;"><span>    peek <span style="color:#f92672">=</span> buffer[start]
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> (start<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) mod <span style="color:#ae81ff">2</span>n
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (start mod n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>        fill(buffer[start:start<span style="color:#f92672">+</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>        end <span style="color:#f92672">=</span> (start<span style="color:#f92672">+</span>n) mod <span style="color:#ae81ff">2</span>n</span></span></code></pre></div><p>Erinnerung: Der Lexer arbeitet direkt auf dem Zeichenstrom und versucht über längste Matches daraus
einen Tokenstrom zu erzeugen. Dabei wird immer das nächste Zeichen angeschaut (Funktion <code>match</code>) und
mit <code>consume</code> das aktuelle Zeichen &quot;verbraucht&quot; und das nächste Zeichen geladen. Hier kann man über
die Doppel-Puffer-Strategie das Einlesen einzelner Zeichen aus einer Datei vermeiden und immer blockweise
in den Puffer einlesen.</p>
<h2 id="grundidee-ll-parser">Grundidee LL-Parser</h2>
<p>Grammatik:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>r : <span style="color:#66d9ef">X</span> s ;</span></span></code></pre></div><p>LL-Implementierung:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">r</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span>(X)
</span></span><span style="display:flex;"><span>    s()</span></span></code></pre></div><ul>
<li>Für jede Regel in der Grammatik wird eine Methode/Funktion mit dem selben Namen definiert</li>
<li>Referenzen auf ein Token <code>T</code> werden durch den Aufruf der Methode <code>match(T)</code> aufgelöst
<ul>
<li><code>match(T)</code> &quot;konsumiert&quot; das aktuelle Token, falls dieses mit <code>T</code> übereinstimmt</li>
<li>Anderenfalls löst <code>match()</code> eine Exception aus</li>
</ul>
</li>
<li>Referenzen auf Regeln <code>s</code> werden durch Methodenaufrufe <code>s()</code> aufgelöst</li>
</ul>
<p><em>Erinnerung</em>: In ANTLR werden Parser-Regeln (non-Terminale) mit einem kleinen und Lexer-Regeln
(Terminale/Token) mit einem großen Anfangsbuchstaben geschrieben.</p>
<h2 id="alternative-subregeln">Alternative Subregeln</h2>
<pre><code>a | b | c
</code></pre>
<p>kann zu einem <code>switch</code>-Konstrukt aufgelöst werden:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>switch (lookahead):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> predicting_a:
</span></span><span style="display:flex;"><span>        a(); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> predicting_b:
</span></span><span style="display:flex;"><span>        b(); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    default: <span style="color:#66d9ef">raise</span> Error()</span></span></code></pre></div><p>Dabei ist <code>lookahead</code> eine globale Variable, die das zu betrachtende Token enthält
(vergleichbar mit <code>peek</code> beim Lexer).</p>
<p>Das Prädikat <code>predicting_a</code> soll andeuten, dass man mit dem aktuellen Token eine
Vorhersage für die Regel <code>a</code> versucht (hier kommen die FIRST- und FOLLOW-Mengen
ins Spiel ...). Wenn das der Fall ist, springt man entsprechend in die Funktion
bzw. Methode <code>a()</code>.</p>
<h2 id="optionale-subregeln-eins-oder-keins">Optionale Subregeln: Eins oder keins</h2>
<pre><code>(T)?
</code></pre>
<p>wird zu einem <code>if</code> ohne <code>else</code>-Teil:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> lookahead<span style="color:#f92672">.</span>predicting_T: <span style="color:#66d9ef">match</span>(T)</span></span></code></pre></div><h2 id="optionale-subregeln-mindestens-eins">Optionale Subregeln: Mindestens eins</h2>
<pre><code>(T)+
</code></pre>
<p>wird zu einer <code>do-while</code>-Schleife (mind. ein Durchlauf):</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span>(T)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> lookahead<span style="color:#f92672">.</span>predicting_T: <span style="color:#66d9ef">break</span></span></span></code></pre></div><h2 id="ll1-parser">LL(1)-Parser</h2>
<p>Beispiel: Parsen von Listen, also Sequenzen wie <code>[1,2,3,4]</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>list     : <span style="color:#e6db74">&#39;[&#39;</span> elements <span style="color:#e6db74">&#39;]&#39;</span> ;
</span></span><span style="display:flex;"><span>elements : <span style="color:#66d9ef">INT</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;,&#39;</span> <span style="color:#66d9ef">INT</span><span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>INT      : <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">..</span><span style="color:#e6db74">&#39;9&#39;</span><span style="color:#f92672">)+</span> ;</span></span></code></pre></div><p>Formal berechnet man die Lookahead-Mengen mit <code>FIRST</code> und <code>FOLLOW</code>, um eine Entscheidung
für die nächste Regel zu treffen. Praktisch betrachtet kann man sich fragen, welche(s)
Token eine Phrase in der aktuellen Alternative starten können.</p>
<p>Für LL(1)-Parser betrachtet man immer das <strong>aktuelle</strong> Token (<strong>genau <em>EIN</em> Lookahead-Token</strong>),
um eine Entscheidung zu treffen.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">list</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span>(LBRACK); elements(); <span style="color:#66d9ef">match</span>(RBRACK);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">elements</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span>(INT)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> lookahead <span style="color:#f92672">==</span> COMMA:  <span style="color:#75715e"># globale Variable, über consume()</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span>(COMMA); <span style="color:#66d9ef">match</span>(INT)</span></span></code></pre></div><h2 id="detail-match-und-consume">Detail: <em>match()</em> und <em>consume()</em></h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">match</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> lookahead <span style="color:#f92672">==</span> x: consume()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">Exception</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">consume</span>():
</span></span><span style="display:flex;"><span>    lookahead <span style="color:#f92672">=</span> lexer<span style="color:#f92672">.</span>nextToken()</span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, p. 43]</a></span></p>
<p>Dabei setzt man in der Klasse <code>Parser</code> zwei Attribute voraus:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Parser</span>:
</span></span><span style="display:flex;"><span>    Lexer lexer
</span></span><span style="display:flex;"><span>    Token lookahead</span></span></code></pre></div><p>Starten würde man den Parser nach dem Erzeugen einer Instanz (dabei wird ein Lexer mit
durchgereicht) über den Aufruf der Start-Regel, also beispielsweise <code>parser.list()</code>.</p>
<p><em>Anmerkung</em>: Mit dem generierten Parse-Tree bzw. <em>AST</em> beschäftigen wir uns später
(=&gt; <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/astdriven-part1.html">AST-basierte Interpreter</a>).</p>
<h2 id="vorrangregeln">Vorrangregeln</h2>
<pre><code>1+2*3 == 1+(2*3) != (1+2)*3
</code></pre>
<p>Die Eingabe <code>1+2*3</code> muss als <code>1+(2*3)</code> interpretiert werden, da <code>*</code> Vorrang vor <code>+</code> hat.</p>
<p>Dies formuliert man üblicherweise in der Grammatik:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : expr <span style="color:#e6db74">&#39;+&#39;</span> term
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> term
</span></span><span style="display:flex;"><span>     ;
</span></span><span style="display:flex;"><span>term : term <span style="color:#e6db74">&#39;*&#39;</span> <span style="color:#66d9ef">INT</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">INT</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p>ANTLR nutzt die Strategie des <a href="https://www.antlr.org/papers/Clarke-expr-parsing-1986.pdf" target="_blank">&quot;<em>precedence climbing</em>&quot;</a>
und löst nach der <em>Reihenfolge der Alternativen</em> in einer Regel auf. Entsprechend könnte man die obige Grammatik
unter Beibehaltung der Vorrangregeln so in ANTLR (v4) formulieren:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : expr <span style="color:#e6db74">&#39;*&#39;</span> expr
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;+&#39;</span> expr
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">INT</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><h2 id="linksrekursion">Linksrekursion</h2>
<p>Normalerweise sind linksrekursive Grammatiken nicht mit einem LL-Parser behandelbar. Man muss die Linksrekursion
manuell auflösen und die Grammatik umschreiben.</p>
<p><strong>Beispiel</strong>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : expr <span style="color:#e6db74">&#39;*&#39;</span> expr <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;+&#39;</span> expr <span style="color:#f92672">|</span> <span style="color:#66d9ef">INT</span> ;</span></span></code></pre></div><p>Diese linksrekursive Grammatik könnte man (unter Beachtung der Vorrangregeln) etwa so umformulieren:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr     : addExpr ;
</span></span><span style="display:flex;"><span>addExpr  : multExpr <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;+&#39;</span> multExpr<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>multExpr : <span style="color:#66d9ef">INT</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;*&#39;</span> <span style="color:#66d9ef">INT</span><span style="color:#f92672">)*</span> ;</span></span></code></pre></div><p>ANTLR (v4) kann Grammatiken mit <em>direkter</em> Linksrekursion auflösen. Für frühere Versionen von ANTLR muss man die
Rekursion manuell beseitigen.</p>
<p>Vergleiche <a href="https://www.antlr.org/papers/allstar-techreport.pdf" target="_blank">&quot;ALL(*)&quot; bzw. &quot;Adaptive LL(*)&quot;</a>.</p>
<p><strong>Achtung</strong>: Mit <em>indirekter</em> Linksrekursion kann ANTLR (v4) <em>nicht</em> umgehen:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : expM <span style="color:#f92672">|</span> <span style="color:#f92672">...</span> ;
</span></span><span style="display:flex;"><span>expM : expr <span style="color:#e6db74">&#39;*&#39;</span> expr ;</span></span></code></pre></div><p>=&gt; <em>Nicht</em> erlaubt!</p>
<h2 id="assoziativität">Assoziativität</h2>
<p>Die Eingabe <code>2^3^4</code> sollte als <code>2^(3^4)</code> geparst werden. Analog sollte <code>a=b=c</code> in C als <code>a=(b=c)</code> verstanden werden.</p>
<p>Per Default werden Operatoren wie <code>+</code> in ANTLR <em>links-assoziativ</em> behandelt, d.h. die Eingabe <code>1+2+3</code> wird
als <code>(1+2)+3</code> gelesen. Für <em>rechts-assoziative</em> Operatoren muss man ANTLR dies in der Grammatik mitteilen:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : expr <span style="color:#e6db74">&#39;^&#39;</span><span style="color:#960050;background-color:#1e0010">&lt;</span>assoc<span style="color:#f92672">=</span>right<span style="color:#960050;background-color:#1e0010">&gt;</span> expr
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">INT</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p><em>Anmerkung</em>: Laut <a href="https://github.com/antlr/antlr4/blob/master/doc/left-recursion.md" target="_blank">Doku</a> gilt die Angabe
<code>&lt;assoc=right&gt;</code> immer für die jeweilige Alternative und muss seit Version 4.2 an den Alternativen-Operator <code>|</code>
geschrieben werden. In der Übergangsphase sei die Annotation an Tokenreferenzen noch zulässig, würde aber
ignoriert?!</p>
<h2 id="llk-parser">LL(k)-Parser</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;++&#39;</span>    <span style="color:#75715e">// x++</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;--&#39;</span>    <span style="color:#75715e">// x--</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p>Die obige Regel ist für einen LL(1)-Parser nicht deterministisch behandelbar, da die Alternativen
mit dem selben Token beginnen (die Lookahead-Mengen überlappen sich). Entweder benötigt man zwei
Lookahead-Tokens, also einen LL(2)-Parser, oder man muss die Regel in eine äquivalente LL(1)-Grammatik
umschreiben:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : <span style="color:#66d9ef">ID</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;++&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;--&#39;</span><span style="color:#f92672">)</span> ;    <span style="color:#75715e">// x++ oder x--</span></span></span></code></pre></div><h2 id="llk-parser-implementierung-mit-ringpuffer">LL(k)-Parser: Implementierung mit Ringpuffer</h2>
<p>Für einen größeren Lookahead benötigt man einen Puffer für die Token. Für einen Lookahead von

<span class="math align-center">$k$</span> Token (also einen LL(k)-Parser) würde man einen Puffer mit 
<span class="math align-center">$k$</span> Plätzen anlegen und diesen
wie einen Ringpuffer benutzen. Dabei ist <code>start</code> der Index des aktuellen Lookahead-Tokens. Über
die neue Funktion <code>lookahead(1)</code> ist dieses aktuelle Lookahead-Token abrufbar.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Parser</span>:
</span></span><span style="display:flex;"><span>    Lexer lexer
</span></span><span style="display:flex;"><span>    k <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>               <span style="color:#75715e"># Lookahead: 3 Token =&gt; LL(3)</span>
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>           <span style="color:#75715e"># aktuelle Tokenposition im Ringpuffer</span>
</span></span><span style="display:flex;"><span>    Token[k] lookahead  <span style="color:#75715e"># Ringpuffer mit k Plätzen (vorbefüllt via Konstruktor)</span></span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">match</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> lookahead(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> x: consume()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">Exception</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">consume</span>():
</span></span><span style="display:flex;"><span>    lookahead[start] <span style="color:#f92672">=</span> lexer<span style="color:#f92672">.</span>nextToken()
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> (start<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> k
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lookahead</span>(i):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> lookahead[(start<span style="color:#f92672">+</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> k]  <span style="color:#75715e"># i==1: start</span></span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, p. 47]</a></span></p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>LL(1) und LL(k) mit festem Lookahead</li>
<li>Implementierung von Vorrang- und Assoziativitätsregeln</li>
<li>Beachtung und Auflösung von Linksrekursion</li>
</ul>


    



    



    

    
<div class="box notices cstyle note">
  <div class="box-label"><i class="fas fa-puzzle-piece"></i> Challenges</div>
  <div class="box-content">

<ul>
<li>Wie kann man aus einer LL(1)-Grammatik einen LL(1)-Parser mit rekursivem Abstieg implementieren? Wie &quot;übersetzt&quot; man dabei Token und Regeln?</li>
<li>Wie geht man mit Alternativen um? Wie mit optionalen Subregeln?</li>
<li>Warum ist Linksrekursion i.A. bei LL-Parsern nicht erlaubt? Wie kann man Linksrekursion beseitigen?</li>
<li>Wie kann man Vorrangregeln implementieren?</li>
<li>Wann braucht man mehr als ein Token Lookahead? Geben Sie ein Beispiel an.</li>
</ul>
</div>
</div>



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Abschnitte 2.4 und 4.4</em></li> <li id='id_Grune2012'>[Grune2012] <strong>Modern Compiler Design</strong><br>Grune, D. und van, Reeuwijk, K. und Bal, H. E. und Jacobs, C. J. H. und Langendoen, K., Springer, 2012. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-4614-4698-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-4614-4698-9</a>.<br><em>Abschnitte 3.1 bis (einschließlich) 3.4</em></li> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 2 (insbesondere Abschnitte 2.3 bis (einschließlich) 2.19)</em></li> <li id='id_Parr2010'>[Parr2010] <strong>Language Implementation Patterns</strong><br>Parr, T., Pragmatic Bookshelf, 2010. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5645-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5645-6</a>.<br><em>Kapitel 2</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>LL-Parser: Fortgeschrittene Techniken</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p><a href="#R-image-fe0b6cbbf79deae0be869c70351cc1e3" class="lightbox-link"><img src="images/architektur_cb_parser.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fe0b6cbbf79deae0be869c70351cc1e3"><img src="images/architektur_cb_parser.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Man kann einen LL(k)-Parser bei Bedarf um ein &quot;spekulatives Matching&quot; ergänzen. Dies ist in Situationen
relevant, wo man das 
<span class="math align-center">$k$</span> nicht vorhersehen kann, etwa bei der Unterscheidung einer Vorwärtsdeklaration
und einer Funktionsdefinition in C. Hier kann man erst nach dem Parsen des Funktionsnamens entscheiden,
welche Situation vorliegt; der Funktionsname kann dabei (nahezu) beliebig lang sein.</p>
<p>Beim spekulativen Matching muss man sich merken, an welcher Position im Tokenstrom man die Spekulation
gestartet hat, um im Fall des Nichterfolgs dorthin wieder zurückspringen zu können (&quot;Backtracking&quot;).</p>
<p>Das Backtracking kann sehr langsam werden durch das Ausprobieren mehrerer Alternativen und das jeweils
nötige Zurückrollen. Zudem kann es passieren, dass eine bestimmte Sequenz immer wieder erkannt werden
muss. Hier hilft eine weitere Technik: <strong>Packrat Parsing</strong> <a href="#id_Packrat2006">[Packrat2006]</a> (nutzt
<a href="https://en.wikipedia.org/wiki/Memoization" target="_blank">&quot;<em>memoisation</em>&quot;</a>). Hierbei führt man pro Regel eine Map mit,
in der zu einer Position im Tokenstrom festgehalten wird, ob diese Regel an/ab dieser Position bereits
erfolgreich oder nicht erfolgreich war. Dies kann man dann nutzen, um bei einem erneuten Parsen der
selben Regel &quot;vorzuspulen&quot;.</p>
<p>In ANTLR kann man <em>semantische Prädikate</em> benutzen, um Alternativen &quot;abzuschalten&quot;. Dies ist beispielsweise
nützlich, wenn man nur eine Grammatik für unterschiedliche Versionen einer Sprache implementieren will.</p>
<p>Eine gute Darstellung finden Sie in <a href="#id_Parr2010">[Parr2010]</a> (Kapitel 3) und in [Packrat2006].</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/12GT2WxZsxY' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL LL-Parser: Fortgeschrittene Techniken</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/c3dc479884ce6b50bbd0fe85a8dd49f7b250576ac73742b879c564d6cba4b83c79fa499f9164b947e81e597add85e6addfd91a41a4eb85438c51218846aac0cb' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL LL-Parser: Fortgeschrittene Techniken</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K3) Implementierung von LL(1)- und LL(k)-Parsern</li> <li>(K3) Dynamischer Lookahead mittels Backtracking; Verbesserung der Laufzeiteigenschaften mit Packrat</li> <li>(K3) Einsatz von semantischen Prädikaten zum (De-) Aktivieren von Regeln oder Token</li></ul></div>
</div>




    <h2 id="ll-parser-mit-backtracking">LL-Parser mit Backtracking</h2>
<p>Problem: Manchmal kennt man den nötigen Lookahead nicht vorher. Beispiel:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>wuppie();         <span style="color:#75715e">// Vorwärtsdeklaration
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>wuppie() { ...}   <span style="color:#75715e">// Definition
</span></span></span></code></pre></div><p>Entsprechend sähe die Grammatik aus:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>func : fdef <span style="color:#f92672">|</span> fdecl ;
</span></span><span style="display:flex;"><span>fdef : head <span style="color:#e6db74">&#39;{&#39;</span> body <span style="color:#e6db74">&#39;}&#39;</span> ;
</span></span><span style="display:flex;"><span>fdecl: head <span style="color:#e6db74">&#39;;&#39;</span> ;
</span></span><span style="display:flex;"><span>head : <span style="color:#f92672">...</span> ;</span></span></code></pre></div><p>Hier müsste man erst den gesamten Funktionskopf parsen, bevor man entscheiden kann, ob es sich um
eine Deklaration oder eine Definition handelt. Unglücklicherweise gibt es keine Längenbeschränkung
bei den Funktionsnamen ...</p>
<p>Mit Hilfe von Backtracking kann man zunächst spekulativ matchen und beim Auftreten eines Fehlers
die Spekulation rückgängig machen:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">func</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> speculate(fdef): fdef()      <span style="color:#75715e"># Spekuliere auf &#34;fdef&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> speculate(fdecl): fdecl()  <span style="color:#75715e"># Spekuliere auf &#34;fdecl&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">Exception</span>()</span></span></code></pre></div><p>Die erste Alternative, die passt, gewinnt. Über die Reihenfolge der Spekulationen kann man
entsprechend Vorrangregeln implementieren.</p>
<h3 id="anmerkung">Anmerkung</h3>
<p>Man könnte die obige Grammatik umformen ...</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>func : head <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;{&#39;</span> body <span style="color:#e6db74">&#39;}&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;;&#39;</span><span style="color:#f92672">)</span> ;
</span></span><span style="display:flex;"><span>head : <span style="color:#f92672">...</span> ;</span></span></code></pre></div><p>...und bräuchte dann kein spekulatives Parsen mit Backtracking.</p>
<p>Da wir aber das Parsen mit Backtracking betrachten wollen, blenden wir diese Möglichkeit
jetzt einfach aus ;)</p>
<h2 id="details-spekulatives-matchen">Details: Spekulatives Matchen</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">speculate</span>(fn):
</span></span><span style="display:flex;"><span>    success <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    mark()                  <span style="color:#75715e"># markiere aktuelle Position</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>:   fn()             <span style="color:#75715e"># probiere Regel fn()</span>
</span></span><span style="display:flex;"><span>    catch: success <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    clear()                 <span style="color:#75715e"># Rollback</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> success</span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, p. 60]</a></span></p>
<p>Der Funktion <code>speculate</code> wird die zu testende Regel (Funktion) als Parameter übergeben, im obigen
Beispiel wären dies <code>fdef</code> bzw. <code>fdecl</code>.</p>
<p>Vor dem spekulativen Matchen muss die aktuelle Position im Tokenstrom markiert werden. Falls der
Versuch, die Deklaration zu matchen nicht funktioniert, wird der Regel-Aufruf eine Exception werfen,
entsprechend wird die Hilfsvariable gesetzt. Anschließend muss noch mit <code>clear()</code> das aktuelle
Token wieder hergestellt werden (wir sind ja nur im Spekulationsmodus, d.h. selbst im Erfolgsfall
wird ja die Regel noch &quot;richtig&quot; aufgerufen).</p>
<h2 id="spekulatives-matchen-hilfsmethoden-iii">Spekulatives Matchen: Hilfsmethoden I/II</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Parser</span>:
</span></span><span style="display:flex;"><span>    Lexer lexer
</span></span><span style="display:flex;"><span>    markers <span style="color:#f92672">=</span> []    <span style="color:#75715e"># Integer-Stack: speichere Tokenpositionen</span>
</span></span><span style="display:flex;"><span>    lookahead <span style="color:#f92672">=</span> []  <span style="color:#75715e"># Puffer (1 Token vorbefüllt via Konstruktor)</span>
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>       <span style="color:#75715e"># aktuelle Tokenposition im lookahead-Puffer</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">mark</span>():
</span></span><span style="display:flex;"><span>        markers<span style="color:#f92672">.</span>push(start)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">clear</span>():
</span></span><span style="display:flex;"><span>        start <span style="color:#f92672">=</span> markers<span style="color:#f92672">.</span>pop()</span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, pp. 61/62]</a></span></p>
<h2 id="spekulatives-matchen-hilfsmethoden-iiii">Spekulatives Matchen: Hilfsmethoden II/II</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">consume</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">++</span>start
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> start <span style="color:#f92672">==</span> lookahead<span style="color:#f92672">.</span>count() <span style="color:#f92672">and</span> markers<span style="color:#f92672">.</span>isEmpty():
</span></span><span style="display:flex;"><span>        start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; lookahead<span style="color:#f92672">.</span>clear()
</span></span><span style="display:flex;"><span>    sync(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lookahead</span>(i):
</span></span><span style="display:flex;"><span>    sync(i)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> lookahead<span style="color:#f92672">.</span>get(start<span style="color:#f92672">+</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sync</span>(i):
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> start <span style="color:#f92672">+</span> i <span style="color:#f92672">-</span> lookahead<span style="color:#f92672">.</span>count()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>        lookahead<span style="color:#f92672">.</span>add(lexer<span style="color:#f92672">.</span>nextToken()); <span style="color:#f92672">--</span>n</span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, pp. 61/62]</a></span></p>
<p><code>consume</code> holt wie immer das nächste Token, hier indem der Index <code>start</code> weiter gesetzt
wird und ein weiteres Token über <code>sync</code> in den Puffer geladen wird. Falls wir nicht am
Spekulieren sind und das Ende des Puffers erreicht haben, nutzen wir die Gelegenheit und
setzen den Puffer zurück. (Dies geht nicht, wenn wir spekulieren -- hier müssen wir ja
ggf. ein Rollback vornehmen und benötigen also den aktuellen Puffer dann noch.)</p>
<p>Die Funktion <code>sync</code> stellt sicher, dass ab der Position <code>start</code> noch <code>i</code> unverbrauchte
Token im Puffer sind.</p>
<h3 id="hinweis">Hinweis</h3>
<p>Die Methode <code>count</code> liefert die Anzahl der aktuell gespeicherten Elemente in <code>lookahead</code>
zurück (nicht die Gesamtzahl der Plätze in der Liste -- diese kann größer sein). Mit der
Methode <code>add</code> wird ein Element hinten an die Liste angefügt, dabei wird das Token auf den
nächsten Index-Platz (<code>count</code>) geschrieben und ggf. die Liste ggf. automatisch um weitere
Speicherplätze ergänzt. Über <code>clear</code> werden die Elemente in der Liste gelöscht, aber der
Speicherplatz erhalten (d.h. <code>count()</code> liefert den Wert 0, aber ein <code>add</code> müsste nicht erst
die Liste mit weiteren Plätzen erweitern, sondern könnte direkt an Index 0 das Token schreiben).</p>
<h3 id="backtracking-führt-zu-problemen">Backtracking führt zu Problemen</h3>
<ol>
<li>Backtracking kann <em>sehr</em> langsam sein (Ausprobieren vieler Alternativen)</li>
<li>Der spekulative Match muss ggf. rückgängig gemacht werden</li>
<li>Man muss bereits gematchte Strukturen erneut matchen (=&gt; Abhilfe: Packrat-Parsing)</li>
</ol>
<h2 id="verbesserung-backtracking-packrat-parser-memoizing">Verbesserung Backtracking: Packrat Parser (Memoizing)</h2>
<p><a href="#R-image-af4c00c1db659d4009b74342db18c290" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced/packrat.png?width=60%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 60%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-af4c00c1db659d4009b74342db18c290"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced/packrat.png?width=60%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Bei der Eingabe <code>wuppie();</code> wird zunächst spekulativ die erste Alternative <code>fdef</code> untersucht
und ein <code>head</code> gematcht. Da die Alternative nicht komplett passt (es kommt ein &quot;;&quot; statt
einem &quot;{&quot;), muss die Spekulation rückgängig gemacht werden und die zweite Alternative
<code>fdecl</code> untersucht werden. Dabei muss man den selben Input erneut auf <code>head</code> matchen!
(Und wenn die Spekulation (irgendwann) erfolgreich war, muss noch einmal ein <code>head</code> gematcht
werden ...)</p>
<p>Idee: Wenn <code>head</code> sich merken würde, ob damit ein bestimmter Teil des Tokenstroms bereits
behandelt wurde (erfolgreich oder nicht), könnte man das Spekulieren effizienter gestalten.
Jede Regel muss also durch eine passende Regel mit Speicherung ergänzt werden.</p>
<p>Dies wird auch als <a href="https://en.wikipedia.org/wiki/Memoization" target="_blank">&quot;Memoization&quot;</a> bezeichnet
und ist eine zentrales Technik des Packrat Parsers (vgl. <a href="#id_Packrat2006">[Packrat2006]</a>).</p>
<h2 id="skizze-idee-des-packrat-parsing">Skizze: Idee des Packrat-Parsing</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>head_memo <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">head</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> head_memo<span style="color:#f92672">.</span>get(start) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">Exception</span>()                         <span style="color:#75715e"># kein Match</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> head_memo<span style="color:#f92672">.</span>get(start) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        start <span style="color:#f92672">=</span> head_memo[start]; <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>     <span style="color:#75715e"># Vorspulen</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>; start_ <span style="color:#f92672">=</span> start
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span>: <span style="color:#f92672">...</span>     <span style="color:#75715e"># rufe die ursprüngliche head()-Regel auf</span>
</span></span><span style="display:flex;"><span>        catch(e): failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>; <span style="color:#66d9ef">raise</span> e
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">finally</span>: head_memo[start_] <span style="color:#f92672">=</span> (failed <span style="color:#960050;background-color:#1e0010">?</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> : start)</span></span></code></pre></div><p><span class='origin'>Quelle: Eigener Code basierend auf einer Idee nach <a href="#id_Parr2010">[Parr2010, pp. 65/66]</a></span></p>
<ul>
<li>Wenn bereits untersucht (Eintrag vorhanden): Vorspulen bzw. Exception werfen</li>
<li>Sonst (aktuelle Position noch nicht in der Tabelle =&gt; Regel noch nicht an
dieser Position getestet):
<ul>
<li>Original-Regel ausführen</li>
<li>Exception: Regel hatte keinen Erfolg =&gt; merken und Exception weiter reichen</li>
</ul>
</li>
<li>Ergebnis für diese Startposition und diese Regel merken:
<ul>
<li>Falls Regel erfolgreich, dann Start-Position und die aktuelle Position
(Stopp-Position) in der Tabelle für diese Regel notieren</li>
<li>Falls Regel nicht erfolgreich, zur Start-Position eine ungültige Position setzen</li>
</ul>
</li>
</ul>
<h3 id="anmerkung-consume">Anmerkung <em>consume()</em></h3>
<p>Die Funktion <code>consume()</code> muss passend ergänzt werden: Wann immer man den <code>lookahead</code>-Puffer
zurücksetzt, werden alle <code>*_memo</code> ungültig und müssen ebenfalls zurückgesetzt werden!</p>
<h2 id="semantische-prädikate">Semantische Prädikate</h2>
<p>Problem in Java: <code>enum</code> ab Java5 Schlüsselwort (vorher als Identifier-Name verwendbar)</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>prog : <span style="color:#f92672">(</span>enumDecl <span style="color:#f92672">|</span> stat<span style="color:#f92672">)+</span> ;
</span></span><span style="display:flex;"><span>stat : <span style="color:#f92672">...</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>enumDecl : <span style="color:#66d9ef">ENUM</span> id <span style="color:#e6db74">&#39;{&#39;</span> id <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;,&#39;</span> id<span style="color:#f92672">)*</span> <span style="color:#e6db74">&#39;}&#39;</span> ;</span></span></code></pre></div><p>Wie kann ich eine Grammatik bauen, die sowohl für Java5 und später als auch für die Vorgänger
von Java5 funktioniert?</p>
<p>Angenommen, man hätte eine Hilfsfunktion (&quot;Prädikat&quot;), mit denen man aus dem Kontext heraus
die Unterscheidung treffen kann, dann würde die Umsetzung der Regel ungefähr so aussehen:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">prog</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> lookahead(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> ENUM <span style="color:#f92672">and</span> java5: enumDecl()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: stat()</span></span></code></pre></div><h2 id="semantische-prädikate-in-antlr">Semantische Prädikate in ANTLR</h2>
<h3 id="semantische-prädikate-in-parser-regeln">Semantische Prädikate in Parser-Regeln</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>@parser::members {public static boolean java5;}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>prog : <span style="color:#f92672">(</span>{java5}<span style="color:#f92672">?</span> enumDecl <span style="color:#f92672">|</span> stat<span style="color:#f92672">)+</span> ;
</span></span><span style="display:flex;"><span>stat : <span style="color:#f92672">...</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>enumDecl : <span style="color:#66d9ef">ENUM</span> id <span style="color:#e6db74">&#39;{&#39;</span> id <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;,&#39;</span> id<span style="color:#f92672">)*</span> <span style="color:#e6db74">&#39;}&#39;</span> ;</span></span></code></pre></div><p>Prädikate in Parser-Regeln aktivieren bzw. deaktivieren alles, was nach der Abfrage
des Prädikats gematcht werden könnte.</p>
<h3 id="semantische-prädikate-in-lexer-regeln">Semantische Prädikate in Lexer-Regeln</h3>
<p>Alternativ für Lexer-Regeln:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>ENUM : <span style="color:#e6db74">&#39;enum&#39;</span> {java5}<span style="color:#f92672">?</span> ;
</span></span><span style="display:flex;"><span>ID   : [a-zA-Z]<span style="color:#f92672">+</span> ;</span></span></code></pre></div><p>Bei Token kommt das Prädikat erst am rechten Ende einer Lexer-Regel vor, da der Lexer keine
Vorhersage macht, sondern nach dem längsten Match sucht und die Entscheidung erst trifft,
wenn das ganze Token gesehen wurde. Bei Parser-Regeln steht das Prädikat links vor der
entsprechenden Alternative, da der Parser mit Hilfe des Lookaheads Vorhersagen trifft, welche
Regel/Alternative zutrifft.</p>
<p><em>Anmerkung</em>: Hier wurden nur Variablen eingesetzt, es können aber auch Methoden/Funktionen
genutzt werden. In Verbindung mit einer Symboltabelle (<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html/cb_symboltabellen1.html">&quot;Symboltabellen&quot;</a>)
und/oder mit Attributen und Aktionen in der Grammatik (<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html/cb_attribute.html">&quot;Attribute&quot;</a> und
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html/cb_interpreter2.html">&quot;Interpreter: Attribute+Aktionen&quot;</a>) hat man hier ein mächtiges Hilfswerkzeug!</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>LL(1) und LL(k): Erweiterungen
<ul>
<li>Dynamischer Lookahead: BT-Parser mit Packrat-Ergänzung</li>
<li>Semantische Prädikate zum Abschalten von Alternativen</li>
</ul>
</li>
</ul>


    



    



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Abschnitte 2.4 und 4.4</em></li> <li id='id_Grune2012'>[Grune2012] <strong>Modern Compiler Design</strong><br>Grune, D. und van, Reeuwijk, K. und Bal, H. E. und Jacobs, C. J. H. und Langendoen, K., Springer, 2012. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-4614-4698-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-4614-4698-9</a>.<br><em>Abschnitte 3.1 bis (einschließlich) 3.4</em></li> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 2 (insbesondere Abschnitte 2.3 bis (einschließlich) 2.19)</em></li> <li id='id_Packrat2006'>[Packrat2006] <a href='http://arxiv.org/abs/cs/0603077' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>Packrat Parsing: Simple, Powerful, Lazy, Linear Time</strong></a><br>Ford, B., 2006.</li> <li id='id_Parr2010'>[Parr2010] <strong>Language Implementation Patterns</strong><br>Parr, T., Pragmatic Bookshelf, 2010. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5645-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5645-6</a>.<br><em>Kapitel 3</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Parser mit ANTLR generieren</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>Mit ANTLR kann aus einer Grammatik ein LL(*)-Parser generiert werden. Die Parser-Regeln
in der Grammatik fangen dabei mit einem <strong>Kleinbuchstaben</strong> an (Erinnerung: Lexer-Regel
starten mit einem Großbuchstaben).</p>
<p>Regeln haben einen Namen (linke Seite) und eine Produktion (rechte Seite). Dabei
können beliebige Abfolgen von Lexer- und Parser-Regeln auf der rechten Seite
einer Parser-Regel auftauchen. Die Token müssen jeweils matchen, die Parser-Regeln
werden in einen Aufruf der jeweiligen generierten Funktion übersetzt.</p>
<p>Parser-Regeln können aus mehreren Alternativen bestehen, diese werden per <code>|</code> separiert.
Dabei hat bei Mehrdeutigkeiten die erste passende Alternative Vorrang. Wie bei Lexer-Regeln
können Teile per <code>?</code> ein- oder keinmal vorkommen, per <code>*</code> beliebig oft oder per <code>+</code> ein-
oder mehrfach.</p>
<p>ANTLR erlaubt im Gegensatz zu allgemeinen LL-Parsern direkte Links-Rekursion. (Indirekte
Links-Rekursion funktioniert allerdings nicht.)</p>
<p>Der von ANTLR generierte Parser erzeugt auf der Eingabe einen Parse-Tree, der die Strukturen
der Grammatik widerspiegelt: Die Token bilden die Blätter und jede erfolgreich durchlaufene
Parser-Regel bildet einen entsprechenden Knoten im Baum.</p>
<p>Für die Traversierung des Parse-Tree kann man die generierten Listener- oder Visitor-Klassen
nutzen. Beim Einsatz der Listener nutzt man die vorgegebene Klasse <code>ParseTreeWalker</code>, die
mit dem Parse-Tree und dem Listener den Baum per Tiefensuche traversiert und immer die
jeweiligen <code>enterRegel</code>- und <code>exitRegel</code>-Methoden aufruft. Beim Visitor muss die Traversierung
selbst erledigt werden, hier steht die aus der Klassenhierarchie geerbte Methode <code>visit</code>
als Startpunkt zur Verfügung. In dieser Methode wird basierend auf dem Knotentyp die in den
Visitor-Klassen implementierte <code>visitRegel</code>-Methode aufgerufen und man muss darauf achten,
die Kindknoten durch passende Aufrufe zu traversieren. Sowohl bei den generierten Listener-
als auch den Visitor-Klassen kann man die leeren Defaultmethoden bei Bedarf selbst überschreiben.
Für den Zugriff auf die Regel-Elemente werden die sogenannten Kontextobjekte als Parameter
übergeben.</p>
<p>Benannte Alternativen und Regel-Elemente sind nützlich, weil für die benannten Alternativen
zusätzliche Kontextklassen erzeugt werden, über die dann auf die Bestandteile der Alternativen
zugegriffen werden kann. Außerdem werden zusätzlich passende <code>enterAlternative</code>- und <code>exitAlternative</code>-
bzw. <code>visitAlternative</code>-Methoden generiert. Für benannte Regel-Elemente wird ein entsprechend
benanntes Attribut im Kontextobjekt angelegt, welches <code>public</code> sichtbar ist.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/YuUHBvPUS4k' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Parser mit ANTLR</a></li> <li><a href='https://youtu.be/FJOEPY-TMmw' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Demo ANTLR Parser</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/19925b756d6fc934bfe0b5107eb5fa58373a53af49c690ebce86e15f2b212c89c80ea7665e42c78abdc8dfe0718ea46f6a9817eeba4ad1293bdb4c84f7c8f084' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Parser mit ANTLR</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K2) Aufbau der Parser-Regeln</li> <li>(K3) Alternativen und optionale/mehrfache Regelteile in Parser-Regeln</li> <li>(K3) Vorrang von Alternativen (bei Mehrdeutigkeiten)</li> <li>(K3) Benannte Alternativen und Regel-Elemente</li> <li>(K2) Aufbau des Parse-Tree</li> <li>(K3) Umgang mit Kontext-Objekten</li> <li>(K3) Traversierung des Parse-Tree mit den generierten Listenern oder Visitors</li></ul></div>
</div>




    <h2 id="hello-world">Hello World</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span><span style="color:#66d9ef">grammar</span> <span style="color:#a6e22e">Hello</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>start : stmt<span style="color:#f92672">*</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>stmt  : <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> expr <span style="color:#e6db74">&#39;;&#39;</span> <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;;&#39;</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>expr  : term <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;+&#39;</span> term<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>term  : atom <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;*&#39;</span> atom<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>atom  : <span style="color:#66d9ef">ID</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">NUM</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ID    : [a-z][a-zA-Z]<span style="color:#f92672">*</span> ;
</span></span><span style="display:flex;"><span>NUM   : [0-9]<span style="color:#f92672">+</span> ;
</span></span><span style="display:flex;"><span>WS    : [ \t\n]<span style="color:#f92672">+</span> <span style="color:#f92672">-&gt;</span> skip ;</span></span></code></pre></div><div style="text-align: right;">
<span class="btn cstyle default">
  <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/lecture/frontend/parsing/src/Hello.g4" target="_blank">
    Konsole: Hello (grun, Parse-Tree)
  </a>
</span></div>
<h3 id="starten-des-parsers">Starten des Parsers</h3>
<ol>
<li>Grammatik übersetzen und Code generieren: <code>antlr Hello.g4</code></li>
<li>Java-Code kompilieren: <code>javac *.java</code></li>
<li>Parser ausführen:
<ul>
<li>
<p><code>grun Hello start -tree</code> oder <code>grun Hello start -gui</code> (Grammatik &quot;Hello&quot;, Startregel &quot;start&quot;)</p>
</li>
<li>
<p>Alternativ mit kleinem Java-Programm:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> org.antlr.v4.runtime.CharStreams<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.antlr.v4.runtime.CommonTokenStream<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.antlr.v4.runtime.tree.ParseTree<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        HelloLexer lexer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HelloLexer<span style="color:#f92672">(</span>CharStreams<span style="color:#f92672">.</span><span style="color:#a6e22e">fromStream</span><span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        CommonTokenStream tokens <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CommonTokenStream<span style="color:#f92672">(</span>lexer<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        HelloParser parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HelloParser<span style="color:#f92672">(</span>tokens<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ParseTree tree <span style="color:#f92672">=</span> parser<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>  <span style="color:#75715e">// Start-Regel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>tree<span style="color:#f92672">.</span><span style="color:#a6e22e">toStringTree</span><span style="color:#f92672">(</span>parser<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div></li>
</ul>
</li>
</ol>
<h3 id="startregeln">Startregeln</h3>
<ul>
<li><code>start</code> ist eine <span class='alert'>Parser-Regel</span>
=&gt; Eine Parser-Regel pro Grammatik wird benötigt, damit man den generierten
Parser am Ende auch starten kann ...</li>
<li>Alle Regeln mit kleinem Anfangsbuchstaben sind Parser-Regeln</li>
<li>Alle Regeln mit großem Anfangsbuchstaben sind Lexer-Regeln</li>
</ul>
<h3 id="formen-der-subregeln">Formen der Subregeln</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt  : <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> expr <span style="color:#e6db74">&#39;;&#39;</span> ;</span></span></code></pre></div><p>Um die Regel <code>stmt</code> anwenden zu können, müssen alle Elemente auf der rechten
Seite der Regel erfüllt werden. Dabei müssen die Token wie <code>ID</code>, <code>=</code> und <code>;</code>
matchen und die Subregel <code>expr</code> muss erfüllt werden können. Beachten Sie das
abschließende Semikolon am Ende einer ANTLR-Regel!</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt  : <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> expr <span style="color:#e6db74">&#39;;&#39;</span> <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;;&#39;</span> ;</span></span></code></pre></div><p>Alternativen werden durch ein <code>|</code> getrennt. Hier muss genau eine Alternative
erfüllt werden. Falls nötig, trennt man die Alternativen durch Einschließung
in runden Klammern vom Rest der Regel ab: <code>r : a (b | c) d ;</code>.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr  : term <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;+&#39;</span> term<span style="color:#f92672">)*</span> ;</span></span></code></pre></div><p>Der durch den <code>*</code> gekennzeichnete Teil kann beliebig oft vorkommen oder auch
fehlen. Bei einem <code>+</code> müsste der Teil mind. einmal vorkommen und bei einem
<code>?</code> entsprechend einmal oder keinmal.</p>
<p>Auch hier kann man die Operatoren durch ein zusätzliches <code>?</code> auf non-greedy
umschalten (analog zu den Lexer-Regeln).</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/parser-rules.md#subrules" target="_blank">github.com/antlr/antlr4/blob/master/doc/parser-rules.md</a>)</p>
<h3 id="reihenfolge-in-grammatik-definiert-priorität">Reihenfolge in Grammatik definiert Priorität</h3>
<p>Falls mehr als eine Parser-Regel die selbe Input-Sequenz matcht, löst ANTLR
diese Mehrdeutigkeit auf, indem es die erste Alternative nimmt, die an der
Entscheidung beteiligt ist.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>start : stmt ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>stmt  : expr <span style="color:#f92672">|</span> <span style="color:#66d9ef">ID</span>  ;
</span></span><span style="display:flex;"><span>expr  : <span style="color:#66d9ef">ID</span>   <span style="color:#f92672">|</span> <span style="color:#66d9ef">NUM</span> ;</span></span></code></pre></div><p>Bei der Eingabe &quot;foo&quot; würde die Alternative <code>ID</code> in der Regel <code>expr</code> &quot;gewinnen&quot;,
weil sie in der Grammatik vor der Alternative <code>ID</code> in der Regel <code>stmt</code> kommt und
damit Vorrang hat.</p>
<h3 id="parse-tree">Parse-Tree</h3>
<p>Betrachten wir erneut die obige Grammatik.</p>
<p>Die Eingabe von &quot;<code>a = 42;</code>&quot; führt zu folgendem Parse-Tree:</p>
<p><a href="#R-image-17460c670750a3d9f3dbfa72b9dc5905" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/hello_ex1.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-17460c670750a3d9f3dbfa72b9dc5905"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/hello_ex1.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Diese Eingabe führt zur Erkennung der Token <code>[ID, WS, =, WS, NUM, ;]</code>, wobei die
<code>WS</code>-Token verworfen werden und der Parser den Tokenstream <code>[ID, =, NUM, ;]</code>
erhält.</p>
<p>Die Startregel hat auf der rechten Seite kein oder mehrere <code>stmt</code>-Regeln. Die
<code>stmt</code>-Regel fordert auf der rechten Seite entweder die Token <code>ID</code>und <code>=</code> sowie
die Regel <code>expr</code> gefolgt vom Token <code>;</code>, oder die Regel <code>expr</code> gefolgt vom Token
<code>;</code>. In unserem Beispiel kann für das &quot;a&quot; das Token <code>ID</code> produziert werden, das
&quot;=&quot; matcht ebenfalls. Die &quot;42&quot; wird erklärt, indem für <code>expr</code> ein <code>term</code> und
dort ein <code>atom</code> aufgerufen wird. Für das <code>atom</code> muss entweder ein Token <code>ID</code>
oder <code>NUM</code> als nächstes Token kommen - hier wird die &quot;42&quot; wird als Token <code>NUM</code>
verarbeitet. Da die weiteren Regelteile in <code>term</code> und <code>expr</code> optional sind,
haben wir damit ein <code>expr</code> erfüllt und das nachfolgende <code>;</code>-Token schließt die
erste Alternative der Regel <code>stmt</code> erfolgreich ab.</p>
<p>Im entstehenden Parse-Tree sind diese Abläufe und grammatikalischen Strukturen
direkt erkennbar. Jede erfolgreich durchlaufene Parserregel wird zu einem
Knoten im Parse-Tree. Die Token werden als Terminale (Blätter) in den Baum
eingehängt.</p>
<p><em>Anmerkung</em>: Der Parse-Tree ist das Ergebnis der Parsers-Phase im Compiler und
dient damit als Input für die folgenden Compilerstufen. In der Regel benötigt
man die oft recht komplexen Strukturen aber später nicht mehr und vereinfacht
den Baum zu einem <em>Abstract Syntax Tree</em> (AST). Im Beispiel könnte man den Zweig
<code>stmt - expr - term - atom - 42</code> zu <code>stmt - 42</code> vereinfachen.</p>
<p>Betrachten wir nun die Eingabe <code>foo = 2+3*4; bar = 3*4+2;</code>. Diese führt zu
folgendem Parse-Tree:</p>
<p><a href="#R-image-5f78916b80c3433210ac1f091312c713" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/hello_ex2.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5f78916b80c3433210ac1f091312c713"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/hello_ex2.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Wie man sehen kann, sind in der Grammatik die üblichen Vorrangregeln für die
Operationen <code>+</code> und <code>*</code> berücksichtigt - die Multiplikation wird in beiden
Fällen korrekt &quot;unter&quot; der Addition im Baum eingehängt.</p>
<h3 id="to-eof-not-to-eof">To EOF not to EOF?</h3>
<p>Startregeln müssen nicht unbedingt den gesamten Input &quot;konsumieren&quot;. Sie müssen
per Default nur eine der Alternativen in der Startregel erfüllen.</p>
<p>Betrachten wir noch einmal einen leicht modifizierten Ausschnitt aus der obigen
Grammatik:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>start : stmt ;</span></span></code></pre></div><p>Die Startregel wurde so geändert, dass sie nur noch genau ein Statement
akzeptieren soll.</p>
<p>In diesem Fall würde die Startregel bei der Eingabe &quot;aa; bb;&quot; nur den ersten
Teil &quot;aa;&quot; konsumieren (als Token <code>ID</code>) und das folgende &quot;bb;&quot; ignorieren.
Das wäre in diesem Fall aber auch kein Fehler.</p>
<p>Wenn der gesamte Eingabestrom durch die Startregel erklärt werden soll,
dann muss das vordefinierte Token <code>EOF</code> am Ende der Startregel eingesetzt
werden:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>start : stmt <span style="color:#66d9ef">EOF</span>;</span></span></code></pre></div><p>Hier würde die Eingabe &quot;aa; bb;&quot; zu einem Fehler führen, da nur der Teil &quot;aa;&quot;
durch die Startregel abgedeckt ist (Token <code>ID</code>), und der Rest &quot;bb;&quot; zwar sogar
ein gültiges Token wären (ebenfalls <code>ID</code> und <code>;</code>), aber eben nicht mehr von der
Startregel akzeptiert. Durch das <code>EOF</code> soll die Startregel aber den gesamten
Input konsumieren und erklären, was hier nicht geht und entsprechend zum Fehler
führt.</p>
<p>(vgl. <a href="https://github.com/antlr/antlr4/blob/master/doc/parser-rules.md#start-rules-and-eof" target="_blank">github.com/antlr/antlr4/blob/master/doc/parser-rules.md</a>)</p>
<h2 id="expressions-und-vorrang-operatoren">Expressions und Vorrang (Operatoren)</h2>
<p>Betrachten wir noch einmal den Ausschnitt für die Ausdrücke (<em>Expressions</em>) in
der obigen Beispielgrammatik:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr  : term <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;+&#39;</span> term<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>term  : atom <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;*&#39;</span> atom<span style="color:#f92672">)*</span> ;
</span></span><span style="display:flex;"><span>atom  : <span style="color:#66d9ef">ID</span> ;</span></span></code></pre></div><p>Diese typische, etwas komplex anmutende Struktur soll sicher stellen, dass die
Vorrangregeln für Addition und Multiplikation korrekt beachtet werden, d.h. dass
<code>2+3*4</code> als <code>2+(3*4)</code> geparst wird und nicht fälschlicherweise als <code>(2+3)*4</code>
erkannt wird.</p>
<p>Zusätzlich muss bei LL-Parsern Links-Rekursion vermieden werden: Die Parser-Regeln
werden in Funktionsaufrufe übersetzt, d.h. bei einer Links-Rekursion würde man die
selbe Regel immer wieder aufrufen, ohne ein Token aus dem Token-Strom zu entnehmen.</p>
<p>ANTLR (ab Version 4) kann mit beiden Aspekten automatisch umgehen:</p>
<ul>
<li>ANTLR kann direkte Linksrekursion automatisch auflösen. Die Regel <code>r : r T U | V ;</code>
kann also in ANTLR verarbeitet werden.</li>
<li>ANTLR besitzt einen Mechanismus zur Auflösung von Mehrdeutigkeiten. Wie oben
geschrieben, wird bei der Anwendbarkeit von mehreren Alternativen die erste
Alternative genutzt.</li>
</ul>
<p>Damit lässt sich die typische Struktur für Expression-Grammatiken deutlich lesbarer
gestalten:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr  : expr <span style="color:#e6db74">&#39;*&#39;</span> expr
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> expr <span style="color:#e6db74">&#39;+&#39;</span> expr
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#66d9ef">ID</span>
</span></span><span style="display:flex;"><span>      ;</span></span></code></pre></div><p>Die Regel <code>expr</code> ist links-rekursiv, was normalerweise bei LL-Parsern problematisch
ist. ANTLR löst diese Links-Rekursion automatisch auf (vgl.
<a href="https://github.com/antlr/antlr4/blob/master/doc/left-recursion.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/left-recursion.md</a>).</p>
<p>Da bei Mehrdeutigkeit in der Grammatik, also bei der Anwendbarkeit mehrerer Alternativen
stets die erste Alternative genommen wird, lassen sich die Vorrangregeln durch die
Reihenfolge der Alternativen in der <code>expr</code>-Regel implementieren: Die Multiplikation
hat Vorrang von der Addition, und diese hat wiederum Vorrang von einer einfachen <code>ID</code>.</p>
<h3 id="direkte-vs-indirekte-links-rekursion">Direkte vs. indirekte Links-Rekursion</h3>
<p>ANTLR kann nur <em>direkte</em> Links-Rekursion auflösen. Regeln wie <code>r : r T U | V ;</code> stellen
in ANTLR also kein Problem dar.</p>
<p><em>Indirekte</em> Links-Rekursion erkennt ANTLR dagegen nicht:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>r : s <span style="color:#66d9ef">T</span> <span style="color:#66d9ef">U</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">V</span> ;
</span></span><span style="display:flex;"><span>s : r <span style="color:#66d9ef">W</span> <span style="color:#66d9ef">X</span> ;</span></span></code></pre></div><p>Hier würden sich die Regeln <code>r</code> und <code>s</code> gegenseitig aufrufen und kein Token aus dem
Tokenstrom entfernen, so dass der generierte LL-Parser hier in einer Endlosschleife
stecken bleiben würde. Mit indirekter Links-Rekursion kann ANTLR nicht umgehen.</p>
<h3 id="konflikte-in-regeln">Konflikte in Regeln</h3>
<p>Wenn mehrere Alternativen einer Regel anwendbar sind, entscheidet sich ANTLR für die
erste Alternative.</p>
<p>Wenn sich mehrere Tokenregeln überlappen, &quot;gewinnt&quot; auch hier die zuerst definierte
Regel.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>def : <span style="color:#e6db74">&#39;func&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;(&#39;</span> <span style="color:#e6db74">&#39;)&#39;</span> block ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>FOR : <span style="color:#e6db74">&#39;for&#39;</span> ;
</span></span><span style="display:flex;"><span>ID  : [a-z][a-zA-Z]<span style="color:#f92672">*</span> ;</span></span></code></pre></div><p>Hier werden ein implizites Token <code>'func'</code> sowie die expliziten Token <code>FOR</code> und <code>ID</code>
definiert. Dabei sind die Lexeme für <code>'func'</code> und <code>FOR</code> auch in <code>ID</code> enthalten.
Dennoch werden <code>'func'</code> und <code>FOR</code> erkannt und nicht über <code>ID</code> gematcht, weil sie
<em>vor</em> der Regel <code>ID</code> definiert sind.</p>
<p>Tatsächlich sortiert ANTLR die Regeln intern um, so dass alle Parser-Regeln <em>vor</em> den
Lexer-Regeln definiert sind. Die impliziten Token werden dabei noch vor den expliziten
Token-Regeln angeordnet. Im obigen Beispiel hat also <code>'func'</code> eine höhere Priorität
als <code>FOR</code>, und <code>FOR</code> hat eine höhere Priorität als <code>ID</code>. Aus diesem Grund gibt es die
Konvention, die Parser-Regeln in der Grammatik vor den Lexer-Regeln zu definieren - dies
entspricht quasi der Anordnung, die ANTLR bei der Verarbeitung sowieso erzeugen würde.</p>
<p>Aus diesem Grund würde auch eine Umsortierung der obigen Grammatik funktionieren:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>FOR : <span style="color:#e6db74">&#39;for&#39;</span> ;
</span></span><span style="display:flex;"><span>ID  : [a-z][a-zA-Z]<span style="color:#f92672">*</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def : <span style="color:#e6db74">&#39;func&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;(&#39;</span> <span style="color:#e6db74">&#39;)&#39;</span> block ;</span></span></code></pre></div><p>Intern würde ANTLR die Parser-Regel <code>def</code> wieder vor den beiden Lexer-Regeln anordnen,
und zwischen den Parser-Regeln und den Lexer-Regeln die impliziten Token (hier <code>'func'</code>).</p>
<h2 id="kontext-objekte-für-parser-regeln">Kontext-Objekte für Parser-Regeln</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>s    : expr         {List&lt;EContext&gt; x = $expr.ctx.e();}
</span></span><span style="display:flex;"><span>     ;
</span></span><span style="display:flex;"><span>expr : e <span style="color:#e6db74">&#39;*&#39;</span> e ;</span></span></code></pre></div><p><a href="#R-image-9ab78d8370d1b91852d454d9b51156ca" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParserRuleContext.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9ab78d8370d1b91852d454d9b51156ca"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParserRuleContext.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Jede Regel liefert ein passend zu dieser Regel generiertes Kontext-Objekt
zurück. Darüber kann man das/die Kontextobjekt(e) der Sub-Regeln abfragen.</p>
<p>Die Regel <code>s</code> liefert entsprechend ein <code>SContext</code>-Objekt und die Regel
<code>expr</code> liefert ein <code>ExprContext</code>-Objekt zurück.</p>
<p>In der Aktion fragt man das Kontextobjekt über <code>ctx</code> ab, in den Listener-
und Visitor-Methoden erhält man die Kontextobjekte als Parameter.</p>
<p>Für einfache Regel-Aufrufe liefert die parameterlose Methode nur ein
einziges Kontextobjekt (statt einer Liste) zurück.</p>
<p><strong>Anmerkung</strong>: ANTLR generiert nur dann <em>Felder</em> für die Regel-Elemente im
Kontextobjekt, wenn diese in irgendeiner Form referenziert werden. Dies
kann beispielsweise durch Benennung (Definition eines Labels, siehe nächste
Folie) oder durch Nutzung in einer Aktion (siehe obiges Beispiel) geschehen.</p>
<h2 id="benannte-regel-elemente-oder-alternativen">Benannte Regel-Elemente oder Alternativen</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stat  : <span style="color:#e6db74">&#39;return&#39;</span> value<span style="color:#f92672">=</span>e <span style="color:#e6db74">&#39;;&#39;</span>    <span style="color:#f92672">#</span> <span style="color:#66d9ef">Return</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;break&#39;</span> <span style="color:#e6db74">&#39;;&#39;</span>             <span style="color:#f92672">#</span> <span style="color:#66d9ef">Break</span>
</span></span><span style="display:flex;"><span>      ;</span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StatContext</span> <span style="color:#66d9ef">extends</span> ParserRuleContext <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReturnContext</span> <span style="color:#66d9ef">extends</span> StatContext <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> EContext value<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> EContext <span style="color:#a6e22e">e</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BreakContext</span> <span style="color:#66d9ef">extends</span> StatContext <span style="color:#f92672">{</span> <span style="color:#f92672">...</span> <span style="color:#f92672">}</span></span></span></code></pre></div><p>Mit <code>value=e</code> wird der Aufruf der Regel <code>e</code> mit dem Label <code>value</code> belegt,
d.h. man kann mit <code>$e.text</code> oder <code>$value.text</code> auf das <code>text</code>-Attribut von
<code>e</code> zugreifen. Falls es in einer Produktion mehrere Aufrufe einer anderen
Regel gibt, <strong>muss</strong> man für den Zugriff auf die Attribute eindeutige Label
vergeben.</p>
<p>Analog wird für die beiden Alternativen je ein eigener Kontext erzeugt.</p>
<h2 id="arbeiten-mit-antlr-listeners">Arbeiten mit ANTLR-Listeners</h2>
<p>ANTLR (generiert auf Wunsch) zur Grammatik passende Listener (Interface und
leere Basisimplementierung). Beim Traversieren mit dem Default-<code>ParseTreeWalker</code>
wird der Parse-Tree mit Tiefensuche abgelaufen und jeweils beim Eintritt in
bzw. beim Austritt aus einen/m Knoten der passende Listener mit dem passenden
Kontext-Objekt aufgerufen.</p>
<p>Damit kann man die Grammatik &quot;für sich&quot; halten, d.h. unabhängig von einer
konkreten Zielsprache und die Aktionen über die Listener (oder Visitors, s.u.)
ausführen.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;*&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">MULT</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;+&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">ADD</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">DIGIT</span>                    <span style="color:#f92672">#</span> <span style="color:#66d9ef">ZAHL</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p>ANTLR kann zu dieser Grammatik <code>calc.g4</code> einen passenden Listener (Interface
<code>calcListener</code>) generieren (Option <code>-listener</code> beim Aufruf von <code>antlr</code>).
Weiterhin generiert ANTLR eine leere Basisimplementierung (Klasse <code>calcBaseListener</code>):</p>
<p><a href="#R-image-d24621cefc1dbfeb9e6d3b7bbdd0a076" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParseTreeListener.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d24621cefc1dbfeb9e6d3b7bbdd0a076"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParseTreeListener.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>(Nur &quot;interessante&quot; Methoden gezeigt.)</p>
<p>Von dieser Basisklasse leitet man einen eigenen Listener ab und implementiert
die Methoden, die man benötigt.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyListener</span> <span style="color:#66d9ef">extends</span> calcBaseListener <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exitMULT</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">MULTContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exitADD</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">ADDContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exitZAHL</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">ZAHLContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div><p>Anschließend baut man das alles in eine Traversierung des Parse-Trees ein:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestMyListener</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyListener</span> <span style="color:#66d9ef">extends</span> calcBaseListener <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        calcLexer lexer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcLexer<span style="color:#f92672">(</span>CharStreams<span style="color:#f92672">.</span><span style="color:#a6e22e">fromStream</span><span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        CommonTokenStream tokens <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CommonTokenStream<span style="color:#f92672">(</span>lexer<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        calcParser parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcParser<span style="color:#f92672">(</span>tokens<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ParseTree tree <span style="color:#f92672">=</span> parser<span style="color:#f92672">.</span><span style="color:#a6e22e">s</span><span style="color:#f92672">();</span>    <span style="color:#75715e">// Start-Regel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        ParseTreeWalker walker <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ParseTreeWalker<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        MyListener eval <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyListener<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        walker<span style="color:#f92672">.</span><span style="color:#a6e22e">walk</span><span style="color:#f92672">(</span>eval<span style="color:#f92672">,</span> tree<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div><div style="text-align: right;">
<span class="btn cstyle default">
  <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/lecture/frontend/parsing/src/TestMyListener.java" target="_blank">
    Beispiel: TestMyListener.java und calc.g4
  </a>
</span></div>
<p>In <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/syntaxdriven.html">Syntaxgesteuerte Interpreter</a>
werden wir damit einen einfachen syntaxgesteuerten Interpreter aufbauen.</p>
<h2 id="arbeiten-mit-dem-visitor-pattern">Arbeiten mit dem Visitor-Pattern</h2>
<p>ANTLR (generiert ebenfalls auf Wunsch) zur Grammatik passende Visitoren
(Interface und leere Basisimplementierung).</p>
<p>Hier muss man im Gegensatz zu den Listeners allerdings selbst für eine geeignete
Traversierung des Parse-Trees sorgen. Dafür hat man mehr Freiheiten im Vergleich
zum Einsatz von Listeners, insbesondere im Hinblick auf Rückgabewerte.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>expr : e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;*&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">MULT</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;+&#39;</span> e2<span style="color:#f92672">=</span>expr      <span style="color:#f92672">#</span> <span style="color:#66d9ef">ADD</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">DIGIT</span>                    <span style="color:#f92672">#</span> <span style="color:#66d9ef">ZAHL</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p>ANTLR kann zu dieser Grammatik einen passenden Visitor (Interface <code>calcVisitor&lt;T&gt;</code>)
generieren (Option <code>-visitor</code> beim Aufruf von <code>antlr</code>). Weiterhin generiert ANTLR
eine leere Basisimplementierung (Klasse <code>calcBaseVisitor&lt;T&gt;</code>):</p>
<p><a href="#R-image-114f335f30d84c9819ebc2bf736e2cc3" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParseTreeVisitor.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-114f335f30d84c9819ebc2bf736e2cc3"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/antlr-parsing/ParseTreeVisitor.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>(Nur &quot;interessante&quot; Methoden gezeigt.)</p>
<p>Von dieser Basisklasse leitet man einen eigenen Visitor ab und überschreibt
die Methoden, die man benötigt. Wichtig ist, dass man selbst für das &quot;Besuchen&quot;
der Kindknoten sorgen muss (rekursiver Aufruf der geerbten Methode <code>visit()</code>).</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyVisitor</span> <span style="color:#66d9ef">extends</span> calcBaseVisitor<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">visitMULT</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">MULTContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">visitADD</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">ADDContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">visitZAHL</span><span style="color:#f92672">(</span>calcParser<span style="color:#f92672">.</span><span style="color:#a6e22e">ZAHLContext</span> ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div><p>Anschließend baut man das alles in eine manuelle Traversierung des Parse-Trees ein:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestMyVisitor</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyVisitor</span> <span style="color:#66d9ef">extends</span> calcBaseVisitor<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        calcLexer lexer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcLexer<span style="color:#f92672">(</span>CharStreams<span style="color:#f92672">.</span><span style="color:#a6e22e">fromStream</span><span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        CommonTokenStream tokens <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CommonTokenStream<span style="color:#f92672">(</span>lexer<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        calcParser parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> calcParser<span style="color:#f92672">(</span>tokens<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ParseTree tree <span style="color:#f92672">=</span> parser<span style="color:#f92672">.</span><span style="color:#a6e22e">s</span><span style="color:#f92672">();</span>    <span style="color:#75715e">// Start-Regel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        MyVisitor eval <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyVisitor<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        eval<span style="color:#f92672">.</span><span style="color:#a6e22e">visit</span><span style="color:#f92672">(</span>tree<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div><div style="text-align: right;">
<span class="btn cstyle default">
  <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/lecture/frontend/parsing/src/TestMyVisitor.java" target="_blank">
    Beispiel: TestMyVisitor.java und calc.g4
  </a>
</span></div>
<p>In <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/syntaxdriven.html">Syntaxgesteuerte Interpreter</a>
werden wir damit einen einfachen syntaxgesteuerten Interpreter aufbauen.</p>
<h2 id="eingebettete-aktionen-und-attribute">Eingebettete Aktionen und Attribute</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>s   : expr                      {System.err.println($expr.v);}
</span></span><span style="display:flex;"><span>    ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>expr <span style="color:#66d9ef">returns</span> [int v]
</span></span><span style="display:flex;"><span>    : e1<span style="color:#f92672">=</span>expr <span style="color:#e6db74">&#39;*&#39;</span> e2<span style="color:#f92672">=</span>expr       {$v = $e1.v * $e2.v;}
</span></span><span style="display:flex;"><span>    ;</span></span></code></pre></div><p>Auch die Parser-Regeln können mit eingebetteten Aktionen ergänzt werden, die
in die (für die jeweilige Regel) generierte Methode eingefügt werden und bei
erfolgreicher Anwendung der Parser-Regel ausgeführt werden.</p>
<p>Über <code>returns [int v]</code> fügt man der Regel <code>expr</code> ein Attribut <code>v</code> (Integer)
hinzu, welches man im jeweiligen Kontext abfragen bzw. setzen kann (agiert
als Rückgabewert der generierten Methode). Auf diesen Wert kann in den
Aktionen mit <code>$v</code> zugegriffen werden.</p>
<p>In <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/attribgrammars.html">Attributierte Grammatiken</a>
werfen wir einen genaueren Blick auf die attributierten Grammatiken. In
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/syntaxdriven.html">Syntaxgesteuerte Interpreter</a>
werden wir eingebettete Aktionen und Attribute nutzen, um einen einfachen
syntaxgesteuerten Interpreter aufzubauen.</p>
<p><em>Anmerkung</em>: Durch den Einsatz von eingebetteten Aktionen und Attributen wird
die Grammatik abhängig von der Zielsprache des generierten Lexers/Parsers!</p>
<h2 id="ausblick">Ausblick</h2>
<p>Damit haben wir die sprichwörtliche &quot;Spitze des Eisbergs&quot; gesehen. Mit ANTLR
sind noch viele weitere Dinge möglich. Bitte nutzen Sie aktiv die Dokumentation
auf <a href="https://github.com/antlr/antlr4" target="_blank">github.com/antlr/antlr4</a>.</p>
<p>Mit Hilfe von semantischen Prädikaten (vgl.
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/ll-advanced.html">LL-Parser: Fortgeschrittene Techniken</a>)
können Parser-Regeln aktiviert oder abgeschaltet werden, je nachdem, was vorher
gesehen wurde.</p>
<p>Dem Thema Behandlung von Fehlern ist eine eigene Sitzung gewidmet:
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery.html">Error-Recovery</a>.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<p>Parser mit ANTLR generieren: Parser-Regeln werden mit <strong>Kleinbuchstaben</strong> geschrieben</p>
<ul>
<li>Regeln können Lexer- und Parser-Regeln &quot;aufrufen&quot;</li>
<li>Regeln können Alternativen haben</li>
<li>Bei Mehrdeutigkeit: Vorrang für erste Alternative</li>
<li>ANTLR erlaubt direkte Links-Rekursion</li>
<li>ANTLR erzeugt Parse-Tree</li>
<li>Benannte Alternativen und Regel-Elemente</li>
<li>Traversierung des Parse-Tree: Listener oder Visitoren, Zugriff auf Kontextobjekte</li>
</ul>


    



    



    

    
<div class="box notices cstyle note">
  <div class="box-label"><i class="fas fa-puzzle-piece"></i> Challenges</div>
  <div class="box-content">

<p><strong>Lexer und Parser mit ANTLR: Programmiersprache Lox</strong></p>
<p>Betrachten Sie folgenden Code-Schnipsel in der Sprache <a href="https://www.craftinginterpreters.com/the-lox-language.html" target="_blank">&quot;Lox&quot;</a>:</p>
<pre><code>fun fib(x) {
    if (x == 0) {
        return 0;
    } else {
        if (x == 1) {
            return 1;
        } else {
            fib(x - 1) + fib(x - 2);
        }
    }
}

var wuppie = fib(4);
</code></pre>
<p>Erstellen Sie für diese fiktive Sprache einen Lexer+Parser mit ANTLR.</p>
<p>(Die genauere Sprachdefinition finden Sie bei Bedarf unter <a href="https://www.craftinginterpreters.com/the-lox-language.html" target="_blank">craftinginterpreters.com/the-lox-language.html</a>.)</p>
</div>
</div>



    





    




    
    
        
        

        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Grenze Lexer und Parser</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>Die Grenze zwischen Lexer und Parser ist gleitend. Das Ziel jeder Verarbeitungsstufe in der
Compilerpipeline sollte es sein, eine möglichst hohe Abstraktion auf der jeweiligen Ebene
zu erreichen.</p>
<p>Das führt zu einfachen Grundregeln:</p>
<ul>
<li>Verwerfe im Lexer alles, was ich später nicht mehr benötige</li>
<li>Fasse so viel wie möglich zusammen:
<ul>
<li>Dinge, die der Parser unterscheiden können muss, sollten vom Lexer als unterschiedliche
Token erkannt werden</li>
<li>Dinge, die der Parser nicht unterscheiden muss, könnten in einen gemeinsamen Token-Typ
geschrieben werden</li>
<li>Fasse nach Möglichkeit passende Zeichenfolgen als ein Token zusammen, d.h. präsentiere
dem Parser nicht eine Folge von Ziffern-Token, sondern <em>ein</em> Number-Token (wenn im
Zeichenstrom eine Integerzahl kommt)</li>
</ul>
</li>
</ul>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/u9fE_I764rg' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Grenze Lexer und Parser</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/cb1486383c3bc9cf2e1c88b2dd94dea71954ceb2f6ea23dea512f10b3d86c34363b8d9c0ab41ef56fc07d9e3b22726752a92ff426592f129c6d6e674795f91cb' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Grenze Lexer und Parser</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K2) Grenze zwischen Lexer und Parser: Was mache ich auf welcher Stufe?</li></ul></div>
</div>




    <h2 id="grenze-lexer-und-parser-faustregeln">Grenze Lexer und Parser (Faustregeln)</h2>
<p>Der Lexer verwendet einfache reguläre Ausdrücke, während der Parser
mit Lookaheads unterschiedlicher Größe, Backtracking und umfangreicher
Error-Recovery arbeitet. Entsprechend sollte man alle Arbeit, die
man bereits im Lexer erledigen kann, auch dort erledigen. Oder
andersherum: Man sollte dem Parser nicht unnötige Arbeit aufbürden.</p>
<p>=&gt; Erreiche in jeder Verarbeitungsstufe die maximal mögliche Abstraktionsstufe!</p>
<ol>
<li>
<p>Matche und verwerfe im Lexer alles, was der Parser nicht braucht.</p>
<p>Wenn bestimmte Dinge später nicht gebraucht werden, sollten sie bereits
im Lexer erkannt und aussortiert werden. Der Lexer arbeitet deutlich
einfacher und schneller als der Parser ... Und je weniger Token der
Parser betrachten muss, um so einfacher und schneller kann er werden.</p>
</li>
<li>
<p>Matche gebräuchliche Token (Namen, Schlüsselwörter, Strings, Zahlen) im Lexer.</p>
<p>Der Lexer hat deutlich weniger Overhead als der Parser. Es lohnt sich deshalb,
beispielsweise Ziffern bereits im Lexer zu Zahlen zusammenzusetzen und dem
Parser als entsprechendes Token zu präsentieren.</p>
</li>
<li>
<p>Quetsche alle lexikalischen Strukturen, die der Parser nicht unterscheiden muss, in einen Token-Typ.</p>
<p>Wenn der Parser bestimmte Strukturen nicht unterscheiden muss, dann macht es
wenig Sinn, dennoch unterschiedliche Token an den Parser zu senden.</p>
<p>Beispiel:
Wenn eine Anwendung nicht zwischen Integer- und Gleitkommazahlen unterscheidet,
sollte der Lexer dafür nur einen Token-Typ erzeugen und an den Parser senden
(etwa <code>NUMBER</code>).</p>
<p>Beispiel:
Wenn der Parser nicht den Inhalt eines XML-Tags &quot;verstehen&quot; muss, dann kann man
diesen in ein einzelnes Token packen.</p>
</li>
<li>
<p>Wenn der Parser Texteinheiten unterscheiden muss, erzeuge dafür eigene Token-Typen im Lexer.</p>
<p>Wenn der Parser etwa Elemente einer Telefonnummer verarbeiten muss, sollte
der Lexer passende Token für die Teile der Telefonnummer erzeugen und an den
Parser schicken.</p>
</li>
</ol>
<h2 id="diskussion-parsen-von-adressbüchern-und-telefonnummern">Diskussion: Parsen von Adressbüchern und Telefonnummern</h2>
<p>Typischer Aufbau eines Adressbuch-Eintrags:</p>
<pre><code>Vorname Name: +49.571.8385-268
</code></pre>
<ul>
<li>
<p>Zählen der Zeilen des Adressbuchs</p>
<p>Wenn es nur um das Zählen der Zeilen geht, muss der Parser nicht den
Aufbau der Zeilen oder sogar den Aufbau von Telefonnummern verstehen.
Es reichen einfache Lexer-Regeln (<code>ROW</code>), die quasi die Zeilenumbrüche
repräsentieren. Der Rest (<code>OTHER</code>) wird per <code>skip</code> (ANTLR-Syntax)
einfach entfernt ...</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>addrbk : <span style="color:#66d9ef">ROW</span><span style="color:#f92672">+</span>;
</span></span><span style="display:flex;"><span>ROW    : <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>OTHER  : <span style="color:#f92672">~</span><span style="color:#e6db74">&#39;\n&#39;</span> <span style="color:#f92672">-&gt;</span> skip ;</span></span></code></pre></div></li>
<li>
<p>Liste aller Telefonnummern</p>
<p>Wenn man nun eine Liste aller Telefonnummern erzeugen will, wäre es ausreichend,
die Struktur einer Zeile (und damit die Telefonnummern) mit Lexer-Regeln
(und -Fragmenten) zu erkennen.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>addrbk  : row<span style="color:#f92672">+</span>;
</span></span><span style="display:flex;"><span>row     : <span style="color:#66d9ef">SURNAME</span> <span style="color:#66d9ef">NAME</span> <span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#66d9ef">TELNR</span>;</span></span></code></pre></div></li>
<li>
<p>Weitere Verarbeiten der Telefonnummern im Parser (Aktionen)</p>
<p>Wenn man zusätzlich die Telefonnummern noch weiter im Parser verarbeiten will
(etwa durch eingebettete Aktionen), dann muss die Regel zum Erkennen der
Adressen entsprechend eine Parser-Regel sein:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>addrbk  : row<span style="color:#f92672">+</span>;
</span></span><span style="display:flex;"><span>row     : <span style="color:#66d9ef">SURNAME</span> <span style="color:#66d9ef">NAME</span> <span style="color:#e6db74">&#39;:&#39;</span> telnr;</span></span></code></pre></div></li>
</ul>
<p>Die weiterführenden Lexer- und Parser-Regeln (<code>telnr</code>, <code>TELNR</code>, <code>SURNAME</code>, <code>NAME</code>)
sind hier nicht dargestellt.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>Grenze zw. Lexer und Parser ist gleitend</li>
<li>Ziel: möglichst hohe Abstraktion auf jeder Ebene erreichen</li>
</ul>


    



    



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Nystrom2021'>[Nystrom2021] <a href='https://github.com/munificent/craftinginterpreters' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>Crafting Interpreters</strong></a><br>Nystrom, R., Genever Benning, 2021. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-9905829-3-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-9905829-3-9</a>.</li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Syntaxanalyse: LR-Parser (Teil 1)</h1>



    
    




    
    
        
        
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="far fa-file-powerpoint"></i> Annotierte Folien</div>
  <div class="box-content">

<ul> <li><a href='https://raw.githubusercontent.com/Compiler-CampusMinden/AnnotatedSlides/master/lr-parser1.ann.ma.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Annotierte Folien: LR-Parser1</a></li></ul></div>
</div>




    <h1 id="wiederholung">Wiederholung</h1>
<h2 id="top-down-analyse">Top-Down-Analyse</h2>
<ul>
<li>Baumaufbau von oben nach unten</li>
<li>die Grammatik muss reduziert sein</li>
<li>recursive-descent parser</li>
<li><em>First-</em> und <em>Follow</em>-Mengen bestimmen Wahl der Ableitungen</li>
<li>tabellengesteuert</li>
<li>nicht mehr rekursiv, sondern mit PDA</li>
</ul>
<h1 id="motivation">Motivation</h1>
<h2 id="ll-ist-nicht-alles"><em>LL</em> ist nicht alles</h2>
<p>Die Menge der <em>LL</em>-Sprachen ist eine echte Teilmenge der deterministisch kontextfreien Sprachen. Wir brauchen ein Verfahren, mit dem man alle deterministisch kontextfreien Sprachen parsen kann.</p>
<h1 id="bottom-up-analyse">Bottom-Up-Analyse</h1>
<h2 id="von-unten-nach-oben">Von unten nach oben</h2>
<p>Bei 
<span class="math align-center">$LL$</span>-Sprachen muss man nach den ersten 
<span class="math align-center">$k$</span> Eingabezeichen entscheiden, welche Ableitung ganz oben im Baum als erste durchgeführt wird, also eine, die im Syntaxbaum ganz weit weg ist von den Terminalen, die die Entschiedung bestimmen.Es gibt deterministisch kontextfreie Sprachen, die nicht 
<span class="math align-center">$LL(k)$</span> sind für irgendein <em>k</em>.</p>
<p>Bei der Bottom-Up-Analyse geht man den umgekehrten Weg. Der Parse Tree wird von unten nach oben aufgebaut, die Entscheidung, welche Produktion angewandt wird, erfolgt &quot;näher&quot; am Terminal. Mit Hilfe der Produktionen und der Vorschautoken werden die Ableitungen &quot;rückwärts&quot; angewandt und &quot;Reduktionen&quot; genannt.</p>
<p>Fehlermeldungen können näher am Programmtext erfolgen.</p>
<h2 id="baumaufbau-von-unten">Baumaufbau von unten</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="kann-ein-stack-helfen">Kann ein Stack helfen?</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="probleme-damit">Probleme damit?</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h1 id="konfliktfälle">Konfliktfälle</h1>
<h2 id="mehrdeutigkeiten--konflikte-beim-parsen">Mehrdeutigkeiten = Konflikte beim Parsen</h2>
<p>Es gibt Grammatiken, bei denen nicht aus dem Inhalt des Stacks und dem Eingabezeichen entschieden werden kann, wie fortgefahren wird, auch nicht, wenn man, wie auch schon im Fall 
<span class="math align-center">$LL$</span>, eine feste Zahl 
<span class="math align-center">$k$</span> von Vorschautoken berücksichtigt. Diese Grammatiken können mehrdeutig sein.</p>
<p>Folgen von falschen Entscheidungen:</p>
<ul>
<li>falscher Baum, falsche Bäume</li>
<li>kein Baum</li>
</ul>
<h2 id="mögliche-konflikte">Mögliche Konflikte</h2>
<ul>
<li>Reduce-Reduce-Konflikt: Es sind zwei oder mehr verschiedene Reduktionen möglich</li>
<li>Shift-Reduce-Konflikt: Es kann nicht entschieden werden, ob eine Reduktion oder ein Shift durchgeführt werden soll.</li>
</ul>
<p>Shiften bedeutet, das nächste Eingabesymbol miteinbeziehen.</p>
<h1 id="lr-parsing">LR-Parsing</h1>
<h2 id="da-wollen-wir-hin">Da wollen wir hin</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser1/Parser-Automat.png" alt="Parser-Automat" width="80%" height="auto">
    <figcaption><p>Parser-Automat</p></figcaption>
</figure>
<h2 id="so-geht-es">So geht es</h2>
<p>Der Stack enthält Zustände, keine Terminals oder Nonterminals.</p>
<p>Der Top-of-Stack ist immer der aktuelle Zustand, am Anfang

<span class="math align-center">$I_0$</span>. Im Stack steht 
<span class="math align-center">$I_0\ \bot$</span>.</p>
<p>Vorgehen:
Im aktuellen Zustand nachschauen, ob das Eingabezeichen auf einem Pfeil steht.</p>
<ul>
<li>
<p>ja: Shiften, d. h. dem Pfeil folgen und den Zustand am Ende des Pfeils pushen. Dort weiter.</p>
</li>
<li>
<p>nein: Reduzieren nach der Regel aus dem aktuellen Zustand mit dem Punkt hinten, d. h. so viele Zustände poppen, wie die Regel Elemente auf der rechten Seite hat. Der Zustand darunter wird aktuell, dem Pfeil mit dem zu reduzierenden Nonterminal der linken Seite der Regel folgen und pushen.</p>
</li>
</ul>
<p>Am Schluss kann nur noch mit 
<span class="math align-center">$\bot$</span> akzeptiert werden.</p>
<h2 id="beispiel">Beispiel</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="definitionen">Definitionen</h2>
<p><strong>Def.:</strong> Bei einer kontextfreien Grammatik <em>G</em> ist die <em>Rechtsableitung</em> von 
<span class="math align-center">$\alpha \in (N \cup T)^{\ast}$</span> die Ableitung, die man erhält, wenn das am weitesten rechts stehende Nichtterminal in 
<span class="math align-center">$\alpha$</span> abgeleitet wird. Man schreibt 
<span class="math align-center">$\alpha \overset{\ast}{\Rightarrow}_r \beta$</span>.</p>
<p><strong>Def.:</strong> Eine <em>Rechtssatzform</em> 
<span class="math align-center">$\alpha$</span> einer Grammatik <em>G</em> ist ein Element aus

<span class="math align-center">$(N \cup T)^{\ast}$</span> mit 
<span class="math align-center">$S \overset{\ast}{\Rightarrow}_r \alpha$</span>.</p>
<p><strong>Def.:</strong> In dem Syntaxbaum von 
<span class="math align-center">$S \overset{\ast}{\Rightarrow}_r \alpha\ A\ w \Rightarrow_r \alpha\ \beta\ w$</span> einer kontextfreien Grammatik ist 
<span class="math align-center">$\beta$</span> ein <em>Handle</em> von der Produktion 
<span class="math align-center">$A \rightarrow \beta$</span>.</p>
<h2 id="lr-parsing-1">LR-Parsing</h2>
<p>Bei der <em>LR</em>-Analyse eines Wortes <em>w</em> wird <em>w</em> von links nach rechts gelesen, dabei wird die Rechtsableitung von <em>w</em> in <em>G</em> von unten nach oben aufgebaut.
Man spricht nicht nicht mehr von Ableitungen, sondern von Reduktionen.</p>
<p>Mehrdeutige Grammatiken können nicht <em>LR</em> sein.</p>
<ul>
<li>Vor der Konstruktion des Automaten wird die Grammatik um eine neues Nonterminal 
<span class="math align-center">$S'$</span> und die neue Produktion 
<span class="math align-center">$S' \rightarrow S$</span> erweitert. 
<span class="math align-center">$S'$</span> ist dann Startsymbol.</li>
<li>Es wird ein Automat erstellt (s.o.)</li>
<li>Es wird eine Parse Table aus dem Automaten erstellt, die den Parse-Vorgang steuert, mit Aktionsteil und Sprungteil.</li>
</ul>
<h2 id="steuerung-des-parsens-mittels-der-parse-table">Steuerung des Parsens mittels der Parse Table</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser1/ParserProgram.png" alt="Parser Schema" width="80%" height="auto">
    <figcaption><p>Parser Schema</p></figcaption>
</figure>
<h2 id="arbeitsweise">Arbeitsweise</h2>
<p>Im Stack stehen nur Zustandsnummern, am Anfang die Nummer des Startzustandes (+ Bottomzeichen, oft auch 
<span class="math align-center">$\$$</span>). Es ist nicht nötig, Symbole zu stacken.</p>
<ul>
<li>Lesen des obersten Stackelements ergibt Zustand <em>q</em></li>
<li>Lesen des nächsten Eingabezeichens ergibt Zeichen <em>a</em></li>
<li>Nachschlagen der Reaktion auf 
<span class="math align-center">$(q, a)$</span> in der Parse Table</li>
<li>Durchführung der Reaktion</li>
</ul>
<h2 id="mögliche-actions-ohne-berücksichtigung-von-vorschautoken">Mögliche &quot;Actions&quot; ohne Berücksichtigung von Vorschautoken</h2>
<ul>
<li>Shift: Schiebe logisch das nächste Eingabesymbol auf den Stack (in Wirklichkeit Zustandsnummern)</li>
<li>Reduce: (Identifiziere ein Handle oben auf dem Stack und ersetze es durch das Nichtterminal der dazugehörigen Produktion.) Das ist gleichbedeutend mit: Entferne so viele Zustände vom Stack wie die rechte Seite der zu reduzierenden Regel Elemente hat, und schreibe den Zustand, der im Goto-Teil für 
<span class="math align-center">$(q, a)$</span> steht, auf den Stack.</li>
<li>Accept: Beende das Parsen erfolgreich</li>
<li>Reagiere auf einen Syntaxfehler</li>
</ul>
<h1 id="0-vorschautoken--lr0-parsing">0 Vorschautoken = LR(0)-Parsing</h1>
<h2 id="lr-parsing-ohne-vorschautoken">LR-Parsing ohne Vorschautoken</h2>
<p>Wichtig: Das Handle, d. h. die rechte Seite einer zu reduzierenden Regel, erscheint oben auf dem Stack, nie weiter unten.</p>
<p>Je nach Anwendungsfall müssen beim Reduzieren von Handles weitere Aktionen ausgeführt werden: z. B. Syntaxbäume aufgebaut, Werte in Tabellen geschrieben werden, usw. Nicht alle rechten Seiten von Produktionen, die oben auf dem Stack stehen, sind auch Handles, manchmal muss nur geshiftet werden.</p>
<p>Bsp: Steht bei der Beispielgrammatik von Folie 8 oben auf dem Stack ein 
<span class="math align-center">$T$</span> mit dem nächsten Eingabezeichen 
<span class="math align-center">$\ast$</span>, darf 
<span class="math align-center">$T$</span> nicht zu 
<span class="math align-center">$E$</span> reduziert werden.</p>
<p>Lösung: Der Parser merkt sich, wo er steht in noch nicht komplett reduzierten Regeln. Dazu benutzt er sogenannte <em>Items</em> oder <em>LR(0)-Items</em>, auch <em>dotted Items</em> oder <em>(kanonische) LR(0)-Elemente</em> genannt.</p>
<h2 id="items">Items</h2>
<p><strong>Def.:</strong> Ein <em>Item</em> einer Grammatik <em>G</em> ist eine Produktion von <em>G</em> mit einem Punkt auf der rechten Seite der Regel vor, zwischen oder nach den Elementen.</p>
<p>Bsp.:</p>
<p>Zu der Produktion 
<span class="math align-center">$A \rightarrow BC$</span> gehören die Items:</p>

<span class="math align-center">$[A\rightarrow \cdot B C]$</span>
<p>
<span class="math align-center">$[A\rightarrow B \cdot C$</span>]</p>

<span class="math align-center">$[A\rightarrow B C \cdot]$</span>
<p>Das zu 
<span class="math align-center">$A \rightarrow \epsilon$</span> gehörende Item ist 
<span class="math align-center">$[A \rightarrow \cdot]$</span></p>
<h2 id="was-bedeuten-die-items">Was bedeuten die Items?</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="berechnung-der-closure_0-von-einer-menge-i-von-items">Berechnung der <em>Closure_0</em> von einer Menge <em>I</em> von Items</h2>
<ol>
<li>
<p>füge 
<span class="math align-center">$I$</span> zu 
<span class="math align-center">$CLOSURE_0 (I)$</span> hinzu</p>
</li>
<li>
<p>gibt es ein Item 
<span class="math align-center">$[A \rightarrow \alpha \cdot B\beta]$</span> aus 
<span class="math align-center">$CLOSURE_0 (I)$</span> und eine Produktion 
<span class="math align-center">$(B \rightarrow \gamma)$</span>, füge 
<span class="math align-center">$[B \rightarrow \cdot \gamma]$</span> zu 
<span class="math align-center">$CLOSURE_0 (I)$</span> hinzu</p>
</li>
</ol>
<h2 id="berechnung-der-goto_0-sprungmarken">Berechnung der <em>GOTO_0</em>-Sprungmarken</h2>

<span class="math align-center">$GOTO_0(I, X) = CLOSURE_0(\lbrace[A \rightarrow \alpha X \cdot \beta] \mid [A \rightarrow \alpha \cdot X \beta] \in I\rbrace)$</span>
<p>für eine Itemmenge <em>I</em> und 
<span class="math align-center">$X \in N \cup T, A \in N, \alpha, \beta \in (N \cup T)^{\ast}$</span>.</p>
<h2 id="konstruktion-des-hahahugoshortcode23s44hbhb---automaten">Konstruktion des 
<span class="math align-center">$LR(0)$</span> - Automaten</h2>
<ol>
<li>
<p>Bilde die Hülle von 
<span class="math align-center">$S' \rightarrow S$</span> und mache sie zum ersten Zustand.</p>
</li>
<li>
<p>Für jedes noch nicht betrachtete 
<span class="math align-center">$\cdot X, X \in (N \cup T)$</span> in einem Zustand 
<span class="math align-center">$q$</span> des Automaten berechne 
<span class="math align-center">$GOTO_0(q, X)$</span> und mache 
<span class="math align-center">$GOTO_0(q, X)$</span> zu einem neuen Zustand 
<span class="math align-center">$r$</span>. Verbinde 
<span class="math align-center">$q$</span> mit einem Pfeil mit 
<span class="math align-center">$r$</span> und schreibe 
<span class="math align-center">$X$</span> an den Pfeil. Ist ein zu 
<span class="math align-center">$r$</span> identischer Zustand schon vorhanden, wird 
<span class="math align-center">$p$</span> mit diesem verbunden und kein neuer erzeugt.</p>
</li>
</ol>
<h2 id="konstruktion-der-parse-table">Konstruktion der Parse Table</h2>
<ol>
<li>
<p>Erstelle eine leere Tabelle mit den Zuständen als Zeilenüberschriften. Für den Aktionstabellenteil überschreibe die Spalten mit den Terminalen, für den Sprungtabellenteil mit den Nonterminals.</p>
</li>
<li>
<p>Shift: Für jeden mit einem Terminal beschrifteten Pfeil aus einem Zustand erstelle in der Aktionstabelle die Aktion shift mit der Nummer des Zustands, auf den der Pfeil zeigt. Für Pfeile mit Nonterminals schreibe in die Sprungtabelle nur die Nummer des Folgezustands.</p>
</li>
<li>
<p>Schreibe beim Zustand 
<span class="math align-center">$[S' \rightarrow S \cdot]$</span> ein 
<span class="math align-center">$accept$</span> bei dem Symbol 
<span class="math align-center">$\bot$</span>.</p>
</li>
<li>
<p>Für jedes Item mit 
<span class="math align-center">$[A \rightarrow \beta \cdot]$</span> aus allen Zuständen schreibe für alle Terminals 
<span class="math align-center">$reduce$</span> und die Nummer der entsprechenden Grammatikregel in die Tabelle.</p>
</li>
</ol>
<h2 id="und-wenn-in-einer-zelle-schon-ein-eintrag-ist">Und wenn in einer Zelle schon ein Eintrag ist?</h2>
<p>Hier entsteht ein Tafelbild.</p>
<h2 id="die-beispielgrammatik-g1">Die Beispielgrammatik G1</h2>
<p>(0) 
<span class="math align-center">$S^{'} \rightarrow S$</span></p>
<p>(1) 
<span class="math align-center">$S \rightarrow a A b S c S$</span></p>
<p>(2) 
<span class="math align-center">$S \rightarrow a A b S$</span></p>
<p>(3) 
<span class="math align-center">$S \rightarrow d$</span></p>
<p>(4) 
<span class="math align-center">$A \rightarrow e$</span></p>
<h2 id="der-lr0-automat-zu-g1">Der LR(0)-Automat zu G1</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser1/LR_0-SLR_1-Automat.png" alt="LR(0)-Automat" width="auto" height="auto">
    <figcaption><p>LR(0)-Automat</p></figcaption>
</figure>
<h2 id="die-lr0-parsertabelle-zu-g1">Die LR(0)-Parsertabelle zu G1</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser1/LR_0-Table.png" alt="LR(0)-Parsertabelle" width="60%" height="auto">
    <figcaption><p>LR(0)-Parsertabelle</p></figcaption>
</figure>
<h1 id="wrap-up">Wrap-Up</h1>
<h2 id="wrap-up-1">Wrap-Up</h2>
<ul>
<li>
<p>LR-Analyse baut den Ableitungbaum von unten nach oben auf.</p>
</li>
<li>
<p>Es wird ein DFA benutzt zusammen mit einem Stack, der Zustände speichert.</p>
</li>
<li>
<p>Eine Parse-Tabelle steuert über Aktions- und Sprungbefehle das Verhalten des Parsers.</p>
</li>
<li>
<p>Die Tabelle wird mit Items und Closures konstruiert.</p>
</li>
</ul>


    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Kapitel 4.5 bis 4.8</em></li> <li id='id_aho2013compilers'>[aho2013compilers] <strong>Compilers: Pearson New International Edition: Principles, Techniques, and Tools</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Education Limited, 2013. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-2920-3723-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-2920-3723-3</a>.</li> <li id='id_hopcroft2003'>[hopcroft2003] <strong>Einführung in die Automatentheorie, formale Sprachen und Komplexitätstheorie</strong><br>Hopcroft, J. E. und Motwani, R. und Ullman, J. D., Pearson Education Deutschland GmbH, 2003. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7020-4' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7020-4</a>.</li> <li id='id_Kunert2018'>[Kunert2018] <a href='http://amor.cms.hu-berlin.de/\~kunert/papers/lr-analyse/lr.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>LR(k)-Analyse für Pragmatiker</strong></a><br>Kunert, A., 2018.</li> <li id='id_Wagenknecht2014'>[Wagenknecht2014] <strong>Formale Sprachen, abstrakte Automaten und Compiler</strong><br>Wagenknecht, C. und Hielscher, M., Springer Fachmedien Wiesbaden, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-658-02692-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-658-02692-9</a>. DOI <a href='https://doi.org/10.1007/978-3-658-02692-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-658-02692-9</a>.</li></ul></div>
</div>



    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) Prinzipien der Bottom-Up-Analyse</li> <li>(K1) Items</li> <li>(K1) Closure</li> <li>(K1) Parse Table</li> <li>(K2) LR(0)-Parsing</li> <li>(K3) Konstruktion der Parse Tables</li> <li>(K3) Durchführen des Parsens</li></ul></div>
</div>



    








<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Syntaxanalyse: LR-Parser (Teil 2)</h1>



    
    




    
    
        
        
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="far fa-file-powerpoint"></i> Annotierte Folien</div>
  <div class="box-content">

<ul> <li><a href='https://raw.githubusercontent.com/Compiler-CampusMinden/AnnotatedSlides/master/lr-parser2.ann.ma.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Annotierte Folien: LR-Parser2</a></li></ul></div>
</div>




    <h1 id="wiederholung">Wiederholung</h1>
<p>Ein PDA für 
<span class="math align-center">$L=\lbrace ww^{R}\mid w\in \lbrace a,b\rbrace^{\ast}\rbrace$</span>:</p>
<p><a href="#R-image-358048f532d792aab9f84bdec706dcd9" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/pda.png?width=60%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 60%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-358048f532d792aab9f84bdec706dcd9"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/pda.png?width=60%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<h2 id="top-down-analyse">Top-Down-Analyse</h2>
<ul>
<li>LL reicht nicht.</li>
<li>LR: Aufbau des Ableitungsbaums von unten nach oben.</li>
<li>LR(0): Parsen ohne Vorschautoken</li>
<li>Ein DFA mit einem Stack wird über eine Tabelle mit Aktions- und Sprungbefehlen gesteuert.</li>
<li>Im Stack stehen Zustände des DFAs.</li>
<li>Diese Zustände werden mit sog. Dotted Items und deren Closures identifiziert.</li>
</ul>
<h1 id="motivation">Motivation</h1>
<h2 id="auch-lr0-ist-nicht-alles">Auch <em>LR(0)</em> ist nicht alles</h2>
<p>Die Menge der <em>LR(0)</em>-Sprachen ist eine echte Teilmenge der deterministisch kontextfreien Sprachen. Wir brauchen ein Verfahren, mit dem man alle deterministisch kontextfreien Sprachen parsen kann.</p>
<h1 id="bottom-up-analyse-mit-vorschautoken">Bottom-Up-Analyse mit Vorschautoken</h1>
<h2 id="lr-parsen-mit-1-vorschautoken">LR-Parsen mit 1 Vorschautoken</h2>
<p>Ist eine Grammatik nicht LR(0), kann sie vielleicht mit einem Vorschautoken geparst werden. Hier gibt es drei Verfahren:</p>
<ul>
<li>SLR(1)-Parsing</li>
<li>(kanonisches) LR(1)-Parsing</li>
<li>LALR(1)-Parsing</li>
</ul>
<h1 id="slr">SLR</h1>
<h2 id="simple-lr1--slr-parsing">Simple LR(1) = (SLR)-Parsing</h2>
<p>
<span class="math align-center">$A \rightarrow \beta$</span> wird nur reduziert, wenn das Vorschautoken in der 
<span class="math align-center">$FOLLOW$</span>-Menge von 
<span class="math align-center">$A$</span> ist.</p>
<p>
<span class="math align-center">$\Rightarrow$</span> Es ändert sich nur die Parse Table:</p>
<p>Bei allen LR(0)-Items in der Tabelle, die einen Punkt am Ende der
rechten Seite stehen haben, trage in der
Aktionstabelle beim zugehörigen Zustand die Reduktion mittels der zugehörigen
Regel bei allen Terminals ein, die in der FOLLOW-Menge des Nonterminals auf der linken Seite der Regel enthalten sind.</p>
<h2 id="der-slr-automat-der-grammatik-g1">Der SLR-Automat der Grammatik G1:</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/LR_0-SLR_1-Automat.png" alt="SLR(1)-Automat" width="auto" height="auto">
    <figcaption><p>SLR(1)-Automat</p></figcaption>
</figure>
<h2 id="die-slr-parsertabelle-der-grammatik-g1">Die SLR-Parsertabelle der Grammatik G1</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/SLR_1-Table.png" alt="SLR(1)-Parsertabelle" width="60%" height="auto">
    <figcaption><p>SLR(1)-Parsertabelle</p></figcaption>
</figure>
<h2 id="zum-vergleich-die-lr0-tabelle-von-g1-letzte-vorlesung">Zum Vergleich: Die LR(0)-Tabelle von G1 (letzte Vorlesung)</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/LR_0-Table.png" alt="LR(0)-Parsertabelle" width="60%" height="auto">
    <figcaption><p>LR(0)-Parsertabelle</p></figcaption>
</figure>
<h1 id="kanonische-lr1-syntaxanalyse">Kanonische LR(1)-Syntaxanalyse</h1>
<h2 id="mehr-geht-nicht-kanonische-lr1-syntaxanalyse--lr-analyse">Mehr geht nicht: Kanonische LR(1)-Syntaxanalyse = LR-Analyse</h2>
<p>Beim SLR-Verfahren wird nach 
<span class="math align-center">$A \rightarrow \beta$</span> reduziert, wenn das Vorschautoken in 
<span class="math align-center">$Follow(A)$</span> liegt. Dabei kann es vorkommen, dass das Vorschautoken ein Element davon ist, aber genau bei dieser Regel kann es nicht dem <em>A</em> folgen. Es wird also falsch reduziert, und es entstehen zu viele Einträge in der Tabelle (Konflikte!).</p>
<p>Jetzt werden nicht Follow-Mengen von Nichtterminalen, sondern LOOKAHEAD-Mengen von Produktionen berechnet.</p>
<h2 id="die-lr1-items">Die LR(1)-Items</h2>
<p>Zu jedem LR(0)-Item (hier auch <em>Kern</em> genannt) wird eine <em>LOOKAHEAD</em> - Menge 
<span class="math align-center">$L$</span> hinzugefügt, die angibt, welche Terminals dem Symbol auf der linken Seite folgen können.</p>
<p>z.  B. 
<span class="math align-center">$[S' \rightarrow \cdot S, \lbrace \bot \rbrace ]$</span></p>
<h2 id="die-hülle-hahahugoshortcode24s12hbhb">Die Hülle 
<span class="math align-center">$CLOSURE_1$</span></h2>
<ol>
<li>
<p>füge 
<span class="math align-center">$I$</span> zu 
<span class="math align-center">$CLOSURE_1 (I)$</span> hinzu</p>
</li>
<li>
<p>gibt es ein LR(1) - Item 
<span class="math align-center">$[A \rightarrow \alpha \cdot B \beta,\ L]$</span> aus 
<span class="math align-center">$CLOSURE_1 (I)$</span> und eine Produktion 
<span class="math align-center">$(B \rightarrow \gamma)$</span>, füge 
<span class="math align-center">$[B \rightarrow \cdot \gamma, FIRST(\beta\ L)]$</span> zu 
<span class="math align-center">$CLOSURE_1 (I)$</span> hinzu (
<span class="math align-center">$\alpha, \beta$</span> dürfen 
<span class="math align-center">$\epsilon$</span> sein).</p>
</li>
</ol>
<h2 id="hahahugoshortcode24s22hbhb">
<span class="math align-center">$Goto_1$</span></h2>
<p>
<span class="math align-center">$GOTO_1(I, X) =$</span> eine Produktion</p>

<span class="math align-center">$CLOSURE_1(\lbrace[A \rightarrow \alpha X \cdot \beta, \ L] \mid [A \rightarrow \alpha \cdot X \beta,\ L] \in I\rbrace)$</span>
<p>für eine Itemmenge 
<span class="math align-center">$I$</span> und 
<span class="math align-center">$X \in N \cup T, A \in N, \alpha, \beta \in (N \cup T)^{\ast}$</span>.</p>
<h2 id="der-lr1-automat">Der LR(1)-Automat</h2>
<p>Der Automat wird analog zum LR(0)-Automaten erstellt mit dem Startzustand</p>

<span class="math align-center">$[S' \rightarrow \cdot S, \lbrace \bot \rbrace ]$</span>
<p>Die Tabelle unterscheidet sich nur bei der Reduktion von der LR(0)-Tabelle:</p>
<p>Reduktionsoperationen werden in den Spalten der
Terminals eingetragen, die in der LOOKAHEAD-Menge der entsprechenden Regel enthalten sind.</p>
<h2 id="die-beispielgrammatik-g2">Die Beispielgrammatik G2</h2>
<p>(0) 
<span class="math align-center">$S^{'} \rightarrow S$</span></p>
<p>(1) 
<span class="math align-center">$S \rightarrow NN$</span></p>
<p>(2) 
<span class="math align-center">$N \rightarrow 0N$</span></p>
<p>(3) 
<span class="math align-center">$N \rightarrow 1$</span></p>
<h2 id="der-lr1-automat-der-grammatik-g2">Der LR(1)-Automat der Grammatik G2</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/LR_1-Automat.png" alt="LR(1)-Automat" width="auto" height="auto">
    <figcaption><p>LR(1)-Automat</p></figcaption>
</figure>
<h2 id="die-lr1-parsertabelle-der-grammatik-g2">Die LR(1)-Parsertabelle der Grammatik G2</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/LR_1-Table.png" alt="LR(1)-Parsertabelle" width="45%" height="auto">
    <figcaption><p>LR(1)-Parsertabelle</p></figcaption>
</figure>
<h1 id="lookahead-lr--lalr">Lookahead-LR = LALR</h1>
<h2 id="lalr1">LALR(1)</h2>
<p>Zusammenfassung aller LR(1)-Zustände, die sich nur in den LOOKAHEAD-Mengen unterscheiden</p>
<p>Parsergeneratoren generieren oft direkt aus einem LR(0)- einen LALR(1)-Zustands-
Übergangsgraphen durch Hinzufügen der LOOKAHEAD-Mengen.</p>
<h2 id="der-lalr-automat-der-grammatik-g2">Der LALR-Automat der Grammatik G2</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/LALR-Automat.png" alt="LALR(1)-Automat" width="auto" height="auto">
    <figcaption><p>LALR(1)-Automat</p></figcaption>
</figure>
<h2 id="die-lalr-parsertabelle-der-grammatik-g2">Die LALR-Parsertabelle der Grammatik G2</h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/LALR-Table.png" alt="LALR(1)-Parsertabelle" width="60%" height="auto">
    <figcaption><p>LALR(1)-Parsertabelle</p></figcaption>
</figure>
<h1 id="hahahugoshortcode24s36hbhb-vorschautoken">
<span class="math align-center">$k \geq 2$</span> Vorschautoken</h1>
<h2 id="hierarachie">Hierarachie</h2>
<p>Zu jeder LR(k)-Sprache gibt es eine LR(1)-Grammatik.</p>
<h1 id="mehrdeutige-grammatiken">Mehrdeutige Grammatiken</h1>
<h2 id="es-gibt-auch-auswege">Es gibt auch Auswege</h2>
<p>Mehrdeutige Grammatiken sind oft leichter zu lesen und kleiner als die Grammatiken, die man erhält, wenn man die Mehrdeutigkeit auflöst, sofern möglich.
Also die Grammatik mehrdeutig lassen!</p>
<p>Folgendes kann trotzdem helfen:</p>
<ul>
<li>Angabe von Vorrangregeln</li>
<li>Angabe von Assoziativität</li>
<li>Voreinstellung des Parsergenearators: z. B. Shiften bei Shift-Reduce-Konflikten</li>
<li>Voreinstellung des Parsergenearators: z. B. Reduzieren nach der Regel, die in der Grammatik zuerst kommt bei Reduce-Reduce-Konflikten</li>
</ul>
<h1 id="hierarchie-der-kontextfreien-sprachen">Hierarchie der kontextfreien Sprachen</h1>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/lr-parser2/CFG-Hierarchy.png" alt="Sprachenhierarchie" width="80%" height="auto">
    <figcaption><p>Sprachenhierarchie</p></figcaption>
</figure>
<h1 id="wrap-up">Wrap-Up</h1>
<h2 id="wrap-up-1">Wrap-Up</h2>
<ul>
<li>
<p>mit Bottom-Up-Parsing LR(1) kann man alle deterministisch kontextfreien Sprachen parsen</p>
</li>
<li>
<p>ein Vorschautoken genügt</p>
</li>
<li>
<p>LR(0)-, SLR- und LALR- Parsing sind vereinfachte Verfahren für Teilmengen der LR-Sprachen</p>
</li>
</ul>


    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                
            
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Kapitel 4.5 bis 4.8</em></li> <li id='id_aho2013compilers'>[aho2013compilers] <strong>Compilers: Pearson New International Edition: Principles, Techniques, and Tools</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Education Limited, 2013. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-2920-3723-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-2920-3723-3</a>.</li> <li id='id_hopcroft2003'>[hopcroft2003] <strong>Einführung in die Automatentheorie, formale Sprachen und Komplexitätstheorie</strong><br>Hopcroft, J. E. und Motwani, R. und Ullman, J. D., Pearson Education Deutschland GmbH, 2003. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7020-4' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7020-4</a>.</li> <li id='id_Kunert2018'>[Kunert2018] <a href='http://amor.cms.hu-berlin.de/\~kunert/papers/lr-analyse/lr.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'><strong>LR(k)-Analyse für Pragmatiker</strong></a><br>Kunert, A., 2018.</li> <li id='id_Wagenknecht2014'>[Wagenknecht2014] <strong>Formale Sprachen, abstrakte Automaten und Compiler</strong><br>Wagenknecht, C. und Hielscher, M., Springer Fachmedien Wiesbaden, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-658-02692-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-658-02692-9</a>. DOI <a href='https://doi.org/10.1007/978-3-658-02692-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-658-02692-9</a>.</li></ul></div>
</div>



    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K1) Prinzipien der Bottom-Up-Analyse</li> <li>(K1) Items</li> <li>(K1) Closure</li> <li>(K1) Parse Table</li> <li>(K2) LR(0)-Parsing</li> <li>(K2) SLR-Parsing</li> <li>(K2) LR(1)-Parsing</li> <li>(K2) LALR-Parsing</li> <li>(K3) Konstruktion der Parse Tables</li> <li>(K3) Durchführen des Parsens</li></ul></div>
</div>



    








<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Error-Recovery</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>Umgang mit Fehlern ist im Compiler sehr wichtig: Falscher Code darf nicht in ein ausführbares Programm
umgewandelt werden oder ausgeführt werden, gleichzeitig erwarten Nutzer zielführende Fehlermeldungen
und auch das Erkennen von möglichst mehreren Fehlern in einem Lauf.</p>
<p>Auf der Ebene des Parsers kann man Fehler in Bezug auf die Grammatik erkennen. Typische Strategien sind
das Entfernen von Token aus dem Eingabestrom, bis wieder ein Token erscheint, welches die weitere Abarbeitung
der aktuellen Regel erlaubt (&quot;Synchronisierung&quot;). Dies sind oft Zeilenenden, ein Semikolon oder eine schließende
geschweifte Klammer. Dieses recht einfache, aber grobe Vorgehen kann verfeinert werden, indem man versucht,
überschüssige Token zu entfernen oder fehlender Token zu ersetzen. In ANTLR wird beispielsweise maximal ein
fehlendes Token virtuell &quot;ersetzt&quot; bzw. max. ein überschüssiges Token entfernt, damit man den restlichen Code
weiter parsen kann. Wenn mehr als ein Token fehlt oder zu viel ist, geht ANTLR in einen &quot;Panic Mode&quot; und
entfernt so lange Token aus dem Eingabestrom, bis das aktuelle Token in einem <em>Resynchronization Set</em> enthalten
ist. Die Bildung dieser Menge erinnert an die Regeln zum Bilden der <em>FOLLOW</em>-Mengen, ist aber an den Kontext
der &quot;aufgerufenen&quot; Parser-Regeln gebunden. Zusätzlich gibt es weitere Strategien zum Behandeln von Fehlern in
Schleifen sowie zur Vermeidung von Endlos-Fehlerbehebungsschleifen (&quot;Fail-Save&quot;). In Bison wird dagegen mit
einem speziellen <em>error</em>-Token gearbeitet und man fügt an &quot;strategischen&quot; Stellen Regeln der Form Regel 
<span class="math align-center">$A \to \operatorname{error} \alpha$</span> hinzu. Dabei ist 
<span class="math align-center">$\alpha$</span> ein Token, welches zur Synchronisierung genutzt werden
soll. Im Fehlerfall werden so lange Token vom Stack entfernt, bis man eine Regel 
<span class="math align-center">$A \to \operatorname{error} \alpha$</span> anwenden kann und das <em>error</em>-Token shiften kann. Danach werden ggf. so lange Token aus dem Eingabestrom
entfernt, bis das Token 
<span class="math align-center">$\alpha$</span> auftaucht und man die Regel mit einem <em>reduce</em> abschließen kann. Diese Form
der Behandlung stellt einen Kompromiss zwischen Aufwand (auch Zeit) und Nutzen dar.</p>
<p>Zusätzlich kann man in der Grammatik bereits typische Fehler (vergessene Klammern oder Typos wie Dreher bei
Schlüsselwörtern) schon über &quot;Fehlerproduktionen&quot; vorwegnehmen. Das bedeutet, dass man eine Regel formuliert,
die diesen typischen Tippfehler akzeptiert (und korrigiert), aber zusätzlich eine Warnung generiert. Es muss
dann aber jeweils entschieden werden, ob der entsprechende Quellcode in ein ausführbares Programm übersetzt
werden darf.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/9sFdI7pYMQs' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Error-Recovery</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/eabf5e829fbcd6be866e20b169989c8fef4fd10f13704999d0c1b531d15d4255975cd4490ac127156874d8334d6cade0ece8e2d15f2f2d34cb965a0c1697eade' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Error-Recovery</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K2) Varianten der Fehler bei Parsern</li> <li>(K2) Fehlerbehandlung bei LL-Parsern: <em>single token deletion</em>, <em>single token insertion</em>, <em>sync-and-return</em></li> <li>(K2) Berechnung und Anwendung des <em>Resynchronization Sets</em></li> <li>(K3) Ändern der Fehlermeldungen bei ANTLR</li> <li>(K3) Eigene Errorhandler in ANTLR-Parser bauen und einbinden</li> <li>(K3) Nutzen von speziellen Fehler-Alternativen in Grammatiken</li></ul></div>
</div>




    <h2 id="fehler-beim-parsen">Fehler beim Parsen</h2>
<p><a href="#R-image-90d978e2402caae0e611096874d121bb" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/bc_xml-parsing-error.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-90d978e2402caae0e611096874d121bb"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/bc_xml-parsing-error.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p><span class='origin'>Quelle: Vorlesung &quot;Einführung in die Programmierung mit Skriptsprachen&quot; by <a href="mailto:bc.george@hsbi.de">BC George</a> (<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC BY-SA 4.0</a>)</span></p>
<ul>
<li>Compiler ist ein schnelles Mittel zum Finden von (syntaktischen) Fehlern</li>
<li>Wichtige Eigenschaften:
<ul>
<li>Reproduzierbare Ergebnisse</li>
<li>Aussagekräftige Fehlermeldungen</li>
<li>Nach Erkennen eines Fehlers: (vorläufige) Korrektur und Parsen des restlichen Codes
=&gt; weitere Fehler anzeigen.
Problem: Bis wohin &quot;gobbeln&quot;, d.h. was als Synchronisationspunkt nehmen? Semikolon?</li>
<li>Syntaktisch fehlerhafte Programme dürfen nicht in die Zielsprache übersetzt werden!</li>
</ul>
</li>
</ul>
<h2 id="typische-fehler-beim-parsing">Typische Fehler beim Parsing</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span><span style="color:#66d9ef">grammar</span> <span style="color:#a6e22e">VarDef</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>alt   : stmt <span style="color:#f92672">|</span> stmt2 ;
</span></span><span style="display:flex;"><span>stmt  : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span> ;
</span></span><span style="display:flex;"><span>stmt2 : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;=&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span>  ;</span></span></code></pre></div><p><em>Anmerkung</em>: Die nachfolgenden Fehler werden am Beispiel der Grammatik
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery.html/src/VarDef.g4">VarDef.g4</a> und ANTLR demonstriert.</p>
<h3 id="lexikalische-fehler">Lexikalische Fehler</h3>
<p>Eingabe: <code>int x1;</code> (Startregel <code>stmt</code>)</p>
<p>Fehlermeldung: <code>token recognition error at: '1'</code></p>
<p>Die ist ein Fehler aus dem Lexer, wenn beim Erkennen eines Tokens ein komplett
unbekanntes Zeichen auftritt.</p>
<h3 id="ein-extra-token">Ein extra Token</h3>
<p>Eingabe: <code>int x y;</code> (Startregel <code>stmt</code>)</p>
<p>Fehlermeldung: <code>extraneous input 'y' expecting ';'</code></p>
<p>Wenn nur ein Token zu viel ist, dann kann der von ANTLR generierte Parser eine
passende Fehlermeldung ausgeben.</p>
<h3 id="mehrere-extra-token">Mehrere extra Token</h3>
<p>Eingabe: <code>int x y z;</code> (Startregel <code>stmt</code>)</p>
<p>Fehlermeldung: <code>mismatched input 'y' expecting ';'</code></p>
<p>Wenn dagegen mehr als ein Token zu viel ist, dann gibt der von ANTLR generierte
Parser eine generische Fehlermeldung aus.</p>
<h3 id="fehlendes-token">Fehlendes Token</h3>
<p>Eingabe: <code>int ;</code> (Startregel <code>stmt</code>)</p>
<p>Fehlermeldung: <code>missing ID at ';'</code></p>
<p>Ein anderer typischer Fehler sind fehlende Token, die kann der Parser analog zu
überzähligen Token erkennen und ausgeben.</p>
<h3 id="fehlendes-token-am-entscheidungspunkt">Fehlendes Token am Entscheidungspunkt</h3>
<p>Eingabe: <code>int ;</code> (Startregel <code>alt</code>)</p>
<p>Fehlermeldung: <code>no viable alternative at input 'int;'</code></p>
<p>Hier fehlt ein Token, aber an einer Stelle, wo sich der Parser zwischen zwei
Alternativen (Sub-Regeln) entscheiden muss.</p>
<h2 id="überblick-recovery-bei-parser-fehlern">Überblick Recovery bei Parser-Fehlern</h2>
<p><a href="#R-image-c7112418d2031833991c09dd1b1fca67" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/recovery.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c7112418d2031833991c09dd1b1fca67"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/recovery.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<ul>
<li>Fehler im Lexer (hier nicht weiter betrachtet):
<ul>
<li>Aktuelles Zeichen passt zu keinem Token: Entfernen oder Hinzufügen
von Zeichen (plus Rückmeldung an den Parser)</li>
<li>Spezielle Token, die typische fehlerhafte Zeichenketten als Token
erkennen (mit Weiterverarbeitung im Parser)</li>
</ul>
</li>
<li>Fehler im Parser:
<ul>
<li>Token passt nicht: Token entfernen oder ein Dummy-Token erzeugen</li>
<li>Panic-Mode: Entferne Token bis zu einem Synchronisationspunkt.
Problem: Dabei nicht zu weit zu springen!</li>
<li>Spezielle Fehlerproduktionen: Spezielle Regeln in der Grammatik,
die typische Fehler matchen.</li>
</ul>
</li>
</ul>
<p>Anmerkung LR-Parser: Ein Syntaxfehler wird entdeckt, wenn die Action-Tabelle
für Top-of-Stack und akt. Token leer ist =&gt; Stack und/oder Token modifizieren,
aber deutlich schwieriger als bei LL ...</p>
<h2 id="skizze-generierte-parser-regeln-antlr">Skizze: Generierte Parser-Regeln (ANTLR)</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt  : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span> ;</span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">stmt</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>: <span style="color:#66d9ef">match</span>(<span style="color:#e6db74">&#34;int&#34;</span>); <span style="color:#66d9ef">match</span>(ID); <span style="color:#66d9ef">match</span>(<span style="color:#e6db74">&#34;;&#34;</span>)
</span></span><span style="display:flex;"><span>    catch (RecognitionException re):
</span></span><span style="display:flex;"><span>        _errHandler<span style="color:#f92672">.</span>reportError(self)               <span style="color:#75715e"># let&#39;s report it</span>
</span></span><span style="display:flex;"><span>        _errHandler<span style="color:#f92672">.</span>recover(self)                   <span style="color:#75715e"># Panic-Mode</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">match</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> lookahead <span style="color:#f92672">==</span> x: consume()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: _errHandler<span style="color:#f92672">.</span>recoverInline(self)           <span style="color:#75715e"># Inline-Mode</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Der im Parser registrierte ErrorHandler erzeugt in der Methode
<code>reportError()</code> eine geeignete Meldung und gibt sie an den Parser
über dessen Methode <code>notifyErrorListeners()</code> weiter.</p>
<p>Die eigentliche Fehlerbehandlung findet in der Methode <code>recover()</code>
bzw. <code>recoverInline()</code> des ErrorHandlers statt.</p>
<h2 id="inline-recovery-bei-token-mismatch-skizze">Inline-Recovery bei Token-Mismatch (Skizze)</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">recoverInline</span>(parser):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># SINGLE TOKEN DELETION</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> singleTokenDeletion(parser):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> getMatchedSymbol(parser)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># SINGLE TOKEN INSERTION</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> singleTokenInsertion(parser):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> getMissingSymbol(parser)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># that didn&#39;t work, throw a new exception</span>
</span></span><span style="display:flex;"><span>    throw new InputMismatchException(parser)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Die Klasse <code>InputMismatchException</code> drückt aus, dass das aktuelle Token nicht
zur Erwartung des Parsers passt. Deshalb wird diese Exception am Ende von
<code>recoverInline()</code> geworfen. Die Klasse <code>RecognitionException</code>, die in den
Parserregeln wie <code>stmt</code> gefangen wird, ist die gemeinsame Oberklasse aller
Parser-Exceptions.</p>
<p>Liste der wichtigsten Exceptions (nach
<a href="https://github.com/antlr/antlr4/blob/master/doc/parser-rules.md" target="_blank">github.com/antlr/antlr4/blob/master/doc/parser-rules.md</a>):</p>
<table>
<thead>
<tr>
<th style="text-align:left">Exception</th>
<th style="text-align:left">Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>RecognitionException</code></td>
<td style="text-align:left">Basisklasse für alle Parser-Exceptions</td>
</tr>
<tr>
<td style="text-align:left"><code>NoViableAltException</code></td>
<td style="text-align:left">Parser konnte sich nicht für (mind.) einen Pfad entscheiden angesichts des Tokenstroms</td>
</tr>
<tr>
<td style="text-align:left"><code>LexerNoViableAltException</code></td>
<td style="text-align:left">Lexer-Pendant zu <code>NoViableAltException</code></td>
</tr>
<tr>
<td style="text-align:left"><code>InputMismatchException</code></td>
<td style="text-align:left">Das aktuelle Token ist nicht das, was der Parser erwartet</td>
</tr>
</tbody>
</table>
<h2 id="panic-mode-sync-and-return-skizze">Panic Mode: Sync-and-Return (Skizze)</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rule</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>: <span style="color:#f92672">...</span> rule<span style="color:#f92672">-</span>body <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    catch (RecognitionException re):
</span></span><span style="display:flex;"><span>        _errHandler<span style="color:#f92672">.</span>reportError(self)       <span style="color:#75715e"># let&#39;s report it</span>
</span></span><span style="display:flex;"><span>        _errHandler<span style="color:#f92672">.</span>recover(self)           <span style="color:#75715e"># Panic-Mode</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>=&gt; Entferne solange Token, bis aktuelles Token im &quot;<em>Resynchronization Set</em>&quot;</p>
<h2 id="antlr-einsatz-des-resynchronization-set">ANTLR: Einsatz des &quot;<em>Resynchronization Set</em>&quot;</h2>
<ul>
<li><strong>Following Set</strong>: Menge der Token, die direkt auf eine Regel-Referenz folgen,
ohne dass die aktuelle Regel/Alternative verlassen wird</li>
<li><strong>Resynchronization Set</strong>: Vereinigung der <em>Following Sets</em> für alle Regeln im
aktuellen Aufruf-Stack</li>
</ul>
<p><span class='origin'>Quelle: nach <a href="#id_Parr2014">[Parr2014, pp. 161-163]</a></span></p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt : <span style="color:#e6db74">&#39;if&#39;</span> expr <span style="color:#e6db74">&#39;:&#39;</span> stmt           <span style="color:#75715e">// Following Set für &#34;expr&#34;: {&#39;:&#39;}</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;while&#39;</span> <span style="color:#e6db74">&#39;(&#39;</span> expr <span style="color:#e6db74">&#39;)&#39;</span> stmt ;  <span style="color:#75715e">// Following Set für &#34;expr&#34;: {&#39;)&#39;}</span>
</span></span><span style="display:flex;"><span>expr : term <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#66d9ef">INT</span> ;               <span style="color:#75715e">// Following Set für &#34;term&#34;: {&#39;+&#39;}</span></span></span></code></pre></div><ul>
<li>Eingabe: <code>if :</code></li>
<li>Aufruf-Stack nach Bearbeitung von <code>if</code>: <code>[stmt, expr, term]</code></li>
<li><strong>Resynchronization Set</strong>: <code>{'+', ':'}</code></li>
</ul>
<h3 id="hinweis-follow-hahahugoshortcode25s0hbhb-following">Hinweis: <em>FOLLOW</em> 
<span class="math align-center">$\ne$</span> <em>Following</em></h3>
<p><strong>FOLLOW</strong> ist die Menge aller Token, die auf eine Regel folgen können</p>
<ul>
<li><code>FOLLOW(term) = {'+'}</code></li>
<li><code>FOLLOW(expr) = {':', ')'}</code></li>
</ul>
<p><strong>Following</strong> ist dagegen <strong>abhängig vom aktuellen Kontext</strong>!</p>
<ul>
<li>Stack: <code>[stmt, expr, term]</code> =&gt; <em>Resynchronization Set</em>: <code>{'+', ':'}</code></li>
</ul>
<h3 id="beispiele-resynchronisation-im-panic-mode-antlr">Beispiele Resynchronisation im Panic Mode (ANTLR)</h3>
<p><strong>Hinweis</strong>: Die Regel <code>term</code> ist in obigem Beispiel nicht weiter detailliert. Hier wird
angenommen, dass das aktuelle Token <code>':'</code> nicht passt.</p>
<ul>
<li>Eingabe: <code>if :</code>
<ul>
<li>In Regel <code>term</code>: Token <code>':'</code> passt nicht
<ul>
<li><code>consume()</code>, bis aktuelles Token in <em>Resynchronization Set</em>: <code>{'+', ':'}</code>
(d.h. hier bleibt <code>':'</code> das aktuelle Token)</li>
<li>Rückkehr zu Regel <code>expr</code></li>
</ul>
</li>
<li>In Regel <code>expr</code>: Token <code>':'</code> passt nicht
<ul>
<li><code>consume()</code>, bis aktuelles Token in <em>Resynchronization Set</em>: <code>{':'}</code>
(d.h. hier bleibt <code>':'</code> das aktuelle Token)</li>
<li>Rückkehr zu Regel <code>stmt</code></li>
</ul>
</li>
<li>In Regel <code>stmt</code>: Token <code>':'</code> passt jetzt
<ul>
<li>Abschluss des Parsing (mit Fehlermeldung)</li>
</ul>
</li>
</ul>
</li>
<li>Eingabe: <code>if x + 42 ))):</code>
<ul>
<li>In Regel <code>stmt</code>: Token <code>')'</code> passt nicht
<ul>
<li><code>consume()</code>, bis aktuelles Token in <em>Resynchronization Set</em>: <code>{':'}</code> (d.h.
hier werden alle <code>')'</code> entfernt)</li>
</ul>
</li>
<li>In Regel <code>stmt</code>: Token <code>':'</code> passt jetzt
<ul>
<li>Abschluss des Parsing (mit Fehlermeldung)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="antlr-anmerkungen-fehlerbehandlung-in-sub-regeln">ANTLR: Anmerkungen Fehlerbehandlung in Sub-Regeln</h2>
<p>Bei Sub-Regeln (d.h. eine Regel enthält Alternativen) oder Schleifenkonstrukten
(d.h. eine Regel enthält <code>(...)*</code> oder <code>(...)+</code>) geht ANTLR etwas anders vor.</p>
<ol>
<li>
<p>Start einer Sub-Regel/Alternative: Versuch einer <em>single token deletion</em></p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># am Anfang einer Alternative oder Schleife</span>
</span></span><span style="display:flex;"><span>_errHandler<span style="color:#f92672">.</span>sync(self)</span></span></code></pre></div></li>
<li>
<p>Schleifenkonstrukte: <code>(...)*</code> oder <code>(...)+</code></p>
<p>Versuche, in der Schleife zu bleiben! Im Fehlerfall <code>consume()</code> bis</p>
<ul>
<li>Weitere Iteration der Schleife erkannt</li>
<li>Token, welches der Schleife folgt, erkannt</li>
<li>Token im <em>Resynchronization Set</em> des aktuellen Aufruf-Stacks</li>
</ul>
<p>Anmerkung: Im Prinzip entspricht dies dem <em>Panic Mode</em>, der Unterschied liegt
darin, bis wohin der Parser nach der Recovery in einer Funktion/Methode (Regel)
zurückspringt. D.h. wenn es verschiedene Möglichkeiten gibt, haben diese die
obige Priorisierung.</p>
</li>
<li>
<p>Fail-Save</p>
<p>Um Endlos-Schleifen durch die Schritte (1) bzw. (2) zu vermeiden, löst der Parser
beim zweiten Versuch, die selbe Parser-Stelle und Input-Position zu bearbeiten
(also bei bereits aktivem Fehler), einen &quot;<em>Fail-Safe</em>&quot; aus. Der Parser konsumiert
dann ein Token und fährt dann mit der Recovery fort.</p>
</li>
</ol>
<p>Zu Details zur Fehlerbehandlung durch ANTLR vergleiche <a href="#id_Parr2014">[Parr2014, S. 170 ff.]</a>.</p>
<h2 id="antlr-ändern-der-fehlerbehandlungs-strategie">ANTLR: Ändern der Fehlerbehandlungs-Strategie</h2>
<h3 id="ändern-der-fehlerbehandlungs-strategie-global">Ändern der Fehlerbehandlungs-Strategie (global)</h3>
<p><a href="#R-image-97eb931b5339c2b19b91d5ed721a6537" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/handler.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-97eb931b5339c2b19b91d5ed721a6537"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/handler.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Sie überschreiben die Klasse <code>DefaultErrorStrategy</code> und müssen die oben gezeigten Methoden
<code>recover()</code> und <code>recoverInline()</code>aufrufen. Die eigene Fehlerbehandlung setzen Sie über die
Methode <code>setErrorHandler</code> des Parsers.</p>
<h3 id="ändern-der-fehlerbehandlungs-strategie-lokal">Ändern der Fehlerbehandlungs-Strategie (lokal)</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>r : <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>  ;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">catch</span>[RecognitionException e] { throw e; }</span></span></code></pre></div><p>Es lassen sich auch andere bzw. mehrere Exceptions fangen. Der <code>catch</code>-Block ersetzt den
Default-<code>catch</code>-Block der generierten Methode. Das bedeutet, dass sich der geänderte Modus
nur für die eine Regel auswirkt.</p>
<h3 id="ändern-der-fehler-meldungen">Ändern der Fehler-Meldungen</h3>
<p><a href="#R-image-56aaad48c95fea35d49326363d96d71f" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/listener.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-56aaad48c95fea35d49326363d96d71f"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/parsing/recovery/listener.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p>Für einen eigenen Listener leitet man sinnvollerweise von <code>BaseErrorListener</code> ab und
überschreibt die leere Implementierung von <code>syntaxError()</code>.</p>
<p>Damit die Fehlermeldungen nicht mehrfach ausgegeben werden, entfernt man zunächst alle
Listener und fügt dann den eigenen hinzu, bevor man den Parser startet.</p>
<h2 id="panic-mode-in-bison-error-recovery">Panic Mode in Bison (Error Recovery)</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span>     { printf(&#34;%s\n&#34;, <span style="color:#960050;background-color:#1e0010">$</span>2); }
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> error <span style="color:#e6db74">&#39;\n&#39;</span>       { yyerror(); yyerrok; }
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p>Bison kennt ein spezielles Fehler-Token <code>error</code>. Dieses Token wird genutzt, um
einen Synchronisationspunkt in der Grammatik zu definieren, von dem aus man
<em>höchstwahrscheinlich</em> weiter parsen kann.</p>
<h3 id="parsen-mit-error-token">Parsen mit <em>error</em>-Token</h3>
<p>Der Parser wird mit diesen Produktionen generiert wie mit normalen Token auch.
Im Fehlerfall werden so lange Symbole vom Stack entfernt, bis eine Regel der
Form 
<span class="math align-center">$A \to \operatorname{error} \alpha$</span> anwendbar ist. Dann wird das Token
<code>error</code> auf den Stack geschoben und so lange Eingabe-Token gelesen und verworfen,
bis eines gefunden wird, welches auf das <code>error</code>-Token folgen kann. Dies nennt
Bison &quot;Resynchronisation&quot;. Anschließend wird im Recovery-Modus normal fortgefahren,
bis drei weitere Token auf den Stack geschoben wurden und damit der Recovery-Modus
verlassen wird. Falls bereits vorher weitere Fehler auftreten, werden diese nicht
separat gemeldet.</p>
<h3 id="anwendung-im-obigen-beispiel">Anwendung im obigen Beispiel</h3>
<p>Im obigen Beispiel ist die Regel <code>stmt : error '\n'</code> enthalten. Im Fehlerfall
werden die Symbole vom Stack entfernt, bis ein Zustand erreicht ist, der eine
Shift-Aktion auf das Token <code>error</code> hat. Das Error-Token wird auf den Stack
geschoben und alle Eingabetoken bis zum nächsten <code>'\n'</code> gelesen und direkt
entfernt. Mit dem Erreichen des Zeilenumbruchs wird die zugeordnete Aktion
ausgeführt. Diese gibt den Fehler auf der Konsole aus und führt mit dem Makro
<code>yyerrok</code> einen Reset des Parsers aus (d.h. er verlässt den Recovery-Modus
<strong>vor</strong> dem Shiften der per Default drei gültigen Token). Anschließend ist der
Bison-Parser wieder im normalen Modus. Die fehlerhaften Symbole/Token wurden
aus dem Eingabestrom entfernt.</p>
<h3 id="wo-kommen-die-error-token-am-besten-hin">Wo kommen die <em>error</em>-Token am besten hin?</h3>
<p>Die &quot;schwarze Kunst&quot; ist, die Error-Token an geeigneten Stellen unterzubringen,
d.h. vorherzusehen, wo der Parser am sinnvollsten wieder aufsetzen kann. Häufig
sind dies beispielsweise das ein Statement beendende Semikolon oder die einen
Block beendende schließende geschweifte Klammer. Beispielsweise könnte man für
die Sprache C bei der Definition von Statements mehrere Synchronisationspunkte
einbauen:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt : <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> error <span style="color:#e6db74">&#39;;&#39;</span>    <span style="color:#75715e">/* Synchronisation für &#39;return&#39; */</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> error <span style="color:#e6db74">&#39;}&#39;</span>    <span style="color:#75715e">/* Synchronisation nach Block */</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> error <span style="color:#e6db74">&#39;\n&#39;</span>   <span style="color:#75715e">/* Synchronisation nach Zeilenumbruch */</span>
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><h3 id="bison-und-c-und-speichermanagement-im-fehlerfall">Bison und C und Speichermanagement im Fehlerfall</h3>
<p>Wenn Bison im Recovery-Modus ist, werden Symbole und ihre Werte vom Stack entfernt.
Falls diese Werte (vgl. <code>%union</code>) Pointer mit dynamisch alloziertem Speicher sind,
muss Bison diesen Speicher freigeben.</p>
<p>Dazu kann man sich über die Direktive <code>%destructor { code } symbols</code> oder
<code>%destructor { code } &lt;types&gt;</code> Code definieren, der dann für die jeweiligen Symbole
oder Typen ausgeführt wird.</p>
<p>Die Typangabe <code>&lt;*&gt;</code> dient dabei als Catch-All für Symbole, für die ein Typ definiert
wurde, aber kein Destruktor.</p>
<p>Beispiel:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">%</span>union {
</span></span><span style="display:flex;"><span>    char* str;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">%token</span> <span style="color:#960050;background-color:#1e0010">&lt;str&gt;</span> <span style="color:#960050;background-color:#1e0010">ID</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">%destructor</span> { free(<span style="color:#960050;background-color:#1e0010">$$</span>); } <span style="color:#960050;background-color:#1e0010">&lt;str&gt;</span></span></span></code></pre></div><p>Für weitere Details vergleiche <a href="#id_Levine2009">[Levine2009, Kap. 8]</a>.</p>
<h2 id="fehlerproduktionen">Fehlerproduktionen</h2>
<p>Häufig vorkommende Fehler kann man bereits in der Grammatik berücksichtigen.
Dadurch kommt es nicht zu einem Parser-Error mit Recovery-Mechanismus, sondern
der Fehler wird über eine entsprechende Alternative in der Grammatik korrigiert.</p>
<p>Es bietet sich an, in diesem Fall eine entsprechende Ausgabe zu tätigen. Dies
wird in der folgenden Grammatik über eingebettete Aktionen erledigt.</p>
<h3 id="antlr">ANTLR</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span>
</span></span><span style="display:flex;"><span>     : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span>             {notifyErrorListeners(&#34;Missing &#39;;&#39;&#34;);}
</span></span><span style="display:flex;"><span>     : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span> <span style="color:#e6db74">&#39;;&#39;</span>     {notifyErrorListeners(&#34;Too many &#39;;&#39;&#34;);}
</span></span><span style="display:flex;"><span>     ;</span></span></code></pre></div><p>Der aus der Grammatik generierte Parser leitet von der Basisklasse <code>Parser</code>
ab. Dort wird eine Methode <code>notifyErrorListeners()</code> implementiert, die man
mit Hilfe von in die Grammatik eingebetteten Aktionen aufrufen kann (Vorgriff
auf <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/syntaxdriven.html">Syntaxgesteuerte Interpreter</a>).
Letztlich steht im generierten Parser in der generierten Methode <code>stmt()</code> an
der passenden Stelle ein Aufruf <code>notifyErrorListeners(Too many ';'&quot;);</code> ...</p>
<h3 id="flex-und-bison">Flex und Bison</h3>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stmt : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span>     { <span style="color:#960050;background-color:#1e0010">$$</span> = <span style="color:#960050;background-color:#1e0010">$</span>2; }
</span></span><span style="display:flex;"><span>     : <span style="color:#e6db74">&#39;int&#39;</span> <span style="color:#66d9ef">ID</span>         { yyerror(&#34;unterminated id&#34;);
</span></span><span style="display:flex;"><span>                          <span style="color:#960050;background-color:#1e0010">$$</span> = <span style="color:#960050;background-color:#1e0010">$</span>2; }
</span></span><span style="display:flex;"><span>     ;
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">%%</span>
</span></span><span style="display:flex;"><span>void <span style="color:#960050;background-color:#1e0010">yyerror(char</span> <span style="color:#960050;background-color:#1e0010">*s,</span> <span style="color:#960050;background-color:#1e0010">...)</span> {
</span></span><span style="display:flex;"><span>    va_list ap; va_start(ap, s);
</span></span><span style="display:flex;"><span>    fprintf(stderr, &#34;%d: error: &#34;, yylineno);
</span></span><span style="display:flex;"><span>    vfprintf(stderr, s, ap); fprintf(stderr, &#34;\n&#34;);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Analog zu ANTLR ist es auch in Flex/Bison üblich, für typische Szenarien
&quot;nicht ganz korrekte&quot; Eingaben zu akzeptieren. Dazu definiert man zusätzliche
Lexer- oder Parser-Regeln, die diese Eingaben als das, was gemeint war akzeptieren
und eine zusätzliche Warnung ausgeben.</p>
<p>Dabei definiert man sich typischerweise die Funktion <code>yyerror()</code>. Über
<code>yytext</code> hat man Zugriff auf den Eingabetext des aktuellen Tokens, und
mit <code>yylineno</code> hat man Zugriff auf die aktuelle Eingabezeile (<code>yylineno</code>
wird automatisch bei jedem <code>\n</code> inkrementiert). Wenn man weitere Informationen
benötigt, muss man mit dem Bison-Feature &quot;Locations&quot; arbeiten. Dies ist ein
spezieller Datentyp <code>YYLTYPE</code>.</p>
<p>Für weitere Details vergleiche <a href="#id_Levine2009">[Levine2009, Kap. 8]</a>.</p>
<h2 id="anmerkung-nicht-eindeutige-grammatiken">Anmerkung: Nicht eindeutige Grammatiken</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-antlr" data-lang="antlr"><span style="display:flex;"><span>stat: expr <span style="color:#e6db74">&#39;;&#39;</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;;&#39;</span> ;
</span></span><span style="display:flex;"><span>expr: <span style="color:#66d9ef">ID</span> <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#66d9ef">ID</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">INT</span> ;</span></span></code></pre></div><p>=&gt; Was passiert bei der Eingabe: <code>a+b</code> ??! Welche Regel/Alternative soll
jetzt matchen, d.h. welcher AST soll am Ende erzeugt werden?!</p>
<h3 id="antlr-1">ANTLR</h3>
<p>Nicht eindeutige Grammatiken führen <strong>nicht</strong> zu einer Fehlermeldung,
da nicht der Nutzer mit seiner Eingabe Schuld ist, sondern das Problem
in der Grammatik selbst steckt.</p>
<p>Während des Debuggings von Grammatiken lohnt es sich aber, diese
Warnungen zu aktivieren. Dies kann entweder mit der Option &quot;<code>-diagnostics</code>&quot;
beim Aufruf des <code>grun</code>-Tools geschehen oder über das Setzen des
<code>DiagnosticErrorListener</code> aus der ANTLR-Runtime als ErrorListener.</p>
<h3 id="bison">Bison</h3>
<p>Bison meldet nicht eindeutige Grammatiken beim Erzeugen des Parsers
(vgl. Shift/Reduce- und Reduce/Reduce-Konflikte) und entscheidet sich
jeweils für eine Operation (wobei Shift bevorzugt wird). Dies kann
man im über die Option <code>-v</code> erzeugten <code>&lt;name&gt;.output</code>-File überprüfen.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Fehler bei <code>match()</code>: <em>single token deletion</em> oder <em>single token insertion</em></p>
</li>
<li>
<p>Panic Mode: <em>sync-and-return</em> bis Token in <em>Resynchronization Set</em> (ANTLR)
oder <code>error</code>-Token shiftbar (Bison)</p>
<ul>
<li>ANTLR: Sonderbehandlung bei Start von Sub-Regeln und in Schleifen</li>
<li>ANTLR: Fail-Save zur Vermeidung von Endlosschleifen</li>
</ul>
</li>
<li>
<p>Fehler-Alternativen in Grammatik einbauen</p>
</li>
</ul>


    



    



    

    
<div class="box notices cstyle note">
  <div class="box-label"><i class="fas fa-puzzle-piece"></i> Challenges</div>
  <div class="box-content">

<ul>
<li>Erklären Sie, welche Fehler typischerweise beim Parsen auftreten können.</li>
<li>Wie reagiert der von ANTLR generierte LL-Parser auf typische Fehler?</li>
<li>Was sind &quot;Fehlerproduktionen&quot;, wozu sind sie gut?</li>
</ul>
</div>
</div>



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Levine2009'>[Levine2009] <strong>flex & bison</strong><br>Levine, J., O'Reilly, 2009. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-5961-5597-1' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-5961-5597-1</a>.<br><em>Kapitel 7 und 8</em></li> <li id='id_Parr2010'>[Parr2010] <strong>Language Implementation Patterns</strong><br>Parr, T., Pragmatic Bookshelf, 2010. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5645-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5645-6</a>.<br><em>Kapitel 2 und 3</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.</li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

          </section>
          <article class="default">
            <header class="headline">
            </header>
<h1 id="semantische-analyse">Semantische Analyse</h1>

<p>Auf die lexikalische Analyse und die Syntaxanalyse folgt die semantische Analyse. Nach dem
Parsen steht fest, dass ein Programm syntaktisch korrekt ist. Nun muss geprüft werden, ob
es auch semantisch korrekt ist.</p>

<ul class="children children-li children-sort-">
	
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables.html">Symboltabellen</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/attribgrammars.html">Typen, Type Checking und Attributierte Grammatiken</a></li>
</ul>

            <footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Semantische Analyse</h1>
          <article class="default">
            <header class="headline">
            </header>
<h1 id="symboltabellen">Symboltabellen</h1>

<p>Zur semantischen Analyse gehört die Identifikation und Sammlung von Bezeichnern und die
Zuordnung zur richtigen Ebene (Scopes). Das Werkzeug hierfür sind die Symboltabellen.</p>
<p><a href="#R-image-274f600db011aa677b82bc13ba9b96df" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/architektur_cb.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-274f600db011aa677b82bc13ba9b96df"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/architektur_cb.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>

<ul class="children children-li children-sort-">
	
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/intro-symbtab.html">Semantische Analyse: Symboltabellen</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/scopes.html">Nested Scopes</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/functions.html">Funktionen</a></li>
<li><a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/classes.html">Strukturen und Klassen</a></li>
</ul>

            <footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Symboltabellen</h1>
<article class="default">
<h1>Semantische Analyse: Symboltabellen</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>Auf die lexikalische Analyse und die Syntaxanalyse folgt die semantische Analyse. Nach dem
Parsen steht fest, dass ein Programm syntaktisch korrekt ist. Nun muss geprüft werden, ob
es auch semantisch korrekt ist. Dies umfasst in der Regel die Identifikation und Sammlung
von Bezeichnern und die Zuordnung zur richtigen Ebene (Scopes). Außerdem muss die Nutzung
von Symbolen validiert werden: Je nach Sprache müssen beispielsweise Variablen und Funktionen
vor ihrer Benutzung zumindest deklariert sein; Funktionen sollten sich nicht wie Variablen
benutzen lassen, ...</p>
<p>Als Werkzeug werden (hierarchische) Tabellen eingesetzt, um die verschiedenen Symbole und
Informationen darüber zu verwalten. Dabei werden die Symboltabelleneinträge oft an verschiedenen
Stellen im Compiler generiert und benutzt.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/5637iNH0wWk' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Symboltabellen (Intro)</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/af37ca12a1e720f50544efd742b34a297da3e96b74904cb521e51cf42138b083510c8e4456377c945a6e9def30c039b207d572b8dae163b02f8509c137eb6446' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Symboltabellen (Intro)</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K2) Aufgaben der semantischen Analyse</li> <li>(K2) Bedeutung von Symboltabellen: Aufgaben, Verbindung zu Compiler-Phasen</li></ul></div>
</div>




    <h2 id="was-passiert-nach-der-syntaxanalyse">Was passiert nach der Syntaxanalyse?</h2>
<div class='columns'>
<div class='column'>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> y<span style="color:#f92672">+</span>x;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#a6e22e">f</span>(x);</span></span></code></pre></div></div>
<div class='column'>
<p><a href="#R-image-89521b14e7606c26f072ad612ec033a1" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/intro-symbtab/parsetree.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-89521b14e7606c26f072ad612ec033a1"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/intro-symbtab/parsetree.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
</div>
</div>
<p>Nach der Syntaxanalyse braucht der Compiler für die darauf folgenden Phasen
<strong>semantische Analyse</strong>, Optimierung und Codegenerierung <strong>Informationen
über Bezeichner</strong>, z.B.</p>
<ul>
<li>Welcher Bezeichner ist gemeint?</li>
<li>Welchen Typ hat ein Bezeichner?</li>
</ul>
<p>Auf dem Weg zum Interpreter/Compiler müssen die Symbole im AST korrekt zugeordnet
werden. Dies geschieht über Symboltabellen. Im Folgenden werden wir verschiedene
Aspekte von Symboltabellen betrachten und eine mögliche Implementierung erarbeiten,
bevor wir uns (in <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/backend/interpretation/syntaxdriven.html">Interpreter</a>)
um die Auswertung (Interpretation) des AST kümmern können.</p>
<h3 id="logische-compilierungsphasen">Logische Compilierungsphasen</h3>
<ul>
<li>
<p>Die lexikalische Analyse generiert eine Folge von Token.</p>
</li>
<li>
<p>Die Syntaxanalyse generiert einen Parse Tree.</p>
</li>
<li>
<p>Die semantische Analyse macht folgendes:</p>
<ul>
<li>Der Parse Tree wird in einen abstrakten Syntaxbaum (AST) umgewandelt.</li>
<li>Dieser wird häufig mit Attributen annotiert.</li>
<li>Dabei sind oft mehrere Baumdurchläufe nötig (z.B. wegen der Abhängigkeiten
der Attribute).</li>
</ul>
</li>
<li>
<p>Nachfolgende Stufen:</p>
<ul>
<li>Der AST wird in einen Zwischencode umgewandelt mit Registern und virtuellen
Adressen.</li>
<li>Der Zwischencode wird optimiert.</li>
<li>Aus dem optimierten Zwischencode wird der endgültige Code, aber immer noch
mit virtuellen Adressen, generiert.</li>
<li>Der generierte Code wird nachoptimiert.</li>
<li>Der Linker ersetzt die virtuellen Adressen durch reale Adressen.</li>
</ul>
</li>
</ul>
<h3 id="abgrenzung-der-phasen">Abgrenzung der Phasen</h3>
<p>Diese Phasen sind oft nicht klar unterscheidbar. Schon allein zur Verbesserung der
Laufzeit baut der Parser oft schon den abstrakten Syntaxbaum auf, der Lexer trägt schon
Bezeichner in Symboltabellen ein, der Parser berechnet beim Baumaufbau schon Attribute,
...</p>
<p>Oft werden gar nicht alle Phasen und alle Zwischendarstellungen benötigt.</p>
<h2 id="semantische-analyse-und-symboltabellen">Semantische Analyse und Symboltabellen</h2>
<p><a href="#R-image-ba9cfd7df76c27ea0df9415f946ee12f" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/intro-symbtab/architektur_cb.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ba9cfd7df76c27ea0df9415f946ee12f"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/intro-symbtab/architektur_cb.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<h2 id="syntax-und-semantik">Syntax und Semantik</h2>
<ul>
<li>
<p><strong>Syntaxregeln</strong>: Formaler Aufbau eines Programms</p>
</li>
<li>
<p><strong>Semantik</strong>: Bedeutung eines (syntaktisch korrekten) Programms</p>
</li>
</ul>
<p>=&gt; Keine Codegenerierung für syntaktisch/semantisch inkorrekte Programme!</p>
<p>Zur Erinnerung: Die <em>Syntaxregeln</em> einer Programmiersprache bestimmen den formalen
Aufbau eines zu übersetzenden Programms. Die <em>Semantik</em> gibt die Bedeutung eines
syntaktisch richtigen Programms an.</p>
<p>Lexikalische und syntaktische Analyse können formalisiert mit regulären Ausdrücken und
endlichen Automaten, sowie mit CFG und Parsern durchgeführt werden.</p>
<p>Die Durchführung der semantischen Analyse ist stark von den Eigenschaften der zu
übersetzenden Sprache, sowie der Zielsprache abhängig und kann hier nur beispielhaft
für einige Eigenschaften erklärt werden.</p>
<p>Es darf kein lauffähiges Programm erstellt werden können, dass nicht syntaktisch und
semantisch korrekt ist. Ein lauffähiges Programm muss syntaktisch und semantisch korrekt
sein!</p>
<h2 id="aufgaben-der-semantischen-analyse">Aufgaben der semantischen Analyse</h2>
<ul>
<li>
<p>Identifikation und Sammlung der Bezeichner</p>
</li>
<li>
<p>Zuordnung zur richtigen Ebene (Scopes)</p>
</li>
<li>
<p>Typ-Inferenz</p>
</li>
<li>
<p>Typkonsistenz (Ausdrücke, Funktionsaufrufe, ...)</p>
</li>
<li>
<p>Validieren der Nutzung von Symbolen</p>
<ul>
<li>Vermeidung von Mehrfachdefinition</li>
<li>Zugriff auf nicht definierte Bezeichner</li>
<li>(Lesender) Zugriff auf nicht initialisierte Bezeichner</li>
<li>Funktionen werden nicht als Variablen genutzt</li>
<li>...</li>
</ul>
</li>
</ul>
<p>Die semantische Analyse überprüft die Gültigkeit eines syntaktisch korrekten Programms
bzgl. statischer semantischer Eigenschaften und liefert die Grundlage für die (Zwischen-)
Codeerzeugung und -optimierung. Insbesondere wird hier die Typkonsistenz (in Ausdrücken,
von Parametern, ...) überprüft, und implizite Typumwandlungen werden vorgenommen. Oft
müssen Typen automatisch bestimmt werden (z.B. bei Polymorphie, Typinferenz). Damit
Typen bestimmt oder angepasst werden können, müssen Bezeichner zunächst identifiziert
werden, d.h. bei namensgleichen Bezeichnern der richtige Bezug bestimmt werden.</p>
<p>Zu Annotationen/Attributen, Typen und Type-Checks siehe VL
<a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/attribgrammars.html">Typprüfungen, Attributgrammatiken</a></p>
<p>=&gt; Ein wichtiges Hilfsmittel dazu sind <strong>Symboltabellen</strong></p>
<h3 id="identifizierung-von-objekten">Identifizierung von Objekten</h3>
<p>Beim Compiliervorgang müssen Namen immer wieder den dazugehörigen Definitionen
zugeordnet, ihre Eigenschaften gesammelt und geprüft und darauf zugegriffen werden.
Symboltabellen werden im Compiler fast überall gebraucht (siehe Abbildung unter
&quot;Einordnung&quot;).</p>
<p>Welche Informationen zu einem Bezeichner gespeichert und ermittelt werden, ist dann
abhängig von der Klasse des Bezeichners.</p>
<h3 id="validieren-der-nutzung-von-symbolen">Validieren der Nutzung von Symbolen</h3>
<p>Hier sind unendlich viele Möglichkeiten denkbar. Dies reicht von den unten aufgeführten
Basisprüfungen bis hin zum Prüfen der Typkompatibilität bei arithmetischen Operationen.
Dabei müssen für alle Ausdrücke die Ergebnistypen berechnet werden und ggf. automatische
Konvertierungen vorgenommen werden, etwa bei <code>3+4.1</code> ...</p>
<ul>
<li>Zugriff auf Variablen: Müssen sichtbar sein</li>
<li>Zugriff auf Funktionen: Vorwärtsreferenzen sind OK</li>
<li>Variablen werden nicht als Funktionen genutzt</li>
<li>Funktionen werden nicht als Variablen genutzt</li>
</ul>
<p>=&gt; Verweis auf VL <a href="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/attribgrammars.html">Typprüfungen, Attributgrammatiken</a></p>
<p>Da Funktionen bereits vor dem Bekanntmachen der Definition aufgerufen werden dürfen, bietet
sich ein <strong>zweimaliger Durchlauf</strong> (<em>pass</em>) an: Beim ersten Traversieren des AST werden alle
Definitionen in der Symboltabelle gesammelt. Beim zweiten Durchlauf werden dann die Referenzen
aufgelöst.</p>
<h3 id="das-mittel-der-wahl-tabellen-für-die-symbole--bezeichner">Das Mittel der Wahl: Tabellen für die Symbole (= Bezeichner)</h3>
<p><strong>Def.:</strong> <em>Symboltabellen</em> sind die zentrale Datenstruktur zur Identifizierung und
Verwaltung von bezeichneten Elementen.</p>
<p>Die Organisation der Symboltabellen ist stark anwendungsabhängig. Je nach Sprachkonzept
gibt es eine oder mehrere Symboltabellen, deren Einträge vom Lexer oder Parser angelegt
werden. Die jeweiligen Inhalte jedes einzelnen Eintrags kommen aus den verschiedenen
Phasen der Compilierung. Symboltabellen werden oft als Hashtables oder auch als Bäume
implementiert, manchmal als verkettete Listen. In seltenen Fällen kommt man auch mit
einem Stack aus.</p>
<p>Eine Symboltabelle enthält benutzerdefinierte Bezeichner (oder Verweise in eine Hashtable
mit allen vorkommenden Namen), manchmal auch die Schlüsselwörter der Programmiersprache.
Die einzelnen Felder eines Eintrags variieren stark, abhängig vom Typ des Bezeichners
(= Bezeichnerklasse).</p>
<p>Manchmal gibt es für Datentypen eine Extra-Tabelle, ebenso eine für die Werte von Konstanten.</p>
<p>Manchmal werden die Namen selbst in eine (Hash-) Tabelle geschrieben. Die Symboltabelle
enthält dann statt der Namen Verweise in diese (Hash-) Tabelle.</p>
<h2 id="einfache-verwaltung-von-variablen-primitiven-typs">Einfache Verwaltung von Variablen primitiven Typs</h2>
<div class='columns'>
<div class='column'>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    x<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></div>
<div class='column'>
<p><a href="#R-image-7e7946b0c793d7b0b01bb32942206967" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/intro-symbtab/simpletable.png?width=20%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 20%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7e7946b0c793d7b0b01bb32942206967"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/intro-symbtab/simpletable.png?width=20%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
</div>
</div>
<p><strong>Bsp.:</strong> Die zu übersetzende Sprache hat nur einen (den globalen) Scope und kennt nur
Bezeichner für Variablen.</p>
<ul>
<li><strong>Eine</strong> Symboltabelle für <strong>alle</strong> Bezeichner</li>
<li>Jeder Bezeichner ist der Name einer Variablen</li>
<li>Symboltabelle wird evtl. mit Einträgen aller Schlüsselwörter initialisiert -- warum?</li>
<li>Scanner erkennt Bezeichner und sucht ihn in der Symboltabelle</li>
<li>Ist der Bezeichner nicht vorhanden, wird ein (bis auf den Namen leerer) Eintrag angelegt</li>
<li>Scanner übergibt dem Parser das erkannte Token und einen Verweis auf den
Symboltabelleneintrag</li>
</ul>
<p>Die Symboltabelle könnte hier eine (Hash-) Tabelle oder eine einfache verkettete Liste sein.</p>
<h2 id="was-kann-jetzt-weiter-passieren">Was kann jetzt weiter passieren?</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    x<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>a <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;</span></span></code></pre></div><p>In vielen Sprachen muss überprüft werden, ob es ein definierendes Vorkommen des Bezeichners oder
ein angewandtes Vorkommen ist.</p>
<h3 id="definitionen-und-deklarationen-von-bezeichnern">Definitionen und Deklarationen von Bezeichnern</h3>
<p><strong>Def.:</strong> Die <em>Definition</em> eines (bisher nicht existenten) Bezeichners in einem Programm
generiert einen neuen Bezeichner und legt für ihn seinem Typ entsprechend Speicherplatz an.</p>
<p><strong>Def.:</strong> Unter der <em>Deklaration</em> eines (bereits existierenden) Bezeichners verstehen wir
seine Bekanntmachung, damit er benutzt werden kann. Er ist oft in einem anderen Scope
definiert und bekommt dort Speicherplatz zugeteilt.</p>
<p>Insbesondere werden auch Typen deklariert. Hier gibt es in der Regel gar keine
Speicherplatzzuweisung.</p>
<p>Ein Bezeichner kann beliebig oft deklariert werden, während er in einem Programm nur einmal
definiert werden kann. Oft wird bei der Deklarationen eines Elements sein Namensraum mit
angegeben.</p>
<p><strong>Vorsicht</strong>: Die Begriffe werden auch anders verwendet. Z.B. findet sich in der
Java-Literatur der Begriff <em>Deklaration</em> anstelle von <em>Definition</em>.</p>
<p><strong>Anmerkung</strong>:
Deklarationen beziehen sich auf Definitionen, die woanders in einer Symboltabelle stehen, evtl.
in einer anderen Datei, also in diesem Compilerlauf nicht zugänglich sind und erst von Linker
aufgelöst werden können. Beim Auftreten einer Deklaration muss die dazugehörige Definition gesucht
werden,und wenn vorhanden, im Symboltabelleneintrag für den deklarierten Bezeichner festgehalten
werden. Hier ist evtl. ein zweiter Baumdurchlauf nötig, um alle offenen Deklarationen, die sich
auf Definitionen in derselben Datei beziehen, aufzulösen.</p>
<p>Wird bei objektorientierten Sprachen ein Objekt definiert, dessen Klassendefinition in einer anderen
Datei liegt, kann man die Definition des Objekts gleichzeitig als Deklaration der Klasse auffassen
(Java).</p>
<h2 id="wo-werden-verweise-in-symboltabellen-gebraucht">Wo werden Verweise in Symboltabellen gebraucht?</h2>
<p>=&gt; Parse Tree und AST enthalten Verweise auf Symboltabelleneinträge</p>
<ul>
<li>Im Parse Tree enthält der Knoten für einen Bezeichner einen Verweis auf den
Symboltabelleneintrag.</li>
<li>Parser und semantische Analyse (AST) vervollständigen die Einträge.</li>
<li>Attribute des AST können Feldern der Symboltabelle entsprechen, bzw. sich aus
ihnen berechnen.</li>
<li>Für Debugging-Zwecke können die Symboltabellen die ganze Compilierung und das
Linken überleben.</li>
</ul>
<h2 id="grenzen-der-semantischen-analyse">Grenzen der semantischen Analyse</h2>
<p><strong>Welche semantischen Eigenschaften einer Sprache kann die semantische Analyse nicht überprüfen?</strong></p>
<ul>
<li>Wer ist dann dafür verantwortlich?</li>
<li>Wie äußert sich das im Fehlerfall?</li>
</ul>
<p>Dinge, die erst durch eine Ausführung/Interpretation eines Programms berechnet werden können.</p>
<p>Beispielsweise können Werte von Ausdrücken oft erst zur Laufzeit bestimmt werden. Insbesondere
kann die semantische Analyse in der Regel nicht feststellen, ob ein Null-Pointer übergeben wird
und anschließend dereferenziert wird.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Semantische Analyse:</p>
<ul>
<li>Identifikation und Sammlung der Bezeichner</li>
<li>Zuordnung zur richtigen Ebene (Scopes)</li>
<li>Validieren der Nutzung von Symbolen</li>
<li>Typ-Inferenz</li>
<li>Typkonsistenz (Ausdrücke, Funktionsaufrufe, ...)</li>
</ul>
</li>
<li>
<p>Symboltabellen: Verwaltung von Symbolen und Typen (Informationen über Bezeichner)</p>
</li>
<li>
<p>Symboltabelleneinträge werden an verschiedenen Stellen des Compilers generiert und benutzt</p>
</li>
</ul>


    



    



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 3</em></li> <li id='id_Parr2010'>[Parr2010] <strong>Language Implementation Patterns</strong><br>Parr, T., Pragmatic Bookshelf, 2010. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5645-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5645-6</a>.<br><em>Kapitel 6, 7 und 8</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.<br><em>Kapitel 6.4 und 8.4</em></li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Nested Scopes</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>In Symboltabellen werden Informationen über Bezeichner verwaltet. Wenn es in der zu
übersetzenden Sprache <em>Nested Scopes</em> gibt, spiegelt sich dies in den Symboltabellen
wider: Auch hier wird eine entsprechende hierarchische Organisation notwendig. In der
Regel nutzt man Tabellen, die untereinander verlinkt sind.</p>
<p>Eine wichtige Aufgabe ist das Binden von Bezeichner gleichen Namens an ihren jeweiligen
Scope =&gt; <code>bind()</code>. Zusätzlich müssen Symboltabellen auch das Abrufen von Bezeichnern
aus dem aktuellen Scope oder den Elternscopes unterstützen =&gt; <code>resolve()</code>.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/CdM1gvsi6P0' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Nested Scopes</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/1ce547df40e91e7a07497e6a070076157868b7d4b1fa18c2f1e17ee5c348e9063582da157de251ae1eb5daff45cfa97efdff7367b4bdd4634da0c00498c876ab' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Nested Scopes</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K3) Aufbau von Symboltabellen für Nested Scopes inkl. Strukturen/Klassen mit einem Listener</li> <li>(K3) Auflösen von Symbolen über die Scopes</li> <li>(K3) Einfache statische Prüfungen anhand der Symboltabellen</li></ul></div>
</div>




    <h2 id="scopes-und-name-spaces">Scopes und Name Spaces</h2>
<p><strong>Def.:</strong> Unter dem <em>Gültigkeitsbereich</em> (Sichtbarkeitsbereich, Scope) eines
Bezeichners versteht man den Programmabschnitt, in dem der Bezeichner sichtbar
und nutzbar ist. Das ist oft der kleinste umgebende Block, außer darin enthaltene
Scopes, die ein eigenes Element dieses Namens benutzen.</p>
<p>Scopes sind fast immer hierarchisch angeordnet.</p>
<p><strong>Def.:</strong> Unter einem <em>Namensraum</em> (name space) versteht man die Menge der zu
einem Zeitpunkt sichtbaren Bezeichner.</p>
<p>Es gibt Sprachen, in denen man eigene Namensräume explizit definieren kann (z.B.
C++).</p>
<p>Vorsicht: Diese Begriffe werden nicht immer gleich definiert und auch gerne
verwechselt.</p>
<h2 id="symbole-und-nested-scopes">Symbole und (nested) Scopes</h2>
<div class='columns'>
<div class='column'>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> y;
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    { <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> x; }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></div>
<div class='column'>
<p><a href="#R-image-2c44ff90b5796a45086f20aaf9c7801a" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/scopes/nestedscopes.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2c44ff90b5796a45086f20aaf9c7801a"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/scopes/nestedscopes.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
</div>
</div>
<p><strong>Aufgaben</strong>:</p>
<ul>
<li><code>bind()</code>: Symbole im Scope definieren</li>
<li><code>resolve()</code>: Symbole aus Scope oder Eltern-Scope abrufen</li>
</ul>
<h3 id="hinzunahme-von-scopes">Hinzunahme von Scopes</h3>
<p><strong>Bsp.:</strong> Die zu übersetzende Sprache ist scope-basiert und kennt nur Bezeichner
für Variablen</p>
<p>Scopes können ineinander verschachtelt sein. Die Spezifikation der zu übersetzenden
Sprache legt fest, in welcher Reihenfolge Scopes zu durchsuchen sind, wenn auf einen
Bezeichner Bezug genommen wird, der nicht im aktuellen Scope definiert ist.</p>
<p>Insgesamt bilden die Scopes oft eine Baumstruktur, wobei jeder Knoten einen Scope
repräsentiert und seine Kinder die direkt in ihm enthaltenen Scopes sind. Dabei ist
es in der Regel so, dass Scopes sich entweder vollständig überlappen oder gar nicht.
Wenn ein Bezeichner nicht im aktuellen Scope vorhanden ist, muss er in der Regel in
umschließenden Scopes gesucht werden. Hier kann ein Stack aller &quot;offenen&quot; Scopes
benutzt werden.</p>
<h3 id="grundlegendes-vorgehen">Grundlegendes Vorgehen</h3>
<p>Das Element, das einen neuen Scope definiert, steht selbst in dem aktuell
behandelten Scope. Wenn dieses Element selbst ein Bezeichner ist, gehört
dieser in den aktuellen Scope. Nur das, was nur innerhalb des oben genannten
Elements oder Bezeichners definiert wird, gehört in den Scope des Elements
oder Bezeichners.</p>
<h2 id="nested-scopes-symbole-und-scopes">Nested Scopes: Symbole und Scopes</h2>
<h3 id="implementierung-mit-hierarchischen-verketteten-tabellen">Implementierung mit hierarchischen (verketteten) Tabellen</h3>
<p>Pro Scope wird eine Symboltabelle angelegt, dabei enthält jede Symboltabelle zusätzlich
einen Verweis auf ihre Vorgängersymboltabelle für den umgebenden Scope. Die globale
Symboltabelle wird typischerweise mit allen Schlüsselwörtern initialisiert.</p>
<ul>
<li>Wenn ein neuer Scope betreten wird, wird eine neue Symboltabelle erzeugt.</li>
<li>Scanner: Erkennt Bezeichner und sucht ihn in der Symboltabelle des aktuellen
Scopes bzw. trägt ihn dort ein und übergibt dem Parser das erkannte Token und
einen Verweis auf den Symboltabelleneintrag (<strong>Erinnerung</strong>: Der Scanner wird
i.d.R. vom Parser aus aufgerufen, d.h. der Parser setzt den aktuellen Scope!)</li>
<li>Parser:
<ul>
<li>Wird ein neues Element (ein Bezeichner) definiert, muss bestimmt werden, ob
es einen eigenen Scope hat. Wenn ja, wird eine neue Symboltabelle für den
Scope angelegt. Sie enthält alle Definitionen von Elementen, die in diesem
Scope liegen. Der Bezeichner selbst wird in die aktuelle Symboltabelle eingetragen
mit einem Verweis auf die neue Tabelle, die all die Bezeichner beinhaltet, die
außerhalb dieses Scopes nicht sichtbar sein sollen. Die Tabellen werden untereinander
verzeigert.</li>
<li>Wird ein Element deklariert oder benutzt, muss sein Eintrag in allen sichtbaren
Scopes in der richtigen Reihenfolge entlang der Verzeigerung gesucht (und je nach
Sprachdefinition auch gefunden) werden.</li>
</ul>
</li>
<li>Der Parse-Tree enthält im Knoten für den Bezeichner den Verweis in die Symboltabelle</li>
</ul>
<h3 id="klassenhierarchie-für-scopes">Klassenhierarchie für Scopes</h3>
<p>Für die Scopes wird eine Klasse <code>Scope</code> definiert mit den Methoden <code>bind()</code> (zum
Definieren von Symbolen im Scope) und <code>resolve()</code> (zum Abrufen von Symbolen aus
dem Scope oder dem umgebenden Scope).</p>
<p>Für lokale Scopes wird eine Instanz dieser Klasse angelegt, die eine Referenz auf
den einschließenden Scope im Attribut <code>enclosingScope</code> hält. Für den globalen Scope
ist diese Referenz einfach leer (<code>None</code>).</p>
<h3 id="klassen-und-interfaces-für-symbole">Klassen und Interfaces für Symbole</h3>
<p>Für die Symbole gibt es die Klasse <code>Symbol</code>, wo für jedes Symbol Name und Typ gespeichert
wird. Variablensymbole leiten direkt von dieser Klasse ab. Für die eingebauten Typen wird
ein &quot;Marker-Interface&quot; <code>Type</code> erstellt, um Variablen- und Typ-Symbole unterscheiden zu
können.</p>
<p><a href="#R-image-4e49b3384f50ee8aa11dc1be08038b3d" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/scopes/nestedscopesuml.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4e49b3384f50ee8aa11dc1be08038b3d"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/scopes/nestedscopesuml.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p><span class='origin'>Quelle: Eigene Modellierung nach einer Idee in <a href="#id_Parr2010">[Parr2010, p. 142]</a></span></p>
<h3 id="alternative-implementierung-über-einen-stack">Alternative Implementierung über einen Stack</h3>
<ul>
<li>Der Parse Tree bzw. der AST enthalten an den Knoten, die jeweils einen ganzen
Scope repräsentieren, einen Verweis auf die Symboltabelle dieses Scopes.</li>
<li>Die Scopes werden in einem Stack verwaltet.</li>
<li>Wird ein Scope betreten beim Baumdurchlauf, wird ein Verweis auf seine
Symboltabelle auf den Stack gepackt.</li>
<li>Die Suche von Bezeichnern in umliegenden Scopes erfordert ein Durchsuchen
des Stacks von oben nach unten.</li>
<li>Beim Verlassen eines Scopes beim Baumdurchlauf wird der Scope vom Stack entfernt.</li>
</ul>
<h2 id="nested-scopes-definieren-und-auflösen-von-namen">Nested Scopes: Definieren und Auflösen von Namen</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Scope</span>:
</span></span><span style="display:flex;"><span>    Scope enclosingScope    <span style="color:#75715e"># None if global (outermost) scope</span>
</span></span><span style="display:flex;"><span>    Symbol<span style="color:#f92672">&lt;</span>String, Symbol<span style="color:#f92672">&gt;</span> symbols
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">resolve</span>(name):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># do we know &#34;name&#34; here?</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> symbols[name]: <span style="color:#66d9ef">return</span> symbols[name]
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if not here, check any enclosing scope</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span>: <span style="color:#66d9ef">return</span> enclosingScope<span style="color:#f92672">.</span>resolve(name)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">except</span>: <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>     <span style="color:#75715e"># not found</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bind</span>(symbol):
</span></span><span style="display:flex;"><span>        symbols[symbol<span style="color:#f92672">.</span>name] <span style="color:#f92672">=</span> symbol
</span></span><span style="display:flex;"><span>        symbol<span style="color:#f92672">.</span>scope <span style="color:#f92672">=</span> self     <span style="color:#75715e"># track the scope in each symbol</span></span></span></code></pre></div><p><span class='origin'>Quelle: Eigene Implementierung nach einer Idee in <a href="#id_Parr2010">[Parr2010, p. 169]</a></span></p>
<p><strong>Anmerkung</strong>: In der Klasse <code>Symbol</code> kann man ein Feld <code>scope</code> vom Typ <code>Scope</code>
implementieren. Damit &quot;weiss&quot; jedes Symbol, in welchem Scope es definiert ist und
man muss sich auf der Suche nach dem Scope eines Symbols ggf. nicht erst durch
die Baumstruktur hangeln. Aus technischer Sicht verhindert das Attribut das
Aufräumen eines lokalen Scopes durch den Garbage Collector, wenn man den lokalen
Scope wieder verlässt: Jeder Scope hat eine Referenz auf den umgebenden (Eltern-)
Scope (Feld <code>enclosingScope</code>). Wenn man den aktuellen Scope &quot;nach oben&quot; verlässt,
würde der eben verlassene lokale Scope bei nächster Gelegenheit aufgeräumt, wenn
es keine weiteren Referenzen auf diesen gäbe. Da nun aber die Symbole, die in
diesem Scope definiert wurden, auf diesen verweisen, passiert das nicht :)</p>
<h2 id="nested-scopes-listener">Nested Scopes: Listener</h2>
<p>Mit einem passenden Listener kann man damit die nötigen Scopes aufbauen:</p>
<ul>
<li><code>enterStart</code>:
<ul>
<li>erzeuge neuen globalen Scope</li>
<li>definiere und pushe die eingebauten Typen</li>
</ul>
</li>
<li><code>exitVarDecl</code>:
<ul>
<li>löse den Typ der Variablen im aktuellen Scope auf</li>
<li>definiere ein neues Variablensymbol im aktuellen Scope</li>
</ul>
</li>
<li><code>exitVar</code>:
<ul>
<li>löse die Variable im aktuellen Scope auf</li>
</ul>
</li>
<li><code>enterBlock</code>:
<ul>
<li>erzeuge neuen lokalen Scope, wobei der aktuelle Scope der Elternscope ist</li>
<li>ersetze den aktuellen Scope durch den lokalen Scope</li>
</ul>
</li>
<li><code>exitBlock</code>:
<ul>
<li>ersetze den aktuellen Scope durch dessen Elternscope</li>
</ul>
</li>
</ul>
<div class='columns'>
<div class='column'>
<div class="wrap-code highlight"><pre tabindex="0"><code class="language-yacc" data-lang="yacc">start   :   stat+ ;

stat    : block | varDecl | expr &#39;;&#39; ;
block   : &#39;{&#39; stat* &#39;}&#39; ;

varDecl : type ID (&#39;=&#39; expr)? &#39;;&#39; ;
expr    : var &#39;=&#39; INT ;

var     : ID ;
type    : &#39;float&#39; | &#39;int&#39; ;</code></pre></div><p>Relevanter Ausschnitt aus der Grammatik</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>{ <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>; x <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>; }</span></span></code></pre></div></div>
<div class='column'>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyListener</span>(BaseListener):
</span></span><span style="display:flex;"><span>    Scope scope
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">enterStart</span>(Parser<span style="color:#f92672">.</span>FileContext ctx):
</span></span><span style="display:flex;"><span>        globals <span style="color:#f92672">=</span> Scope()
</span></span><span style="display:flex;"><span>        globals<span style="color:#f92672">.</span>bind(BuiltIn(<span style="color:#e6db74">&#34;int&#34;</span>))
</span></span><span style="display:flex;"><span>        globals<span style="color:#f92672">.</span>bind(BuiltIn(<span style="color:#e6db74">&#34;float&#34;</span>))
</span></span><span style="display:flex;"><span>        scope <span style="color:#f92672">=</span> globals
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">enterBlock</span>(Parser<span style="color:#f92672">.</span>BlockContext ctx):
</span></span><span style="display:flex;"><span>        scope <span style="color:#f92672">=</span> Scope(scope)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">exitBlock</span>(Parser<span style="color:#f92672">.</span>BlockContext ctx):
</span></span><span style="display:flex;"><span>        scope <span style="color:#f92672">=</span> scope<span style="color:#f92672">.</span>enclosingScope
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">exitVarDecl</span>(Parser<span style="color:#f92672">.</span>VarDeclContext ctx):
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">=</span> scope<span style="color:#f92672">.</span>resolve(ctx<span style="color:#f92672">.</span>type()<span style="color:#f92672">.</span>getText())
</span></span><span style="display:flex;"><span>        var <span style="color:#f92672">=</span> Variable(ctx<span style="color:#f92672">.</span>ID()<span style="color:#f92672">.</span>getText(), t)
</span></span><span style="display:flex;"><span>        scope<span style="color:#f92672">.</span>bind(var)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">exitVar</span>(Parser<span style="color:#f92672">.</span>VarContext ctx):
</span></span><span style="display:flex;"><span>        name <span style="color:#f92672">=</span> ctx<span style="color:#f92672">.</span>ID()<span style="color:#f92672">.</span>getText()
</span></span><span style="display:flex;"><span>        var <span style="color:#f92672">=</span> scope<span style="color:#f92672">.</span>resolve(name)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> var <span style="color:#f92672">==</span> <span style="color:#66d9ef">None</span>: error(<span style="color:#e6db74">&#34;no such var: &#34;</span> <span style="color:#f92672">+</span> name)</span></span></code></pre></div><p><em>Anmerkung</em>: Um den Code auf die Folie zu bekommen, ist dies ein Mix aus Java und Python geworden. Sry ;)</p>
</div>
</div>
<p>In der Methode <code>exitVar()</code> wird das Variablensymbol beim Ablaufen des AST
lediglich aufgelöst und ein Fehler geworfen, wenn das Variablensymbol (noch)
nicht bekannt ist. Hier könnte man weiteres Type-Checking und/oder -Propagation
ansetzen.</p>
<p>Später im Interpreter muss an dieser Stelle dann aber auch der <strong>Wert</strong> der
Variablen abgerufen werden ...</p>
<h2 id="löschen-von-symboltabellen">Löschen von Symboltabellen</h2>
<p>Möglicherweise sind die Symboltabellen nach der Identifizierungsphase der Elemente
überflüssig, weil die zusammengetragenen Informationen als Attribute im AST stehen.
Die Knoten enthalten dann Verweise auf definierende Knoten von Elementen, nicht mehr
auf Einträge in den Symboltabellen. In diesem Fall können die Symboltabellen nach der
Identifizierung gelöscht werden, wenn sie nicht z.B. für einen symbolischen Debugger
noch gebraucht werden.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Symboltabellen: Verwaltung von Symbolen und Typen (Informationen über Bezeichner)</p>
</li>
<li>
<p>Blöcke: Nested Scopes =&gt; hierarchische Organisation</p>
</li>
<li>
<p>Binden von Bezeichner gleichen Namens an ihren jeweiligen Scope =&gt; <code>bind()</code></p>
</li>
<li>
<p>Abrufen von Bezeichnern aus dem aktuellen Scope oder den Elternscopes =&gt; <code>resolve()</code></p>
</li>
</ul>


    



    



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 3</em></li> <li id='id_Parr2010'>[Parr2010] <strong>Language Implementation Patterns</strong><br>Parr, T., Pragmatic Bookshelf, 2010. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5645-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5645-6</a>.<br><em>Kapitel 6, 7 und 8</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.<br><em>Kapitel 6.4 und 8.4</em></li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Funktionen</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>Eine Funktion sind selbst ein Symbol, welches in einem Scope gilt und entsprechend
in der Symboltabelle eingetragen wird. Darüber hinaus bildet sie einen neuen
verschachtelten Scope, in dem die Funktionsparameter und der Funktionskörper definiert
werden müssen.</p>
<p>Entsprechend müssen die Strukturen für die Symboltabellen sowie das Eintragen und das
Auflösen von Symbolen erweitert werden.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/yk2x6WGhgVg' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Funktionen</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/eddc0526dca0dd506e7f1a4ea426319fca05126ebacadb328ab8ccf68f2d0b038bc58b98ab51fdf3774db1b3a4ffe5b3d2279c7db4a37fe277ed2f3b27b9e495' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Funktionen</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K3) Aufbau von Symboltabellen für Nested Scopes inkl. Strukturen/Klassen mit einem Listener</li> <li>(K3) Attribute von Klassen und Strukturen auflösen</li></ul></div>
</div>




    <h2 id="funktionen-und-scopes">Funktionen und Scopes</h2>
<div class='columns'>
<div class='column'>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> y;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    { <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> x; }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">g</span>(<span style="color:#66d9ef">int</span> z){}</span></span></code></pre></div></div>
<div class='column'>
<p><a href="#R-image-0527fa5c195d588964ee4eb9f474524d" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/functions/functionscopes.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0527fa5c195d588964ee4eb9f474524d"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/functions/functionscopes.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
</div>
</div>
<h3 id="behandlung-von-funktionsdefinitionen">Behandlung von Funktionsdefinitionen</h3>
<ul>
<li>Jeder Symboltabelleneintrag braucht ein Feld, das angibt, ob es sich um eine
Variable, eine Funktion, ... handelt. Alternativ eine eigene Klasse ableiten ...</li>
<li>Der Name der Funktion steht als Bezeichner in der Symboltabelle des Scopes, in dem
die Funktion definiert wird.</li>
<li>Der Symboltabelleneintrag für den Funktionsnamen enthält Verweise auf die Parameter.</li>
<li>Der Symboltabelleneintrag für den Funktionsnamen enthält Angaben über den Rückgabetypen.</li>
<li>Jede Funktion wird grundsätzlich wie ein neuer Scope behandelt.</li>
<li>Die formalen Parameter werden als Einträge in der Symboltabelle für den Scope der
Funktion angelegt and entsprechend als Parameter gekennzeichnet.</li>
</ul>
<h3 id="behandlung-von-funktionsaufrufen">Behandlung von Funktionsaufrufen</h3>
<ul>
<li>Der Name der Funktion steht als Bezeichner in der Symboltabelle des Scopes, in dem
die Funktion aufgerufen wird und wird als Aufruf gekennzeichnet.</li>
<li>Der Symboltabelleneintrag für den Funktionsnamen enthält Verweise auf die aktuellen
Parameter.</li>
<li>Die Definition der Funktion wird in den zugänglichen Scopes gesucht (wie oben) und
ein Verweis darauf in der Symboltabelle gespeichert.</li>
</ul>
<h2 id="erweiterung-des-klassendiagramms-für-funktions-scopes">Erweiterung des Klassendiagramms für Funktions-Scopes</h2>
<p><a href="#R-image-6d21a428ecfe6a1b3912a512ae251402" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/functions/functionscopesuml.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6d21a428ecfe6a1b3912a512ae251402"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/functions/functionscopesuml.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p><span class='origin'>Quelle: Eigene Modellierung nach einer Idee in <a href="#id_Parr2010">[Parr2010, p. 147]</a></span></p>
<h2 id="funktionen-sind-symbole-und-scopes">Funktionen sind Symbole <em>und</em> Scopes</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Function</span>(Scope, Symbol):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(name, retType, enclScope):
</span></span><span style="display:flex;"><span>        Symbol<span style="color:#f92672">.</span>__init__(name, retType)      <span style="color:#75715e"># we are &#34;Symbol&#34; ...</span>
</span></span><span style="display:flex;"><span>        enclosingScope <span style="color:#f92672">=</span> enclScope          <span style="color:#75715e"># ... and &#34;Scope&#34;</span></span></span></code></pre></div><h2 id="funktionen-listener">Funktionen: Listener</h2>
<p>Den Listener zum Aufbau der Scopes könnte man entsprechend erweitern:</p>
<ul>
<li><code>enterFuncDecl</code>:
<ul>
<li>löse den Typ der Funktion im aktuellen Scope auf</li>
<li>lege neues Funktionssymbol an, wobei der aktuelle Scope der Elternscope ist</li>
<li>definiere das Funktionssymbol im aktuellen Scope</li>
<li>ersetze den aktuellen Scope durch das Funktionssymbol</li>
</ul>
</li>
<li><code>exitFuncDecl</code>:
<ul>
<li>ersetze den aktuellen Scope durch dessen Elternscope</li>
</ul>
</li>
<li><code>exitParam</code>: analog zu <code>exitVarDecl</code>
<ul>
<li>löse den Typ der Variablen im aktuellen Scope auf</li>
<li>definiere ein neues Variablensymbol im aktuellen Scope</li>
</ul>
</li>
<li><code>exitCall</code>: analog zu <code>exitVar</code>
<ul>
<li>löse das Funktionssymbol (und die Argumente) im aktuellen Scope auf</li>
</ul>
</li>
</ul>
<div class='columns'>
<div class='column'>
<div class="wrap-code highlight"><pre tabindex="0"><code class="language-yacc" data-lang="yacc">funcDecl : type ID &#39;(&#39; params? &#39;)&#39; block ;
params   : param (&#39;,&#39; param)* ;
param    : type ID ;

call     : ID &#39;(&#39; exprList? &#39;)&#39; ;
exprList : expr (&#39;,&#39; expr)* ;</code></pre></div><p>Relevanter Ausschnitt aus der Grammatik</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#a6e22e">f</span>(x);</span></span></code></pre></div></div>
<div class='column'>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">enterFuncDecl</span>(Parser<span style="color:#f92672">.</span>FuncDeclContext ctx):
</span></span><span style="display:flex;"><span>    name <span style="color:#f92672">=</span> ctx<span style="color:#f92672">.</span>ID()<span style="color:#f92672">.</span>getText()
</span></span><span style="display:flex;"><span>    type <span style="color:#f92672">=</span> scope<span style="color:#f92672">.</span>resolve(ctx<span style="color:#f92672">.</span>type()<span style="color:#f92672">.</span>getText())
</span></span><span style="display:flex;"><span>    func <span style="color:#f92672">=</span> Function(name, type, scope)
</span></span><span style="display:flex;"><span>    scope<span style="color:#f92672">.</span>bind(func)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># change current scope to function scope</span>
</span></span><span style="display:flex;"><span>    scope <span style="color:#f92672">=</span> func
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">exitFuncDecl</span>(Parser<span style="color:#f92672">.</span>FuncDeclContext ctx):
</span></span><span style="display:flex;"><span>    scope <span style="color:#f92672">=</span> scope<span style="color:#f92672">.</span>enclosingScope
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">exitParam</span>(Parser<span style="color:#f92672">.</span>ParamContext ctx):
</span></span><span style="display:flex;"><span>    t <span style="color:#f92672">=</span> scope<span style="color:#f92672">.</span>resolve(ctx<span style="color:#f92672">.</span>type()<span style="color:#f92672">.</span>getText())
</span></span><span style="display:flex;"><span>    var <span style="color:#f92672">=</span> Variable(ctx<span style="color:#f92672">.</span>ID()<span style="color:#f92672">.</span>getText(), t)
</span></span><span style="display:flex;"><span>    scope<span style="color:#f92672">.</span>bind(var)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">exitCall</span>(Parser<span style="color:#f92672">.</span>CallContext ctx):
</span></span><span style="display:flex;"><span>    name <span style="color:#f92672">=</span> ctx<span style="color:#f92672">.</span>ID()<span style="color:#f92672">.</span>getText()
</span></span><span style="display:flex;"><span>    func <span style="color:#f92672">=</span> scope<span style="color:#f92672">.</span>resolve(name)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> func <span style="color:#f92672">==</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        error(<span style="color:#e6db74">&#34;no such function: &#34;</span> <span style="color:#f92672">+</span> name)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> func<span style="color:#f92672">.</span>type <span style="color:#f92672">==</span> Variable:
</span></span><span style="display:flex;"><span>        error(name <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; is not a function&#34;</span>)</span></span></code></pre></div><p><em>Anmerkung</em>: Um den Code auf die Folie zu bekommen, ist dies wieder ein Mix aus Java und Python geworden. Sry ;)</p>
</div>
</div>
<p>Im Vergleich zu den einfachen <em>nested scopes</em> kommt hier nur ein weiterer
Scope für den Funktionskopf dazu. Dieser spielt eine Doppelrolle: Er ist
sowohl ein Symbol (welches im Elternscope bekannt ist) als auch ein eigener
(lokaler) Scope für die Funktionsparameter.</p>
<p>Um später im Interpreter eine Funktion tatsächlich auswerten zu können, muss
im Scope der Funktion zusätzlich der AST-Knoten der Funktionsdefinition
gespeichert werden (weiteres Feld/Attribut in <code>Function</code>)!</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Symboltabellen: Verwaltung von Symbolen und Typen (Informationen über Bezeichner)</p>
</li>
<li>
<p>Funktionen: Nested Scopes =&gt; hierarchische Organisation</p>
</li>
<li>
<p>Umgang mit dem Funktionsnamen, den Parametern und dem Funktionskörper</p>
</li>
</ul>


    



    



    

    
<div class="box notices cstyle note">
  <div class="box-label"><i class="fas fa-puzzle-piece"></i> Challenges</div>
  <div class="box-content">

<p>Diskutieren Sie folgende Fragen:</p>
<ul>
<li>Warum werden überhaupt Symboltabellen eingesetzt?</li>
<li>Warum muss man zwischen Deklaration und Definition unterscheiden?</li>
<li>Erklären Sie die Verbindung einer Symboltabelle zu den einzelnen Phasen einer Compiler-Pipeline.</li>
<li>Wo liegen die Grenzen der semantischen Analyse?</li>
<li>Warum kann man im Allgemeinen nicht die Symboltabellen nutzen, um die Werte von Symbolen mit zu speichern?</li>
<li>Wieso sind Funktionen Scope und Symbol gleichzeitig?</li>
<li>Skizzieren Sie für eine Funktionsdeklaration mit Parametern die resultierende Symboltabelle.</li>
<li>Erklären Sie, wie man beim Funktionsaufruf vorgehen würde. Werden dabei Einträge in der Symboltabelle erzeugt?</li>
</ul>
</div>
</div>



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 3</em></li> <li id='id_Parr2010'>[Parr2010] <strong>Language Implementation Patterns</strong><br>Parr, T., Pragmatic Bookshelf, 2010. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5645-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5645-6</a>.<br><em>Kapitel 6, 7 und 8</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.<br><em>Kapitel 6.4 und 8.4</em></li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

<article class="default">
<h1>Strukturen und Klassen</h1>



    



    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-graduation-cap"></i> TL;DR</div>
  <div class="box-content">

<p>Strukturen und Klassen bilden jeweils einen eigenen verschachtelten Scope, worin
die Attribute und Methoden definiert werden.</p>
<p>Bei der Namensauflösung muss man dies beachten und darf beim Zugriff auf Attribute
und Methoden nicht einfach in den übergeordneten Scope schauen. Zusätzlich müssen
hier Vererbungshierarchien in der Struktur der Symboltabelle berücksichtigt werden.</p>
</div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (YouTube)</div>
  <div class="box-content">

<ul> <li><a href='https://youtu.be/-w9ljeFGq3k' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Strukturen und Klassen</a></li></ul></div>
</div>




    
    
    
    





    
    
        
        
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-podcast"></i> Videos (HSBI-Medienportal)</div>
  <div class="box-content">

<ul> <li><a href='https://www.hsbi.de/medienportal/m/61bbea5570ec17a741c3899f0822085deee317d4f5f34268eb6bcc1cc4ce6b443eb2ac397791e1fbeb5ba7a9d6c46cf08307bf3be2ccde9b7d2fc0a6ee9cfcc9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>VL Strukturen und Klassen</a></li></ul></div>
</div>




    
    





    

    

    
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K3) Aufbau von Symboltabellen für Nested Scopes inkl. Strukturen/Klassen mit einem Listener</li> <li>(K3) Attribute von Klassen und Strukturen auflösen</li></ul></div>
</div>




    <h2 id="strukturen">Strukturen</h2>
<div class='columns'>
<div class='column'>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> A {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> B {<span style="color:#66d9ef">int</span> x;};
</span></span><span style="display:flex;"><span>    B b;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> C {<span style="color:#66d9ef">int</span> z;};
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>A a;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>() {
</span></span><span style="display:flex;"><span>    A a;
</span></span><span style="display:flex;"><span>    a.b.x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></div>
<div class='column'>
<p><a href="#R-image-314b62671411cd8912ad522dd85611b0" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/classes/structscopes.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-314b62671411cd8912ad522dd85611b0"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/classes/structscopes.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
</div>
</div>
<h2 id="strukturen-erweiterung-der-symbole-und-scopes">Strukturen: Erweiterung der Symbole und Scopes</h2>
<p><a href="#R-image-c626c076682a1190467c3c2b6bead5b4" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/classes/structscopesuml.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c626c076682a1190467c3c2b6bead5b4"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/classes/structscopesuml.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p><span class='origin'>Quelle: Eigene Modellierung nach einer Idee in <a href="#id_Parr2010">[Parr2010, p. 162]</a></span></p>
<p>Strukturen stellen wie Funktionen sowohl einen Scope als auch ein Symbol dar.</p>
<p>Zusätzlich stellt eine Struktur (-definition) aber auch einen neuen Typ
dar, weshalb <code>Struct</code> auch noch das Interface <code>Type</code> &quot;implementiert&quot;.</p>
<h2 id="strukturen-auflösen-von-namen">Strukturen: Auflösen von Namen</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Struct</span>(Scope, Symbol, Type):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">resolveMember</span>(name):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> symbols[name]</span></span></code></pre></div><p>=&gt; Auflösen von &quot;<code>a.b</code>&quot; (im Listener in <code>exitMember()</code>):</p>
<ul>
<li><code>a</code> im &quot;normalen&quot; Modus mit <code>resolve()</code> über den aktuellen Scope</li>
<li>Typ von <code>a</code> ist <code>Struct</code> mit Verweis auf den eigenen Scope</li>
<li><code>b</code> nur innerhalb des <code>Struct</code>-Scopes mit <code>resolveMember()</code></li>
</ul>
<p>In der Grammatik würde es eine Regel <code>member</code> geben, die auf eine Struktur
der Art <code>ID.ID</code> anspricht (d.h. eigentlich den Teil <code>.ID</code>), und entsprechend
zu Methoden <code>enterMember()</code> und <code>exitMember()</code> im Listener führt.</p>
<p>Das Symbol für <code>a</code> hat als <code>type</code>-Attribut eine Referenz auf die <code>Struct</code>,
die ja einen eigenen Scope hat (<code>symbols</code>-Map). Darin muss dann <code>b</code> aufgelöst
werden.</p>
<h2 id="klassen">Klassen</h2>
<div class='columns'>
<div class='column'>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>() { ; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> y;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> z <span style="color:#f92672">=</span> x<span style="color:#f92672">+</span>y;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></div>
<div class='column'>
<p><a href="#R-image-6514501e788189974c47ede62db8caaf" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/classes/classscopes.png?width=auto&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: auto;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6514501e788189974c47ede62db8caaf"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/classes/classscopes.png?width=auto&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
</div>
</div>
<h2 id="klassen-erweiterung-der-symbole-und-scopes">Klassen: Erweiterung der Symbole und Scopes</h2>
<p><a href="#R-image-790d9a63525a3a62deb650d3594f6a19" class="lightbox-link"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/classes/classscopesuml.png?width=80%25&amp;height=auto" alt="" class="figure-image noborder lightbox noshadow" style="height: auto; width: 80%;" loading="lazy"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-790d9a63525a3a62deb650d3594f6a19"><img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/symboltables/classes/classscopesuml.png?width=80%25&amp;height=auto" alt="" class="lightbox-image noborder lightbox noshadow" loading="lazy"></a></p>
<p><span class='origin'>Quelle: Eigene Modellierung nach einer Idee in <a href="#id_Parr2010">[Parr2010, p. 167]</a></span></p>
<p>Bei Klassen kommt in den Tabellen ein weiterer Pointer <code>parentClazz</code> auf die
Elternklasse hinzu (in der Superklasse ist der Wert <code>None</code>).</p>
<h2 id="klassen-auflösen-von-namen">Klassen: Auflösen von Namen</h2>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Clazz</span>(Struct):
</span></span><span style="display:flex;"><span>    Clazz parentClazz   <span style="color:#75715e"># None if base class</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">resolve</span>(name):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># do we know &#34;name&#34; here?</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> symbols[name]: <span style="color:#66d9ef">return</span> symbols[name]
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># NEW: if not here, check any parent class ...</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> parentClazz <span style="color:#f92672">!=</span> <span style="color:#66d9ef">None</span>: <span style="color:#66d9ef">return</span> parentClazz<span style="color:#f92672">.</span>resolve(name)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># ... or enclosing scope if base class</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span>: <span style="color:#66d9ef">return</span> enclosingScope<span style="color:#f92672">.</span>resolve(name)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">except</span>: <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>     <span style="color:#75715e"># not found</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">resolveMember</span>(name):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> symbols[name]: <span style="color:#66d9ef">return</span> symbols[name]
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># NEW: check parent class</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span>: <span style="color:#66d9ef">return</span> parentClazz<span style="color:#f92672">.</span>resolveMember(name)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">except</span>: <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span></span></span></code></pre></div><p><span class='origin'>Quelle: Eigene Implementierung nach einer Idee in <a href="#id_Parr2010">[Parr2010, p. 172]</a></span></p>
<p>Beim Auflösen von Attributen oder Methoden muss zunächst in der Klasse selbst gesucht werden,
anschließend in der Elternklasse.</p>
<p>Beispiel (mit den obigen Klassen <code>A</code> und <code>B</code>):</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>B foo;
</span></span><span style="display:flex;"><span>foo.x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;</span></span></code></pre></div><p>Hier wird analog zu den Structs zuerst <code>foo</code> mit <code>resolve()</code> im lokalen Scope aufgelöst. Der Typ
des Symbols <code>foo</code> ist ein <code>Clazz</code>, was zugleich ein Scope ist. In diesem Scope wird nun mit
<code>resolveMember()</code> nach dem Symbol <code>x</code> gesucht. Falls es hier nicht gefunden werden kann, wird in
der Elternklasse (sofern vorhanden) weiter mit<code>resolveMember()</code> gesucht.</p>
<p>Die normale Namensauflösung wird ebenfalls erweitert um die Auflösung in der Elternklasse.</p>
<p>Beispiel:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> wuppie;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>() { ; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> y;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> z <span style="color:#f92672">=</span> x<span style="color:#f92672">+</span>y<span style="color:#f92672">+</span>wuppie;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div><p>Hier würde <code>wuppie</code> als Symbol im globalen Scope definiert werden. Beim Verarbeiten von
<code>int z = x+y+wuppie;</code> würde mit <code>resolve()</code> nach <code>wuppie</code> gesucht: Zuerst im lokalen Scope
unterhalb der Funktion, dann im Funktions-Scope, dann im Klassen-Scope von <code>B</code>. Hier sucht
<code>resolve()</code> auch zunächst lokal, geht dann aber die Vererbungshierarchie entlang (sofern
wie hier vorhanden). Erst in der Superklasse (wenn der <code>parentClazz</code>-Zeiger <code>None</code> ist),
löst <code>resolve()</code> wieder normal auf und sucht um umgebenden Scope. Auf diese Weise kann man
wie gezeigt in Klassen (Methoden) auf globale Variablen verweisen ...</p>
<p><em>Anmerkung</em>: Durch dieses Vorgehen wird im Prinzip in Methoden aus dem Zugriff auf ein Feld
<code>x</code> implizit ein <code>this.x</code> aufgelöst, wobei <code>this</code> die Klasse auflöst und <code>x</code> als Attribut darin.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<ul>
<li>
<p>Symboltabellen: Verwaltung von Symbolen und Typen (Informationen über Bezeichner)</p>
</li>
<li>
<p>Strukturen und Klassen bilden eigenen Scope</p>
</li>
<li>
<p>Strukturen/Klassen lösen etwas anders auf: Zugriff auf Attribute und Methoden</p>
</li>
</ul>


    



    



    

    
<div class="box notices cstyle note">
  <div class="box-label"><i class="fas fa-puzzle-piece"></i> Challenges</div>
  <div class="box-content">

<p><strong>Symboltabellen praktisch</strong></p>
<p>Betrachten Sie folgenden Java-Code:</p>
<ol>
<li>Umkreisen Sie alle Symbole.</li>
<li>Zeichen Sie Pfeile von Symbol-Referenzen zur jeweiligen Definition (falls vorhanden).</li>
<li>Identifizieren Sie alle benannten Scopes.</li>
<li>Identifizieren Sie alle anonymen Scopes.</li>
<li>Geben Sie die resultierende Symboltabelle an (Strukturen wie in VL besprochen).</li>
</ol>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> a.b<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> u.Y<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">X</span> <span style="color:#66d9ef">extends</span> Y <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">f</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x<span style="color:#f92672">,</span>y<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">{</span> <span style="color:#66d9ef">int</span> x<span style="color:#f92672">;</span> x <span style="color:#f92672">-</span> y <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Z</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">W</span> <span style="color:#66d9ef">extends</span> X <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> f<span style="color:#f92672">(</span><span style="color:#ae81ff">34</span><span style="color:#f92672">);</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x<span style="color:#f92672">,</span>z<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">f</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> y<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        z <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span></span></span></code></pre></div></div>
</div>



    





    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
                    
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Mogensen2017'>[Mogensen2017] <strong>Introduction to Compiler Design</strong><br>Mogensen, T., Springer, 2017. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-319-66966-3</a>. DOI <a href='https://doi.org/10.1007/978-3-319-66966-3' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>10.1007/978-3-319-66966-3</a>.<br><em>Kapitel 3</em></li> <li id='id_Parr2010'>[Parr2010] <strong>Language Implementation Patterns</strong><br>Parr, T., Pragmatic Bookshelf, 2010. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5645-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5645-6</a>.<br><em>Kapitel 6, 7 und 8</em></li> <li id='id_Parr2014'>[Parr2014] <strong>The Definitive ANTLR 4 Reference</strong><br>Parr, T., Pragmatic Bookshelf, 2014. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-1-9343-5699-9' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-1-9343-5699-9</a>.<br><em>Kapitel 6.4 und 8.4</em></li></ul></div>
</div>






<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

          </section>
<article class="default">
<h1>Typen, Type Checking und Attributierte Grammatiken</h1>



    
    




    
    
        
        
            
            
                
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="far fa-file-powerpoint"></i> Annotierte Folien</div>
  <div class="box-content">

<ul> <li><a href='https://raw.githubusercontent.com/Compiler-CampusMinden/AnnotatedSlides/master/semantics_attribgrammars.ann.ma.pdf' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>Annotierte Folien: Typen, Type Checking und attributierte Grammatiken</a></li></ul></div>
</div>




    <h1 id="motivation">Motivation</h1>
<h2 id="ist-das-alles-erlaubt">Ist das alles erlaubt?</h2>
<p>Operation erlaubt?</p>
<p>Zuweisung erlaubt?</p>
<p>Welcher Ausdruck hat welchen Typ?</p>
<p>(Welcher Code muss dafür erzeugt werden?)</p>
<ul>
<li>a = b</li>
<li>a = f(b)</li>
<li>a = b + c</li>
<li>a = b + o.nummer</li>
<li>if (f(a) == f(b))</li>
</ul>
<h2 id="taschenrechner-parsen-von-ausdrücken-wie-354">Taschenrechner: Parsen von Ausdrücken wie <code>3*5+4</code></h2>
<pre><code>expr : expr '+' term
     | term
     ;
term : term '*' DIGIT
     | DIGIT
     ;

DIGIT : [0-9] ;
</code></pre>
<p>=&gt; Wie den Ausdruck <strong>ausrechnen</strong>?</p>
<p><em>Anmerkung</em>: Heute geht es um die einfachste Form der semantischen Analyse: Anreichern einer Grammatik um
Attribute und Aktionen, die während des Parsens oder bei der Traversierung des Parse-Trees ausgewertet
werden.</p>
<h1 id="semantische-analyse">Semantische Analyse</h1>
<h2 id="das-haben-wir-bis-jetzt">Das haben wir bis jetzt</h2>
<p>Wir haben den AST vorliegen.</p>
<p>Idealerweise enthält er bei jedem Bezeichner einen Verweis in sogenannte Symboltabellen (siehe spätere Veranstaltung).</p>
<p>Beim Parsen können schon einige semantische Eigenschaften des zu übersetzenden Programms überprüft werden, falls erforderlich z. B.:</p>
<ul>
<li>Wurden alle Variablen / Objekte vor ihrer Verwendung definiert oder deklariert?</li>
<li>Wurden keine Elemente mehrfach definiert?</li>
<li>Wurden alle Funktionen / Methoden mit der richtigen Anzahl Parameter aufgerufen? (Nicht in allen Fällen schon prüfbar)</li>
<li>Haben Arrayzugriffe auch keine zu hohe Dimension?</li>
<li>Werden auch keine Namen benutzt, für die es keine Definition / Deklaration gibt?</li>
</ul>
<h2 id="was-fehlt-jetzt-noch">Was fehlt jetzt noch?</h2>
<p>Es müssen kontextsensitive Analysen durchgeführt werden, allen voran Typanalysen. Damit der &quot;richtige&quot; (Zwischen-) Code entsprechend den beteiligten Datentypen erzeugt werden kann, muss mit Hilfe des Typsystems der Sprache (aus der Sprachdefinition) überprüft werden, ob alle Operationen nur mit den korrekten Datentypen benutzt werden. Dazu gehört auch, dass nicht nur Typen von z. B. Variablen, sondern von ganzen Ausdrücken betrachtet, bzw. bestimmt werden. Damit kann dann für die Codeerzeugung festgelegt werden, welcher Operator realisiert werden muss (Überladung).</p>
<h1 id="analyse-von-datentypen">Analyse von Datentypen</h1>
<h2 id="typisierung">Typisierung</h2>
<ul>
<li>stark oder statisch typisierte Sprachen: Alle oder fast alle Typüberprüfungen finden in der semantischen Analyse statt (C, C++, Java)</li>
<li>schwach oder dynamisch typisierte Sprachen: Alle oder fast alle Typüberprüfungen finden zur Laufzeit statt (Python, Lisp, Perl)</li>
<li>untypisierte Sprachen: keinerlei Typüberprüfungen (Maschinensprache)</li>
</ul>
<h2 id="ausdrücke">Ausdrücke</h2>
<p>Jetzt muss für jeden Ausdruck im weitesten Sinne sein Typ bestimmt werden.</p>
<p>Ausdrücke können hier sein:</p>
<ul>
<li>rechte Seiten von Zuweisungen</li>
<li>linke Seiten von Zuweisungen</li>
<li>Funktions- und Methodenaufrufe</li>
<li>jeder einzelne aktuelle Parameter in Funktions- und Methodenaufrufen</li>
<li>Bedingungen in Kontrollstrukturen</li>
</ul>
<h2 id="typinferenz">Typinferenz</h2>
<p><strong>Def.:</strong> <em>Typinferenz</em> ist die Bestimmung des Datentyps jedes Bezeichners und jedes Ausdrucks im Code.</p>
<p>Der Typ eines Ausdrucks wird mit Hilfe der Typen seiner Unterausdrücke bestimmt.</p>
<p>Dabei kann man ein Kalkül mit sog. Inferenzregeln der Form</p>

<span class="math align-center">$$\frac{f:s \rightarrow t\ \ \ \ \ x:s}{f(x) : t}$$</span>
<p><em>(Wenn f den Typ</em> 
<span class="math align-center">$s \rightarrow t$</span> <em>hat und x den Typ s,
dann hat der Ausdruck f(x) den Typ t.)</em></p>
<p>benutzen. So wird dann z. B. auch Überladung aufgelöst und Polymorphie zur Laufzeit.</p>
<h2 id="statische-typprüfungen">Statische Typprüfungen</h2>
<p><strong>Bsp.:</strong> Der + - Operator:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Typ 1. Operand</th>
<th style="text-align:center">Typ 2. Operand</th>
<th style="text-align:center">Ergebnistyp</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">int</td>
<td style="text-align:center">int</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">float</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">float</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">int</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center">string</td>
<td style="text-align:center">string</td>
</tr>
</tbody>
</table>
<h2 id="typkonvertierungen">Typkonvertierungen</h2>
<ul>
<li>
<p>Der Compiler kann implizite Typkonvertierungen vornehmen, um einen Ausdruck zu verifizieren (siehe Sprachdefiniton).</p>
</li>
<li>
<p>In der Regel sind dies Typerweiterungen, z.B. von <em>int</em> nach <em>float</em>.</p>
</li>
<li>
<p>Manchmal muss zu zwei Typen der kleinste Typ gefunden werden, der beide vorhandenen Typen umschließt.</p>
</li>
<li>
<p>Explizite Typkonvertierungen heißen auch <em>Type Casts</em>.</p>
</li>
</ul>
<h2 id="nicht-grundsätzlich-statisch-mögliche-typprüfungen">Nicht grundsätzlich statisch mögliche Typprüfungen</h2>
<p><strong>Bsp.:</strong> Der ^ - Operator 
<span class="math align-center">$(a^b)$</span>:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Typ 1. Operand</th>
<th style="text-align:center">Typ 2. Operand</th>
<th style="text-align:center">Ergebnistyp</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">int 
<span class="math align-center">$\geq$</span> 0</td>
<td style="text-align:center">int</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">int &lt; 0</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">float</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td style="text-align:center">
<span class="math align-center">$\ldots$</span></td>
<td style="text-align:center">
<span class="math align-center">$\ldots$</span></td>
<td style="text-align:center">
<span class="math align-center">$\ldots$</span></td>
</tr>
</tbody>
</table>
<h1 id="attributierte-grammatiken">Attributierte Grammatiken</h1>
<h2 id="was-man-damit-macht">Was man damit macht</h2>
<p>Die Syntaxanalyse kann keine kontextsensitiven Analysen durchführen.</p>
<ul>
<li>
<p>Kontextsensitive Grammatiken benutzen: Laufzeitprobleme, das Parsen von cs-Grammatiken ist <em>PSPACE-complete</em>.</p>
</li>
<li>
<p>Der Parsergenerator <em>Bison</em> generiert LALR(1)-Parser, aber auch sog. <em>Generalized LR (GLR) Parser</em>, die bei nichtlösbaren Konflikten in der Grammatik (Reduce/Reduce oder Shift/Reduce) parallel den Input mit jede der Möglichkeiten weiterparsen.</p>
</li>
<li>
<p>Ein weiterer Ansatz, kontextsensitive Abhängigkeiten zu berücksichtigen, ist der Einsatz von attributierten Grammatiken, nicht nur zur Typanalyse, sondern evtl. auch zur Codegenerierung.</p>
</li>
<li>
<p>Informationen weden im Baum weitergegeben.</p>
</li>
</ul>
<h1 id="syntax-gesteuerte-übersetzung-attribute-und-aktionen">Syntax-gesteuerte Übersetzung: Attribute und Aktionen</h1>
<h2 id="berechnen-der-ausdrücke">Berechnen der Ausdrücke</h2>
<pre><code>expr : expr '+' term ;

translate expr ;
translate term ;
handle + ;
</code></pre>
<h2 id="attributierte-grammatiken-sdd">Attributierte Grammatiken (SDD)</h2>
<p>auch &quot;<em>syntax-directed definition</em>&quot;</p>
<p>Anreichern einer CFG:</p>
<ul>
<li>Zuordnung einer Menge von Attributen zu den Symbolen (Terminal- und Nicht-Terminal-Symbole)</li>
<li>Zuordnung einer Menge von <em>semantischen Regeln</em> (Evaluationsregeln) zu den Produktionen</li>
</ul>
<h2 id="definition-attributierte-grammatik">Definition: Attributierte Grammatik</h2>
<p>Eine <em>attributierte Grammatik</em> <em>AG = (G,A,R)</em> besteht aus folgenden Komponenten:</p>
<ul>
<li>
<p>Mengen A(X) der Attribute eines Nonterminals X</p>
</li>
<li>
<p><em>G = (N, T, P, S)</em> ist eine cf-Grammatik</p>
</li>
<li>
<p>A = 
<span class="math align-center">$\bigcup\limits_{X \in (T \cup N)} A(X)$</span> mit 
<span class="math align-center">$A(X) \cap A(Y) \neq \emptyset \Rightarrow X = Y$</span></p>
</li>
<li>
<p>R = 
<span class="math align-center">$\bigcup\limits_{p \in P} R(p)$</span> mit 
<span class="math align-center">$R(p) = \lbrace X_i.a = f(\ldots) \vert p : X_0 \rightarrow X_1 \ldots X_n \in P, X_i.a \in A(X_i), 0 \leq i \leq n\rbrace$</span></p>
</li>
</ul>
<h2 id="abgeleitete-und-ererbte-attribute">Abgeleitete und ererbte Attribute</h2>
<p>Die in einer Produktion p definierten Attribute sind</p>
<p><em>AF(p)</em> = 
<span class="math align-center">$\lbrace X_i.a \ \vert\  p : X_0 \rightarrow X_1 \ldots X_n \in P, 0 \leq i \leq n, X_i.a = f(\ldots) \in R(p)\rbrace$</span></p>
<p>Wir betrachten Grammatiken mit zwei disjunkten Teilmengen, den abgeleiteten (synthesized) Attributen <em>AS(X)</em> und den ererbten (inherited) Attributen <em>AI(X)</em>:</p>
<p><em>AS(X)</em> = 
<span class="math align-center">$\lbrace X.a\ \vert \ \exists p : X \rightarrow X_1 \ldots X_n \in P, X.a \in AF(p)\rbrace$</span></p>
<p><em>AI(X)</em> = 
<span class="math align-center">$\lbrace X.a\ \vert \ \exists q : Y \rightarrow uXv \in P, X.a\in AF(q)\rbrace$</span></p>
<p>Abgeleitete Attribute geben Informationen von unten nach oben weiter, geerbte von oben nach unten.</p>
<p>Die Abhängigkeiten der Attribute lassen sich im sog. <em>Abhängigkeitsgraphen</em> darstellen.</p>
<h2 id="beispiel-attributgrammatiken">Beispiel: Attributgrammatiken</h2>
<table>
<thead>
<tr>
<th style="text-align:left">Produktion</th>
<th style="text-align:left">Semantische Regel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>e : e1 '+' t ;</code></td>
<td style="text-align:left"><code>e.val = e1.val + t.val</code></td>
</tr>
<tr>
<td style="text-align:left"><code>e : t ;</code></td>
<td style="text-align:left"><code>e.val = t.val</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t : t1 '*' D ;</code></td>
<td style="text-align:left"><code>t.val = t1.val * D.lexval</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t : D ;</code></td>
<td style="text-align:left"><code>t.val = D.lexval</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">Produktion</th>
<th style="text-align:left">Semantische Regel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>t : D t' ;</code></td>
<td style="text-align:left"><code>t'.inh = D.lexval</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>t.syn = t'.syn</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t' : '*' D t'1 ;</code></td>
<td style="text-align:left"><code>t'1.inh = t'.inh * D.lexval</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>t'.syn = t'1.syn</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t' :</code> 
<span class="math align-center">$\epsilon$</span> <code>;</code></td>
<td style="text-align:left"><code>t'.syn = t'.inh</code></td>
</tr>
</tbody>
</table>
<p>Wenn ein Nichtterminal mehr als einmal in einer Produktion vorkommt, werden die Vorkommen nummeriert. (t, t1; t', t'1)</p>
<h1 id="s-attributgrammatiken-und-l-attributgrammatiken">S-Attributgrammatiken und L-Attributgrammatiken</h1>
<p><em>S-Attributgrammatiken</em>: Grammatiken mit nur abgeleiteten Attributen, lassen sich während des Parsens mit LR-Parsern bei beim Reduzieren berechnen mittels Tiefensuche mit Postorder-Evaluation:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">visit</span>(N):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> each child C of N (<span style="color:#f92672">from</span> left to right):
</span></span><span style="display:flex;"><span>        visit(C)
</span></span><span style="display:flex;"><span>    eval(N)     <span style="color:#75715e"># evaluate attributes of N</span></span></span></code></pre></div><p><em>L-Attributgrammatiken</em>: Grammatiken, deren gerbte Atribute nur von einem Elternknoten oder einem linken Geschwisterknoten abhängig sind. Sie können während des Parsens mit LL-Parsern berechnet werden. Ein links-nach-rechts-Durchlauf ist ausreichend.</p>
<p>Alle Kanten im Abhängigkeitsgraphen gehen nur von links nach rechts.</p>
<p>S-attributierte SDD sind eine Teilmenge von L-attributierten SDD.</p>
<h2 id="beispiel-s-attributgrammatik">Beispiel: S-Attributgrammatik</h2>
<table>
<thead>
<tr>
<th style="text-align:left">Produktion</th>
<th style="text-align:left">Semantische Regel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>e : e1 '+' t ;</code></td>
<td style="text-align:left"><code>e.val = e1.val + t.val</code></td>
</tr>
<tr>
<td style="text-align:left"><code>e : t ;</code></td>
<td style="text-align:left"><code>e.val = t.val</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t : t1 '*' D ;</code></td>
<td style="text-align:left"><code>t.val = t1.val * D.lexval</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t : D ;</code></td>
<td style="text-align:left"><code>t.val = D.lexval</code></td>
</tr>
</tbody>
</table>
<h2 id="beispiel-annotierter-syntaxbaum-für-582">Beispiel: Annotierter Syntaxbaum für <code>5*8+2</code></h2>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/attribgrammars/annotatedparsetree.png" alt="Annotierter Parse-Tree" width="auto" height="auto">
    <figcaption><p>Annotierter Parse-Tree</p></figcaption>
</figure>
<h2 id="erzeugung-des-ast-aus-dem-parse-tree-für-582">Erzeugung des AST aus dem Parse-Tree für <code>5*8+2</code></h2>
<table>
<thead>
<tr>
<th style="text-align:left">Produktion</th>
<th style="text-align:left">Semantische Regel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>e : e1 '+' t ;</code></td>
<td style="text-align:left"><code>e.node = new Node('+', e1.node, t.node)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>e : t ;</code></td>
<td style="text-align:left"><code>e.node = t.node</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t : t1 '*' D ;</code></td>
<td style="text-align:left"><code>t.node = new Node('*', t1.node, new Leaf(D, D.lexval));</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t : D ;</code></td>
<td style="text-align:left"><code>t.node = new Leaf(D, D.lexval);</code></td>
</tr>
</tbody>
</table>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/attribgrammars/ast.png" alt="AST" width="30%" height="auto">
    <figcaption><p>AST</p></figcaption>
</figure>
<h2 id="beispiel-l-attributgrammatik-berechnete-u-geerbte-attribute-ohne-links-rekursion">Beispiel: L-Attributgrammatik, berechnete u. geerbte Attribute, ohne Links-Rekursion</h2>
<p>Teil der vorigen SDD zum Parsen und Berechnen von Ausdrücken wie <code>5*8+2</code>, hier umformuliert ohne Links-Rekursion
und mit berechneten und geerbten Attributen:</p>
<div class='center'>
<table>
<thead>
<tr>
<th style="text-align:left">Produktion</th>
<th style="text-align:left">Semantische Regel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>t : D t' ;</code></td>
<td style="text-align:left"><code>t'.inh = D.lexval</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>t.syn = t'.syn</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t' : '*' D t'1 ;</code></td>
<td style="text-align:left"><code>t'1.inh = t'.inh * D.lexval</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>t'.syn = t'1.syn</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t' :</code> 
<span class="math align-center">$\epsilon$</span> <code>;</code></td>
<td style="text-align:left"><code>t'.syn = t'.inh</code></td>
</tr>
</tbody>
</table>
</div>
<div class='center'>
<div class='columns'>
<div class='column'>
<p><strong><code>5*8</code></strong> =&gt;</p>
</div>
<div class='column'>
<figure class="center">
    <img src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/frontend/semantics/attribgrammars/annotatedparsetree2.png" alt="Annotierter Parse-Tree mit berechneten und geerbten Attributen (nur Multiplikation)" width="auto" height="auto">
    <figcaption><p>Annotierter Parse-Tree mit berechneten und geerbten Attributen (nur Multiplikation)</p></figcaption>
</figure>
</div>
</div>
</div>
<p><em>Vorgriff</em>: Dies ist ein Beispiel für eine &quot;L-attributierte SDD&quot;.</p>
<h2 id="beispiel-typinferenz-für-379-oder-helloworld">Beispiel: Typinferenz für <code>3+7+9</code> oder <code>&quot;hello&quot;+&quot;world&quot;</code></h2>
<table>
<thead>
<tr>
<th style="text-align:left">Produktion</th>
<th style="text-align:left">Semantische Regel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>e : e1 '+' t ;</code></td>
<td style="text-align:left"><code>e.type = f(e1.type, t.type)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>e : t ;</code></td>
<td style="text-align:left"><code>e.type = t.type</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t : NUM ;</code></td>
<td style="text-align:left"><code>t.type = &quot;int&quot;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t : NAME ;</code></td>
<td style="text-align:left"><code>t.type = &quot;string&quot;</code></td>
</tr>
</tbody>
</table>
<h1 id="syntax-gesteuerte-übersetzung-sdt">Syntax-gesteuerte Übersetzung (SDT)</h1>
<h2 id="erweiterung-attributierter-grammatiken">Erweiterung attributierter Grammatiken</h2>
<p><em>Syntax-directed translation scheme</em>:</p>
<p>Zu den Attributen kommen <strong>Semantische Aktionen</strong>: Code-Fragmente als zusätzliche Knoten im Parse Tree an beliebigen Stellen in einer Produktion, die, wenn möglich, während des Parsens, ansonsten in weiteren Baumdurchläufen ausgeführt werden.</p>
<pre><code>e : e1  {print e1.val;}
    '+' {print &quot;+&quot;;}
    t   {e.val = e1.val + t.val; print(e.val);}
  ;
</code></pre>
<h2 id="s-attributierte-sdd-lr-grammatik-bottom-up-parsierbar">S-attributierte SDD, LR-Grammatik: Bottom-Up-Parsierbar</h2>
<p>Die Aktionen werden am Ende jeder Produktion eingefügt (&quot;postfix SDT&quot;).</p>
<table>
<thead>
<tr>
<th style="text-align:left">Produktion</th>
<th style="text-align:left">Semantische Regel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>e : e1 '+' t ;</code></td>
<td style="text-align:left"><code>e.val = e1.val + t.val</code></td>
</tr>
<tr>
<td style="text-align:left"><code>e : t ;</code></td>
<td style="text-align:left"><code>e.val = t.val</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t : t1 '*' D ;</code></td>
<td style="text-align:left"><code>t.val = t1.val * D.lexval</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t : D ;</code></td>
<td style="text-align:left"><code>t.val = D.lexval</code></td>
</tr>
</tbody>
</table>
<pre><code>e : e1 '+' t  {e.val = e1.val + t.val; print(e.val);} ;
e : t         {e.val = t.val;} ;
t : t1 '*' D  {t.val = t1.val * D.lexval;} ;
t : D         {t.val = D.lexval;} ;
</code></pre>
<h2 id="l-attributierte-sdd-ll-grammatik-top-down-parsierbar-12">L-attributierte SDD, LL-Grammatik: Top-Down-Parsierbar (1/2)</h2>
<table>
<thead>
<tr>
<th style="text-align:left">Produktion</th>
<th style="text-align:left">Semantische Regel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>t : D t' ;</code></td>
<td style="text-align:left"><code>t'.inh = D.lexval</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>t.syn = t'.syn</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t' : '*' D t'1 ;</code></td>
<td style="text-align:left"><code>t'1.inh = t'.inh * D.lexval</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>t'.syn = t'1.syn</code></td>
</tr>
<tr>
<td style="text-align:left"><code>t' :</code> 
<span class="math align-center">$\epsilon$</span> <code>;</code></td>
<td style="text-align:left"><code>t'.syn = t'.inh</code></td>
</tr>
</tbody>
</table>
<pre><code>t  : D {t'.inh = D.lexval;} t' {t.syn = t'.syn;} ;
t' : '*' D {t'1.inh = t'.inh * D.lexval;} t'1 {t'.syn = t'1.syn;} ;
t' : e {t'.syn = t'.inh;} ;
</code></pre>
<h2 id="l-attributierte-sdd-ll-grammatik-top-down-parsierbar-22">L-attributierte SDD, LL-Grammatik: Top-Down-Parsierbar (2/2)</h2>
<ul>
<li>
<p>LL-Grammatik: Jede L-attributierte SDD direkt während des Top-Down-Parsens implementierbar/berechenbar</p>
</li>
<li>
<p>SDT dazu:</p>
<ul>
<li>Aktionen, die ein berechnetes Attribut des Kopfes einer Produktion berechnen, an das Ende der Produktion anfügen</li>
<li>Aktionen, die geerbte Attribute für ein Nicht-Terminalsymbol 
<span class="math align-center">$A$</span> berechnen, direkt vor dem Auftreten von 
<span class="math align-center">$A$</span> im Körper der Produktion eingefügen</li>
</ul>
</li>
<li>
<p>Implementierung im rekursiven Abstieg:</p>
<ul>
<li>Geerbte Attribute sind Parameter für die Funktionen für die Nicht-Terminalsymbole</li>
<li>berechnete Attribute sind Rückgabewerte dieser Funktionen.</li>
</ul>
</li>
</ul>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>T t<span style="color:#960050;background-color:#1e0010">&#39;</span>(T inh) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">match</span>(<span style="color:#e6db74">&#39;*&#39;</span>);
</span></span><span style="display:flex;"><span>    T t1inh <span style="color:#f92672">=</span> inh <span style="color:#f92672">*</span> <span style="color:#a6e22e">match</span>(D);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> t<span style="color:#960050;background-color:#1e0010">&#39;</span>(t1inh);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h1 id="bison-attribute-und-aktionen">Bison: Attribute und Aktionen</h1>
<h2 id="berechnete-synthesized-attribute">Berechnete (<em>synthesized</em>) Attribute</h2>
<pre><code>expr    : expr '+' term     { $$ = $1 + $3; }
        | term
        ;
term    : term '*' DIGIT    { $$ = $1 * $3; }
        | DIGIT
        ;
</code></pre>
<p>Berechnete Attribute sind der Defaultfall in Bison.</p>
<p>Erinnerung:
Keine Typen deklariert:</p>
<ul>
<li>Bison verwendet per Default <code>int</code> für
alle Symbole (Terminalsymbole (Token) und Regeln).</li>
</ul>
<p>Keine Aktionen an den Regeln angegeben:</p>
<ul>
<li>Bison nutzt die Default-Aktion <code>$$ = $1</code>. Diese
Aktionen werden immer dann ausgeführt, wenn die rechte Seite der zugehörigen
Regel/Alternative reduziert werden konnte.</li>
</ul>
<h2 id="geerbte-inherited-attribute-12">Geerbte (<em>inherited</em>) Attribute (1/2)</h2>
<pre><code>functiondecl : returntype fname paramlist ;

returntype  : REAL    { $$ = 1; }
            | INT     { $$ = 2; }
            ;

fname : IDENTIFIER;

paramlist : IDENTIFIER           { mksymbol($0, $-1, $1); }
          | paramlist IDENTIFIER { mksymbol($0, $-1, $2); }
          ;
</code></pre>
<h2 id="geerbte-inherited-attribute-22">Geerbte (<em>inherited</em>) Attribute (2/2)</h2>
<p>Hier:</p>
<ul>
<li>
<p><code>returntype</code> und <code>fname</code> haben normale berechnete Attribute</p>
</li>
<li>
<p><code>paramlist</code>: Funktionsaufruf mit den erzeugten Werte für <code>returntype</code> und <code>fname</code> als Parameter 
<span class="math align-center">$\Rightarrow$</span> der Wert von <code>paramlist</code> ist ein &quot;geerbtes Attribut&quot;.</p>
</li>
</ul>
<p>Zugriff auf die Werte der Symbole auf dem Stack links vom aktuellen
Symbol: <code>$0</code> ist das erste
Symbol links vom aktuellen (hier <code>type</code>), <code>$-1</code> das zweite (hier <code>class</code>)
usw. ...</p>
<h2 id="probleme-mit-geerbten-attributen">Probleme mit geerbten Attributen</h2>
<pre><code>functiondecl : returntype fname paramlist ;
functiondecl : STRING paramlist ;  /* Autsch! */

...

paramlist : IDENTIFIER           { mksymbol($0, $-1, $1); }
          | paramlist IDENTIFIER { mksymbol($0, $-1, $2); }
          ;
</code></pre>
<p>Wenn vor <code>paramlist</code> ein <code>STRING</code> steht, ist <code>$0</code> der Wert von <code>STRING</code>, nicht <code>fname</code>. Analog
für <code>$-1</code>, 
<span class="math align-center">$\ldots$</span></p>
<p>Dies ist eine Quelle für schwer zu findende Bugs!</p>
<h2 id="typen-für-geerbte-attribute">Typen für geerbte Attribute</h2>
<pre><code>functiondecl : returntype fname paramlist ;

paramlist : IDENTIFIER           { mksymbol($0, $-1, $1); }
          | paramlist IDENTIFIER { mksymbol($0, $-1, $2); }
          ;
</code></pre>
<p><strong>Achtung</strong>: Für geerbte Attribute funktioniert die Deklaration von Typen
mit <code>%type</code> nicht mehr!</p>
<p>Das Symbol, auf das man sich mit <code>$0</code> bezieht, steht nicht in der Produktion,
sondern im Stack. Bison kann zur Compilezeit nicht den
Typ des referenzierten Symbols bestimmen. Falls
oben die Typen von <code>returntype</code> und <code>fname</code> jeweils <code>rval</code> und <code>fval</code>
wären, müsste man die Aktion manuell wie folgt anpassen:</p>
<pre><code>paramlist : IDENTIFIER           { mksymbol($&lt;fval&gt;0, $&lt;rval&gt;-1, $1); }
          | paramlist IDENTIFIER { mksymbol($&lt;fval&gt;0, $&lt;rval&gt;-1, $2); }
          ;
</code></pre>
<h2 id="bison-und-aktionen">Bison und Aktionen</h2>
<p>Regeln ohne Aktion ganz rechts: die Default-Aktion ist
<code>$$ = $1;</code> (Vorsicht: Die Typen von <code>$$</code> und <code>$1</code> müssen passen!)</p>
<p>Aktionen mitten in einer Regel:</p>
<pre><code>xxx : A { dosomething(); } B ;
</code></pre>
<p>wird übersetzt in:</p>
<pre><code>xxx : A dummy B ;
dummy : /* empty */ { dosomething(); }
</code></pre>
<p>Da nach dem Shiften von <code>A</code> nicht klar ist,
ob diese Regel matcht und <code>dosomething</code> ausgeführt
werden soll, übersetzt Bison die Regel <code>xxx</code> in zwei Regeln, wobei <code>dosomething()</code> ganz rechts in der Dummy-Regel steht. <code>dummy</code> ist ein normales referenzierbares Symbol.</p>
<h2 id="beispiel">Beispiel:</h2>
<pre><code>xxx : A { $$ = 42; } B C { printf(&quot;%d&quot;, $2); } ;
</code></pre>
<p>=&gt; Hier wird &quot;42&quot; ausgegeben, da mit <code>$2</code> auf den Wert der
eingebetteten Aktion zugegriffen wird.</p>
<p><code>$3</code>: Der Wert von <code>B</code></p>
<p><code>$4</code>: Der Wert von <code>C</code></p>
<h2 id="bison-konflikte-durch-eingebettete-aktionen">Bison: Konflikte durch eingebettete Aktionen</h2>
<pre><code>xxx : a | b ;

a : 'a' 'b' 'a' 'a' ;
b : 'a' 'b' 'a' 'b' ;
</code></pre>
<p>Diese Grammatik ist ohne Konflikte von Bison übersetzbar.</p>
<pre><code>xxx : a | b ;

a : 'a' 'b' { dosomething(); } 'a' 'a' ;
b : 'a' 'b' 'a' 'b' ;
</code></pre>
<p>Nach dem Lesen von &quot;<code>ab</code>&quot; gibt es wegen des identischen Vorschauzeichens
(<code>'a'</code>) einen Shift/Reduce-Konflikt.</p>
<h1 id="wrap-up">Wrap-Up</h1>
<h2 id="wrap-up-1">Wrap-Up</h2>
<ul>
<li>
<p>Die Typinferenz benötigt Informationen aus der Symboltabelle</p>
</li>
<li>
<p>Einfache semantische Analyse: Attribute und semantische Regeln (SDD)</p>
</li>
<li>
<p>Umsetzung mit SDT: Attribute und eingebettete Aktionen</p>
</li>
<li>
<p>Reihenfolge der Auswertung u.U. schwierig</p>
<p>Bestimmte SDT-Klassen können direkt beim Parsing abgearbeitet werden:</p>
<ul>
<li>S-attributierte SDD, LR-Grammatik: Bottom-Up-Parsierbar</li>
<li>L-attributierte SDD, LL-Grammatik: Top-Down-Parsierbar</li>
</ul>
<p>Ansonsten werden die Attribute und eingebetteten Aktionen in den Parse-Tree, bzw. AST,
integriert und bei einer (späteren) Traversierung abgearbeitet.</p>
</li>
</ul>


    




    
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
                
            
            
        
    
        
        

        
            
            
            
            
            

            
            
                
                    
                
            
            
            
            
            
            

            
            
                
            
            
                
                
                    
                
                
            
            
            
        
    
    

    
<div class="box notices cstyle info">
  <div class="box-label"><i class="fas fa-book-reader"></i> Quellen</div>
  <div class="box-content">

<ul> <li id='id_Aho2008'>[Aho2008] <strong>Compiler: Prinzipien, Techniken und Werkzeuge</strong><br>Aho, A. V. und Lam, M. S. und Sethi, R. und Ullman, J. D., Pearson Studium, 2008. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-3-8273-7097-6' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-3-8273-7097-6</a>.<br><em>Kapitel 2.3 und 5</em></li> <li id='id_Levine2009'>[Levine2009] <strong>flex & bison</strong><br>Levine, J., O'Reilly, 2009. ISBN <a href='https://fhb-bielefeld.digibib.net/openurl?isbn=978-0-5961-5597-1' class='icon reading' target='_blank' rel='nofollow noopener noreferrer'>978-0-5961-5597-1</a>.</li></ul></div>
</div>



    

    

    
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
        
        
        
        
    
    

    
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fas fa-lightbulb"></i> Lernziele</div>
  <div class="box-content">

<ul> <li>(K2) Konzept der attributierten Grammatiken: Anreicherung mit Attributen und semantischen Regeln</li> <li>(K2) Unterschied zwischen geerbten und berechneten Attributen</li> <li>(K2) Umsetzung von SDD mit Hilfe von SDT</li> <li>(K3) Einfache semantische Analyse mit Hilfe von attributierten Grammatiken</li></ul></div>
</div>



    








<footer class="footline"><div style="color: darkgray; font-size: small;">
<p style="margin: 4rem;">
<!-- https://creativecommons.org/choose/ -->
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0;margin:0;display:inline;" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
Unless otherwise noted, <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master">this work</a> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/bcg7" property="cc:attributionName" rel="cc:attributionURL">BC George</a>, <a xmlns:cc="https://creativecommons.org/ns#" href="https://github.com/cagix" property="cc:attributionName" rel="cc:attributionURL">Carsten Gips</a>, and <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/graphs/contributors">contributors</a> is licensed under <a rel="license" href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/LICENSE.md">CC BY-SA 4.0</a>.
See the <a href="https://github.com/Compiler-CampusMinden/CB-Vorlesung-Master/blob/master/CREDITS.md">credits</a> for a detailed list of contributing projects.

</p>
</div>

</footer>
</article>

          </section>
          </section>
        </div>
      </main>
    </div>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/clipboard.min.js?1697015446" defer></script>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/perfect-scrollbar.min.js?1697015446" defer></script>
    <script>
      function useMathJax( config ){
        if( !Object.assign ){
          
          return;
        }
        window.MathJax = Object.assign( window.MathJax || {}, {
          loader: {
            load: ['[tex]/mhchem']
          },
          startup: {
            elements: [
              '.math'
            ]
          },
          tex: {
            inlineMath: [
              ['$', '$'], 
              ['\\(', '\\)']
            ]
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/mathjax/tex-mml-chtml.js?1697015446"></script>
    <script src="https://www.hsbi.de/elearning/data/FH-Bielefeld/lm_data/lm_1371719/js/theme.js?1697015446" defer></script>
  </body>
</html>
